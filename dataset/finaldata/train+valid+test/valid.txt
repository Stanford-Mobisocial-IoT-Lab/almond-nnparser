16001	if not ,	else :
16002	call the method s.get_data , return the result .	return s . get_data ( )
16003	define the function strip_tags with an argument value .	def strip_tags ( value ) :
16004	while STR0 is contained in value and STR1 is contained in value ,	while STR0 in value and STR1 in value :
16005	call the function _strip_once with an argument value , substitute the result for new_value .	new_value = _strip_once ( value )
16006	if new_value equals value ,	if new_value == value :
16007	break from the loop execution .	break
16008	substitute new_value for value .	value = new_value
16009	return value .	return value
16010	call the function allow_lazy with an argument strip_tags , substitute the result for strip_tags .	strip_tags = allow_lazy ( strip_tags )
16011	define the function remove_tags with 2 arguments : html and tags .	def remove_tags ( html , tags ) :
16012	tags is a list containing results of the function re.escape with an argument tag , for every tag in tags split into words .	tags = [ re . escape ( tag ) for tag in tags . split ( ) ]
16013	join elements of tags into a string , separated with STR0 , format string STR1 with it , substitute the result for tags_re .	tags_re = STR0 % STR1 . join ( tags )
16014	call the function re.compile with 2 arguments : raw string STR0 formated with tags_re and re.U , substitute the result for starttag_re .	starttag_re = re . compile ( STR0 % tags_re , re . U )
16015	call the function re.compile with an argument string STR0 formated with tags_re , substitute the result for endtag_re .	endtag_re = re . compile ( STR0 % tags_re )
16016	call the function starttag_re.sub with 2 arguments : an empty string and html , substitute the result for html .	html = starttag_re . sub ( STR , html )
16017	call the function endtag_re.sub with 2 arguments : an empty string and html , substitute the result for html .	html = endtag_re . sub ( STR , html )
16018	return html .	return html
16019	call the function allow_lazy with 2 arguments : remove_tags , six.text_type , substitute the result for remove_tags .	remove_tags = allow_lazy ( remove_tags , six . text_type )
16020	define the function strip_spaces_between_tags with an argument value .	def strip_spaces_between_tags ( value ) :
16021	call the method re.sub with 3 arguments : raw string STR0 , string STR1 and result of the function force_text , called with an argument value , return the result .	return re . sub ( STR0 , STR1 , force_text ( value ) )
16022	call the function allow_lazy with 2 arguments : strip_spaces_between_tags , six.text_type , substitute the result for strip_spaces_between_tags .	strip_spaces_between_tags = allow_lazy ( strip_spaces_between_tags , six . text_type )
16023	define the function strip_entities with an argument value .	def strip_entities ( value ) :
16024	call the method re.sub with 3 arguments : raw string STR0 , empty string and result of the function force_text , called with an argument value , return the result .	return re . sub ( STR0 , STR , force_text ( value ) )
16025	call the function allow_lazy with 2 arguments : strip_entities , six.text_type , substitute the result for strip_entities .	strip_entities = allow_lazy ( strip_entities , six . text_type )
16026	define the function smart_urlquote with an argument url .	def smart_urlquote ( url ) :
16027	try ,	try :
16028	call the function urlsplit with an argument url , assign the result to scheme , netloc , path , query and fragment , respectively .	scheme , netloc , path , query , fragment = urlsplit ( url )
16029	try ,	try :
16030	call the method netloc.encode with an argument string STR0 , call the method decode on the result with an argument STR1 , substitute the result for netloc .	netloc = netloc . encode ( STR0 ) . decode ( STR1 )
16031	if UnicodeError exception is caught ,	except UnicodeError :
16032	do nothing .	pass
16033	if not ,	else :
16034	call the function urlunsplit with an argument tuple with 4 elements : scheme , netloc , path , query and fragment , substitute the result for url .	url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )
16035	if ValueError exception is caught ,	except ValueError :
16036	do nothing .	pass
16037	call the function force_str with an argument url , use the result as an argument for the call to the function unquote , substitute the result for url .	url = unquote ( force_str ( url ) )
16038	call the function quote with 2 arguments : url and safe as bytes string STR0 , substitute the result for url .	url = quote ( url , safe = STR0 )
16039	call the function force_text with an argument url , return the result .	return force_text ( url )
16040	define the function urlize with 4 arguments : text , trim_url_limit set to None , nofollow set to boolean False ,	def urlize ( text , trim_url_limit = None , nofollow = False , autoescape = False ) :
16041	define the function trim_url with 2 arguments : x and limit set to trim_url_limit .	def trim_url ( x , limit = trim_url_limit ) :
16042	if limit is None or length of x is lesser than or equal to limit ,	if limit is None or len ( x ) <= limit :
16043	return x .	return x
16044	return a string STR0 formated with elements of x up to the index equal to the maximum value between integer 0 and 3 subtracted from limit .	return STR0 % x [ : max ( 0 , limit - 3 ) ]
16045	if text is an instance of SafeData , safe_input is boolean True , otherwise is boolean False .	safe_input = isinstance ( text , SafeData )
16046	call the function force_text with an argument text , split by it word_split_re , substitute it for words .	words = word_split_re . split ( force_text ( text ) )
16047	for every i and word in enumerated iterable words ,	for i , word in enumerate ( words ) :
16048	if STR0 is contained in words or STR1 is contained in word or STR2 is contained in word ,	if STR0 in word or STR1 in word or STR2 in word :
16049	substitute empty string , word an empty string for lead , middle and trail , respectively .	lead , middle , trail = STR , word , STR
16050	for every punctuation in TRAILING_PUNCTUATION ,	for punctuation in TRAILING_PUNCTUATION :
16051	if middle ends with punctuation ,	if middle . endswith ( punctuation ) :
16052	substitute elements of middle from the beginning to the negative length of punctuation , for middle .	middle = middle [ : - len ( punctuation ) ]
16053	sum punctuation and trail , substitute the result for trail .	trail = punctuation + trail
16054	for every opening and closing in WRAPPING_PUNCTUATION ,	for opening , closing in WRAPPING_PUNCTUATION :
16055	if middle starts with opening ,	if middle . startswith ( opening ) :
16056	substitute elements of middle from length of opening index to the end , for middle .	middle = middle [ len ( opening ) : ]
16057	sum lead and opening , substitute the result for lead .	lead = lead + opening
16058	if middle ends with closing and count of occurrence of closing in middle equals count of occurrence of opening in middle incremented by one ,	if ( middle . endswith ( closing ) and middle . count ( closing ) == middle . count ( opening ) + 1 ) :
16059	substitute elements of middle from the beginning to the negative length of closing , for middle .	middle = middle [ : - len ( closing ) ]
16060	sum trail and closing , substitute the result for lead .	trail = closing + trail
16061	url is None .	url = None
16062	if nofollow is true nofollow_attr is a string STR1 , otherwise nofollow_attr is an empty string .	nofollow_attr = STR1 if nofollow else STR
16063	call the method simple_url_re.match with an argument middle , if it evaluates to true ,	if simple_url_re . match ( middle ) :
16064	call the function smart_urlquote with an argument middle , substitute the result for url .	url = smart_urlquote ( middle )
16065	otherwise if call the method simple_url_2_re.match with an argument middle evaluates to true ,	elif simple_url_2_re . match ( middle ) :
16066	call the function smart_urlquote with an argument string STR0 formated with an argument middle , substitute the result for url .	url = smart_urlquote ( STR0 % middle )
16067	otherwise if STR0 is not contained in middle and result of the function simple_email_re.match called with an argument middle ,	elif STR0 not in middle and simple_email_re . match ( middle ) :
16068	evaluates to true , split middle into two parts from the right by STR0 character , assign the resulting parts to local and domain .	local , domain = middle . rsplit ( STR0 , 1 )
16069	try ,	try :
16070	call the method domain.encode with an argument string STR0 , call the method decode on the result with an argument string STR1 , substitute the result for domain .	domain = domain . encode ( STR0 ) . decode ( STR1 )
16071	if UnicodeError exception is caught ,	except UnicodeError :
16072	skip this loop iteration .	continue
16073	url is a string STR0 formated with local and domain .	url = STR0 % ( local , domain )
16074	nofollow_attr is an empty string .	nofollow_attr = STR
16075	if url is true ,	if url :
16076	call the function trim_url with an argument middle , substitute the result for trimmed .	trimmed = trim_url ( middle )
16077	if autoescape is true and safe_input is false ,	if autoescape and not safe_input :
16078	call the function escape with an argument lead , substitute the result for lead , call the function escape with an argument trail , substitute the result for trail .	lead , trail = escape ( lead ) , escape ( trail )
16079	call the function escape with an argument url , substitute the result for url , call the function escape with an argument trimmed , substitute the result for trimmed .	url , trimmed = escape ( url ) , escape ( trimmed )
16080	middle is a string STR1 formated with url , nofollow_attr and trimmed .	middle = STR1 % ( url , nofollow_attr , trimmed )
16081	format string STR1 with lead , middle and trail , use it as an argument for the call to the function mark_safe , substitute the result for i-th element of words .	words [ i ] = mark_safe ( STR0 % ( lead , middle , trail ) )
16082	if not ,	else :
16083	if safe_input is true ,	if safe_input :
16084	call the function mark_safe with an argument word , substitute the result for i-th element of words .	words [ i ] = mark_safe ( word )
16085	otherwise if autoescape is true ,	elif autoescape :
16086	call the function escape with an argument word , substitute the result for i-th element of words .	words [ i ] = escape ( word )
16087	otherwise if safe_input is true ,	elif safe_input :
16088	call the function mark_safe with an argument word , substitute the result for i-th element of words .	words [ i ] = mark_safe ( word )
16089	otherwise if autoescape is true ,	elif autoescape :
16090	call the function escape with an argument word , substitute the result for i-th element of words .	words [ i ] = escape ( word )
16091	join elements of words into a string , return it .	return STR . join ( words )
16092	call the function allow_lazy with 2 arguments : urlize , six.text_type , substitute the result for urlize .	urlize = allow_lazy ( urlize , six . text_type )
16093	define the function avoid_wrapping with an argument value .	def avoid_wrapping ( value ) :
16094	replace every occurrence of STR in value for STR0 , return the result .	return value . replace ( STR , STR0 )
16095	from django.utils.six.moves import html_parser as _html_parse into default name space .	from django . utils . six . moves import html_parser as _html_parser
16096	import module re .	import re
16097	import module sys .	import sys
16098	substitute version_info from module sys for surrent_version .	current_version = sys . version_info
16099	set use_workaround to boolean True if current_version tuple elements are smaller than the tuple ( 2,7,3 ) , respectively , or if current_version is greater than ( 3,0 ) , but smaller than ( 3,2,3 ) , otherwise set use_workaround to boolean False .	use_workaround = ( ( current_version < ( 2 , 7 , 3 ) ) or ( current_version >= ( 3 , 0 ) and current_version < ( 3 , 2 , 3 ) ) )
16100	substitute HTMLParseError from the module _html_parser for HTMLParseError .	HTMLParseError = _html_parser . HTMLParseError
16101	if use_workaround is boolean False ,	if not use_workaround :
16102	if tuple current_version elements are greater or equal to ( 3 , 4 ) , respectively ,	if current_version >= ( 3 , 4 ) :
16103	derive the class HTMLParser from the base class HTMLParser located in the module _html_parser .	class HTMLParser ( _html_parser . HTMLParser ) :
16104	define the initialization method __init__ , with self instance of this class , convert_charrefs set to boolean False , and dictionary of arbitrary length **kwargs as arguments .	def __init__ ( self , convert_charrefs = False , ** kwargs ) :
16105	call the initialization method for the base class , _html_parser.HTMLParser.__init__ with self , convert_charrefs set to convert_charrefs and dictionary **kwargs as the arguments .	_html_parser . HTMLParser . __init__ ( self , convert_charrefs = convert_charrefs , ** kwargs )
16106	if not ,	else :
16107	substitute HTMLParser from the module _html_parser for HTMLParser .	HTMLParser = _html_parser . HTMLParser
16108	if not ,	else :
16109	compile a regular expression pattern string STR0 into a regular expression object and assign it to tagfind .	tagfind = re . compile ( STR0 )
16110	derive the class HTMLParser from the base class HTMLParser located in the module _html_parser .	class HTMLParser ( _html_parser . HTMLParser ) :
16111	define initialization method __init__ with self instance of the class as an argument .	def __init__ ( self ) :
16112	call the initialization method _html_parser.HTMLParser.__init__ ( self ) for the base class .	_html_parser . HTMLParser . __init__ ( self )
16113	set field cdata_tag for this class instance to None .	self . cdata_tag = None
16114	define method set_cdata_mode , with self class instance and tag as the arguments .	def set_cdata_mode ( self , tag ) :
16115	try ,	try :
16116	set field interesting for this class instance to interesting_cdata from module _html_parser .	self . interesting = _html_parser . interesting_cdata
16117	if AttributeError exception is caught ,	except AttributeError :
16118	replace STR0 in the string STR1 with the result of the function call tag.lower ( ) , use it and the re.I as the input arguments for function re.compile , put the result in the self.interesting .	self . interesting = re . compile ( STR0 % tag . lower ( ) , re . I )
16119	evaluate function tag.lower , without the arguments , put the result in the self.cdata_tag .	self . cdata_tag = tag . lower ( )
16120	define method clear_cdata_mode , with self class instance as an argument .	def clear_cdata_mode ( self ) :
16121	substitute _html_parser.interesting_normal for self.interesting .	self . interesting = _html_parser . interesting_normal
16122	set self.cdata_tag to None .	self . cdata_tag = None
16123	define method parse_starttag with self class instance and i as the arguments .	def parse_starttag ( self , i ) :
16124	set self.__starttag_text to None .	self . __starttag_text = None
16125	call the method self.check_for_whole_start_tag with i as an argument , substitute result for the endpos .	endpos = self . check_for_whole_start_tag ( i )
16126	if endpos is lesser than zero ,	if endpos < 0 :
16127	return endpos .	return endpos
16128	substitute self.rawdata for rawdata .	rawdata = self . rawdata
16129	slice the list from the i-th to the endpos-th element , substitute it for self.__starttag_text .	self . __starttag_text = rawdata [ i : endpos ]
16130	attrs is a empty list .	attrs = [ ]
16131	match the rawdata from the position i+1 , with tagfind pattern , assign the result to the match .	match = tagfind . match ( rawdata , i + 1 )
16132	if match evaluates to False throw an exception with the string message STR0 .	assert match , STR0
16133	find the ending position of the regular expression match of the object match , substitute the result for k .	k = match . end ( )
16134	find the first subgroup of the matched string from the match object , convert it to lowercase , substitute it for tag and self.lasttag .	self . lasttag = tag = match . group ( 1 ) . lower ( )
16135	as long k is smaller than endpos ,	while k < endpos :
16136	match the rawdata from the position k , with attrfind pattern , assign the result to the m .	m = _html_parser . attrfind . match ( rawdata , k )
16137	if m is not False , None is considered False ,	if not m :
16138	breaks from the smallest enclosing loop .	break
16139	find the first , second and third subgroup of the m regular expression match , assign the result to the attrname , rest and attrvalue , respectively .	attrname , rest , attrvalue = m . group ( 1 , 2 , 3 )
16140	if rest is not False , None is considered False ,	if not rest :
16141	set attrvalue to None .	attrvalue = None
16142	otherwise , if first and the last character of attrvalue are STRspecial charter or first and last character of attrvalue are STR character ,	elif ( attrvalue [ : 1 ] == STR == attrvalue [ - 1 : ] or attrvalue [ : 1 ] == STR == attrvalue [ - 1 : ] ) :
16143	remove first and last character from the attrvalue , substitute it for attrvalue .	attrvalue = attrvalue [ 1 : - 1 ]
16144	if attrvalue is not an empty string ,	if attrvalue :
16145	call the method unescape with attrvalue as the argument on the self class instance , substitute the result for attrvalue .	attrvalue = self . unescape ( attrvalue )
16146	form the tuple from the attrname converted to lowercase and attrvalue , append it to the end of attrs .	attrs . append ( ( attrname . lower ( ) , attrvalue ) )
16147	find the ending position of the regular expression match of the object match , substitute the result for k .	k = m . end ( )
16148	slice the rawdata string from the k-th to the endpos-th index , remove the whitespaces from the start and the end of the string , substitute it for end .	end = rawdata [ k : endpos ] . strip ( )
16149	if end is not a STR0 or STR1 character ,	if end not in ( STR0 , STR1 ) :
16150	evaluate the self.getpos ( ) and assign the result to the lineno and offset respectfully .	lineno , offset = self . getpos ( )
16151	if self.__stattag_text contains newline character ,	if STR0 in self . __starttag_text :
16152	increment the lineno by the count of the newlines in self.__starttag_text .	lineno = lineno + self . __starttag_text . count ( STR0 )
16153	find the last index of newline occurrence in self.__starttag_text , subtract it from total length of self.__starttag_text , substitute the result for offset .	offset = ( len ( self . __starttag_text ) - self . __starttag_text . rfind ( STR0 ) )
16154	if not ,	else :
16155	increment the offset by the length of self.__starttag_text .	offset = offset + len ( self . __starttag_text )
16156	slice the rawdata from k to endpos , then take the first 20 elements of the previous slice , with it replace % r in the string STR0 , call the method self.error with the resulting string as an argument .	self . error ( STR0 % ( rawdata [ k : endpos ] [ : 20 ] , ) )
16157	if string end ends with string STR0 ,	if end . endswith ( STR0 ) :
16158	call the method self.handle_startendtag with tag and attrs as the arguments .	self . handle_startendtag ( tag , attrs )
16159	if not ,	else :
16160	call the method self.handle_starttag , with tag and attrs as the arguments .	self . handle_starttag ( tag , attrs )
16161	if tag is contained in self.CDATA_CONTENT_ELEMENTS ,	if tag in self . CDATA_CONTENT_ELEMENTS :
16162	call the method self.set_cdata_mode with tag as the argument .	self . set_cdata_mode ( tag )
16163	return endpos .	return endpos
16164	define the method parse_endtag with self class instance and i as the arguments .	def parse_endtag ( self , i ) :
16165	substitute self.rawdata for rawdata .	rawdata = self . rawdata
16166	take two characters from the i-th element of rawdata , if they are not equal to the string STR1 , throw an exception with string STR0 as the message .	assert rawdata [ i : i + 2 ] == STR0 , STR1
16167	search anywhere in the rawdata string starting from the ( i+1 ) -th element for the _html_parser.endendeag , replace the result for match .	match = _html_parser . endendtag . search ( rawdata , i + 1 )
16168	if there is no match ,	if not match :
16169	return integer -1 .	return - 1
16170	find the ending position of the regular expression match of the object match , substitute the result for j .	j = match . end ( )
16171	match the rawdata from the position i , with _html_parser.endtagfind pattern , assign the result to the match .	match = _html_parser . endtagfind . match ( rawdata , i )
16172	if there is no match ,	if not match :
16173	if self.cdata_tag is not None ,	if self . cdata_tag is not None :
16174	slice the rawdata to obtain substring from i-th to j-th element , use it as the argument for the method call to the self.handle_data .	self . handle_data ( rawdata [ i : j ] )
16175	return j .	return j
16176	slice the rawdata from i-th to the j-th element , replace with it STR1 in the string STR0 , use it to call the method self.error .	self . error ( STR0 % ( rawdata [ i : j ] , ) )
16177	find the first subgroup of the matched string from the match object , strip the whitespaces from the begging and end , replace it for tag .	tag = match . group ( 1 ) . strip ( )
16178	if self.cdata_tag is not None ,	if self . cdata_tag is not None :
16179	convert tag to lowercase if it is not equal to self.cdata_tag ,	if tag . lower ( ) != self . cdata_tag :
16180	slice the rawdata to obtain substring from i-th to j-th element , use it as the argument for the method call to the self.handle_data .	self . handle_data ( rawdata [ i : j ] )
16181	return j .	return j
16182	convert tag to lowercase , use it as the argument for the call to the method self.handle_endtag .	self . handle_endtag ( tag . lower ( ) )
16183	call the method self.clear_cdata_mode .	self . clear_cdata_mode ( )
16184	return j .	return j
16185	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
16186	import module base64 .	import base64
16187	import module calendar .	import calendar
16188	import module datetime .	import datetime
16189	import module re .	import re
16190	import module sys .	import sys
16191	from binascii import Error as BinasciiError into default name space .	from binascii import Error as BinasciiError
16192	from email.utils import formatdate into default name space .	from email . utils import formatdate
16193	from django.utils.datastructures import MultiValueDict into default name space .	from django . utils . datastructures import MultiValueDict
16194	from django.utils.encoding import force_str and force_text into default name space .	from django . utils . encoding import force_str , force_text
16195	from django.utils.functional import allow_lazy into default name space .	from django . utils . functional import allow_lazy
16196	from django.utils import six into default name space .	from django . utils import six
16197	from django.utils.six.moves.urllib.parse import quote , quote_plus , unquote , unquote_plus , urlparse , urlencode as original_urlencode .	from django . utils . six . moves . urllib . parse import ( quote , quote_plus , unquote , unquote_plus , urlparse , urlencode as original_urlencode )
16198	call the function re.compile with an argument raw string STR1 , substitute the result for ETAG_MATCH .	ETAG_MATCH = re . compile ( STR1 )
16199	MONTHS is a list with 12 elements : strings STR0 , STR1 , STR2 , STR3 , STR4 , STR5 , STR6 , STR7 , STR8 , STR9 , STR10 , and STR11 .	MONTHS = STR0 . split ( )
16200	__D is a raw string STR0 .	__D = STR0
16201	__D2 is a raw string STR0 .	__D2 = STR0
16202	__M is a raw string STR0 .	__M = STR0
16203	__Y is a raw string STR0 .	__Y = STR0
16204	__Y2 is a raw string STR0 .	__Y2 = STR0
16205	__T is a raw string STR0 .	__T = STR0
16206	call the function re.compile with an argument raw string STR0 formated with __D , __M , __Y and __T , substitute the result for RFC1123_DATE .	RFC1123_DATE = re . compile ( STR0 % ( __D , __M , __Y , __T ) )
16207	call the function re.compile with an argument raw string STR0 formated with __D , __M , __Y2 and __T , substitute the result for RFC850_DATE .	RFC850_DATE = re . compile ( STR0 % ( __D , __M , __Y2 , __T ) )
16208	call the function re.compile with an argument raw string STR0 formated with __M , __D2 , __T and __Y , substitute the result for ASCTIME_DATE .	ASCTIME_DATE = re . compile ( STR0 % ( __M , __D2 , __T , __Y ) )
16209	define the function urlquote with 2 arguments : url and safe set to STR0 .	def urlquote ( url , safe = STR0 ) :
16210	call the function quote with 2 arguments : result of the function force_str called with an argument url , and result of the function force_str called with an argument safe , use the result as an argument for the call to the function force_text , return the result .	return force_text ( quote ( force_str ( url ) , force_str ( safe ) ) )
16211	call the function allow_lazy with 2 arguments : urlquote and six.text_type , substitute the result for urlquote .	urlquote = allow_lazy ( urlquote , six . text_type )
16212	define the function urlquote_plus with 2 arguments : url and safe set to an empty string .	def urlquote_plus ( url , safe = STR ) :
16213	call the function quote_plus with 2 arguments : result of the function force_str called with an argument url , and result of the function force_str called with an argument safe , use the result as an argument for the call to the function force_text , return the result .	return force_text ( quote_plus ( force_str ( url ) , force_str ( safe ) ) )
16214	call the function allow_lazy with 2 arguments : urlquote_plus and six.text_type , substitute the result for urlquote_plus .	urlquote_plus = allow_lazy ( urlquote_plus , six . text_type )
16215	define the function urlunquote with an argument quoted_url .	def urlunquote ( quoted_url ) :
16216	call the function force_str with an argument quoted_url , use the result as an argument for the call to the function unquote , use the result as an argument for the call to the function force_text , return the result .	return force_text ( unquote ( force_str ( quoted_url ) ) )
16217	call the function allow_lazy with 2 arguments : urlunquote and six.text_type , substitute the result for urlunquote .	urlunquote = allow_lazy ( urlunquote , six . text_type )
16218	define the function urlunquote with an argument quoted_url .	def urlunquote_plus ( quoted_url ) :
16219	call the function force_str with an argument quoted_url , use the result as an argument for the call to the function unquote_plus , use the result as an argument for the call to the function force_text , return the result .	return force_text ( unquote_plus ( force_str ( quoted_url ) ) )
16220	call the function allow_lazy with 2 arguments : urlunquote_plus and six.text_type , substitute the result for urlunquote_plus .	urlunquote_plus = allow_lazy ( urlunquote_plus , six . text_type )
16221	define the function urlencode with 2 arguments query and doseq set to integer 0 .	def urlencode ( query , doseq = 0 ) :
16222	if query is an instance of MultiValueDict class ,	if isinstance ( query , MultiValueDict ) :
16223	call the method query.lists , substitute the result for query .	query = query . lists ( )
16224	otherwise if query has an attribute STR0 ,	elif hasattr ( query , STR0 ) :
16225	call the method query.items , substitute the result for query .	query = query . items ( )
16226	call the function original_urlencode with 2 arguments : list with 2 elements : result of the function force_str with an argument k , and list with results of the function force_str with an argument i , for every i in v , only if v is a list or a tuple , otherwise second element is result of the function force_str with an argument v , for every k and v in query , and doseq , return the result .	return original_urlencode ( [ ( force_str ( k ) , [ force_str ( i ) for i in v ] if isinstance ( v , ( list , tuple ) ) else force_str ( v ) ) for k , v in query ] , doseq )
16227	define the function cookie_date with an argument epoch_seconds set to None .	def cookie_date ( epoch_seconds = None ) :
16228	call the function formatdate with an argument epoch_seconds , substitute the result for rfcdate .	rfcdate = formatdate ( epoch_seconds )
16229	return a string STR0 , formated with : first 7 elements of rfcdate , elements of rfcdate from 8-th to the 11-th index , and elements of rfcdate from 12-th to the 25-th index .	return STR0 % ( rfcdate [ : 7 ] , rfcdate [ 8 : 11 ] , rfcdate [ 12 : 25 ] )
16230	define the function http_date with an argument epoch_seconds set to None .	def http_date ( epoch_seconds = None ) :
16231	call the function formatdate with 2 arguments : epoch_seconds and usegmt set to boolean True , return the result .	return formatdate ( epoch_seconds , usegmt = True )
16232	define the function parse_http_date with an argument date .	def parse_http_date ( date ) :
16233	for every regex in tuple with 3 elements : RFC1123_DATE , RFC850_DATE and ASCTIME_DATE ,	for regex in RFC1123_DATE , RFC850_DATE , ASCTIME_DATE :
16234	call the method regex.match with an argument date , substitute the result for m .	m = regex . match ( date )
16235	if m is not None ,	if m is not None :
16236	break from the loop execution .	break
16237	if not ,	else :
16238	raise an ValueError exception with an argument string STR0 formated with date .	raise ValueError ( STR0 % date )
16239	try ,	try :
16240	call the method m.group with an argument string STR0 , convert the result into a string , substitute it for year .	year = int ( m . group ( STR0 ) )
16241	if year is lesser than integer 100 ,	if year < 100 :
16242	if year is lesser than integer 70 ,	if year < 70 :
16243	increment year by integer 2000 .	year += 2000
16244	if not ,	else :
16245	increment year by integer 1900 .	year += 1900
16246	call the method m.group with an argument string STR0 , convert the result to lowercase , use it as an argument for the call to the , method MONTHS.index , increment the result by integer 1 , substitute it for month .	month = MONTHS . index ( m . group ( STR0 ) . lower ( ) ) + 1
16247	call the method m.group with an argument string STR0 , convert the result into a string , substitute it for day .	day = int ( m . group ( STR0 ) )
16248	call the method m.group with an argument string STR0 , convert the result into a string , substitute it for hour .	hour = int ( m . group ( STR0 ) )
16249	call the method m.group with an argument string STR0 , convert the result into a string , substitute it for min .	min = int ( m . group ( STR0 ) )
16250	call the method m.group with an argument string STR0 , convert the result into a string , substitute it for sec .	sec = int ( m . group ( STR0 ) )
16251	call the method MONTHS.index with 6 arguments : year , month , day , hour , min and sec , substitute the result for result .	result = datetime . datetime ( year , month , day , hour , min , sec )
16252	call the method result.utctimetuple , use the result as an argument for the call to the method calendar.timegm , return the result .	return calendar . timegm ( result . utctimetuple ( ) )
16253	if Exception exception is caught .	except Exception :
16254	call the function six.reraise with 3 arguments : ValueError , instance of a class ValueError , created with an argument string , STR0 formated with date and third element of the result of the function sys.exc_info .	six . reraise ( ValueError , ValueError ( STR0 % date ) , sys . exc_info ( ) [ 2 ] )
16255	define the function parse_http_date_safe an argument date .	def parse_http_date_safe ( date ) :
16256	try ,	try :
16257	call the function parse_http_date with an argument date , return the result .	return parse_http_date ( date )
16258	if Exception exception is caught .	except Exception :
16259	do nothing .	pass
16260	define the functionbase36_to_int with an argument s .	def base36_to_int ( s ) :
16261	if length of s is greater than integer 13 ,	if len ( s ) > 13 :
16262	raise an ValueError exception with an argument string STR0 .	raise ValueError ( STR0 )
16263	convert s to integer of base 36 , substitute it for value .	value = int ( s , 36 )
16264	if six.PY2 is true and value is greater than sys.maxint ,	if six . PY2 and value > sys . maxint :
16265	raise an ValueError exception with an argument string STR0 .	raise ValueError ( STR0 )
16266	return value .	return value
16267	define the function int_to_base36 with an argument i .	def int_to_base36 ( i ) :
16268	digits is a string STR0 .	digits = STR0
16269	factor is integer 0 .	factor = 0
16270	if i is smaller than integer 0 ,	if i < 0 :
16271	raise an ValueError exception with an argument string STR0 .	raise ValueError ( STR0 )
16272	if six.PY2 is true ,	if six . PY2 :
16273	if i is not an instance of six.integer_types class ,	if not isinstance ( i , six . integer_types ) :
16274	raise an TypeError exception with an argument string STR0 .	raise TypeError ( STR0 )
16275	if i is greater than sys.maxint ,	if i > sys . maxint :
16276	raise an ValueError exception with an argument string STR0 .	raise ValueError ( STR0 )
16277	endless loop ,	while True :
16278	increment factor by one .	factor += 1
16279	bring integer 36 to the power of factor , if i is smaller than the result ,	if i < 36 ** factor :
16280	decrement factor by one .	factor -= 1
16281	break from the loop execution .	break
16282	base36 is an empty list .	base36 = [ ]
16283	while factor is greater or equal to integer 0 ,	while factor >= 0 :
16284	bring integer 36 to the power of factor , substitute the result for j .	j = 36 ** factor
16285	floor the division of i by j , use it an an index to get the element of the digits list , append the result for base36 .	base36 . append ( digits [ i // j ] )
16286	i is the reminder of the division of i by j .	i = i % j
16287	decrement factor by one .	factor -= 1
16288	join elements of base36 into a string , return it .	return STR . join ( base36 )
16289	define the function urlsafe_base64_encode with an argument s .	def urlsafe_base64_encode ( s ) :
16290	call the method base64.urlsafe_b64encode with an argument s , strip the result of the bytes string STR0 from the right , return it .	return base64 . urlsafe_b64encode ( s ) . rstrip ( STR0 )
16291	define the function urlsafe_base64_decode with an argument s .	def urlsafe_base64_decode ( s ) :
16292	call the method s.encode with an argument string STR0 , substitute the result for s .	s = s . encode ( STR0 )
16293	try ,	try :
16294	left justify string s in a field of width equal to the sum of length of s and reminder of the division of length of s by integer 4 , pad the rest of the field with bytes string STR0 , use the result as an argument for the call to the method base64.urlsafe_b64decode , return the result .	return base64 . urlsafe_b64decode ( s . ljust ( len ( s ) + len ( s ) % 4 , STR0 ) )
16295	if LookupError or BinasciiError , renamed to e , exceptions are caught .	except ( LookupError , BinasciiError ) as e :
16296	raise an ValueError exception with an argument e .	raise ValueError ( e )
16297	define the function parse_etags with an argument etag_str .	def parse_etags ( etag_str ) :
16298	call the method ETAG_MATCH.findall with an argument etag_str , substitute the result for etags .	etags = ETAG_MATCH . findall ( etag_str )
16299	if etags is false ,	if not etags :
16300	return a list with an element etag_str .	return [ etag_str ]
16301	for every e in etags call the method e.encode with an argument string STR0 , call the method decode on the result with an argument , string STR1 , substitute the list of results for etags .	etags = [ e . encode ( STR0 ) . decode ( STR1 ) for e in etags ]
16302	return etags .	return etags
16303	define the function quote_etag with an argument etag .	def quote_etag ( etag ) :
16304	return a string STR1 formated with etag , in which every occurrence of STRspecial is replaced with STR2 and every occurrence of STR , is replaced with STR3 .	return STR1 % etag . replace ( STRspecial , STR2 ) . replace ( STR , STR3 )
16305	define the function same_origin with 2 arguments url1 and url2 .	def same_origin ( url1 , url2 ) :
16306	substitute result of the function urlparse with an argument ur1 for p1 and result of the function urlparse with an argument ur2 for p2 .	p1 , p2 = urlparse ( url1 ) , urlparse ( url2 )
16307	try ,	try :
16308	if p2.scheme , p2.hostname and p2.port equals p1.scheme , p1.hostname and p1.port , respectively , return boolean True , otherwise return boolean False .	return ( p1 . scheme , p1 . hostname , p1 . port ) == ( p2 . scheme , p2 . hostname , p2 . port )
16309	if ValueError exception is caught .	except ValueError :
16310	return boolean False .	return False
16311	define the function is_safe_url with 2 arguments url and host set to None .	def is_safe_url ( url , host = None ) :
16312	if url is false ,	if not url :
16313	return boolean False .	return False
16314	replace every occurrence of STRspecial in url with STR0 .	url = url . replace ( STRspecial , STR0 )
16315	if url starts with STR0 ,	if url . startswith ( STR0 ) :
16316	return boolean False .	return False
16317	call the function urlparse with an argument url , substitute the result for url_info .	url_info = urlparse ( url )
16318	if url_info.netloc is false and url_info.scheme is true ,	if not url_info . netloc and url_info . scheme :
16319	return boolean False .	return False
16320	if url_info.netloc is false or url_info.netloc equals host , and if url_info.scheme is false or url_info.scheme equals ,	return ( ( not url_info . netloc or url_info . netloc == host ) and ( not url_info . scheme or url_info . scheme in [ STR0 , STR1 ] ) )
16321	import module warnings .	import warnings
16322	import module sys .	import sys
16323	from django.utils import six into default name space .	from django . utils import six
16324	from django.utils.deprecation import RemovedInDjango19Warning into default name space .	from django . utils . deprecation import RemovedInDjango19Warning
16325	call the function warnings.warn with 3 arguments : string STR0 , RemovedInDjango19Warning and stacklevel set to integer 2 .	warnings . warn ( STR0 , RemovedInDjango19Warning , stacklevel = 2 )
16326	define the function _resolve_name with 3 arguments : name , package and level .	def _resolve_name ( name , package , level ) :
16327	if package doesnt have an STR0 attribute ,	if not hasattr ( package , STR0 ) :
16328	raise an ValueError with an argument string STR0 .	raise ValueError ( STR0 )
16329	substitute length of package for dot .	dot = len ( package )
16330	for every x is the range of integers from level to the integer 2 , in the reversed order ,	for x in range ( level , 1 , - 1 ) :
16331	try ,	try :
16332	call the method package.rindex with 3 arguments : string STR0 , integer 0 and dot , substitute the result for dot .	dot = package . rindex ( STR0 , 0 , dot )
16333	if ValueError exception is caught ,	except ValueError :
16334	raise an ValueError with an argument string STR0 .	raise ValueError ( STR0 )
16335	return a string STR0 formated with first dot package elements and name .	return STR0 % ( package [ : dot ] , name )
16336	if six.PY3 is true ,	if six . PY3 :
16337	from importlib import import_module .	from importlib import import_module
16338	if not ,	else :
16339	define the function import_module with 3 arguments : name and package set to None .	def import_module ( name , package = None ) :
16340	if name starts with an string STR0 ,	if name . startswith ( STR0 ) :
16341	if package is false ,	if not package :
16342	raise an TypeError with an argument string STR0 .	raise TypeError ( STR0 )
16343	level is an integer 0 .	level = 0
16344	for every character in name ,	for character in name :
16345	if character is not equal to a string STR0 ,	if character != STR0 :
16346	break from the loop execution .	break
16347	increment level by one .	level += 1
16348	call the function _resolve_name with 3 arguments : name list elements from the level index to the end , package and level , substitute the result for name .	name = _resolve_name ( name [ level : ] , package , level )
16349	call the function __import__ with an argument name .	__import__ ( name )
16350	return sys.modules dictionary value under the name key .	return sys . modules [ name ]
16351	from django.core.exceptions import ValidationError into default name space .	from django . core . exceptions import ValidationError
16352	from django.utils.translation import ugettext_lazy as _ into default name space .	from django . utils . translation import ugettext_lazy as _
16353	from django.utils.six.moves import xrange into default name space .	from django . utils . six . moves import xrange
16354	define the function clean_ipv6_address with 3 arguments : ip_str , unpack_ipv4 set to boolean False and error_message ,	def clean_ipv6_address ( ip_str , unpack_ipv4 = False , error_message = _ ( STR0 ) ) :
16355	best_doublecolon_start is an integer -1 .	best_doublecolon_start = - 1
16356	best_doublecolon_len is an integer 0 .	best_doublecolon_len = 0
16357	doublecolon_start is an integer -1 .	doublecolon_start = - 1
16358	doublecolon_len is an integer 0 .	doublecolon_len = 0
16359	call he function is_valid_ipv6_address with an argument ip_str , if it evaluates to false ,	if not is_valid_ipv6_address ( ip_str ) :
16360	raise an ValidationError exception with 2 arguments : error_message and code as a string STR0 .	raise ValidationError ( error_message , code = STR0 )
16361	call the function _explode_shorthand_ip_string with an argument ip_str , substitute the result for ip_str .	ip_str = _explode_shorthand_ip_string ( ip_str )
16362	call the function _explode_shorthand_ip_string with an argument ip_str , substitute the result for ip_str .	ip_str = _sanitize_ipv4_mapping ( ip_str )
16363	if unpack_ipv4 is true ,	if unpack_ipv4 :
16364	call the function _unpack_ipv4 with an argument ip_str , substitute the result for ipv4_unpacked .	ipv4_unpacked = _unpack_ipv4 ( ip_str )
16365	if ipv4_unpacked is true ,	if ipv4_unpacked :
16366	return ipv4_unpacked .	return ipv4_unpacked
16367	split ip_str by STR0 , substitute the result for hextets .	hextets = ip_str . split ( STR0 )
16368	for every index in range of integers from 0 to length of hextets , not included ,	for index in range ( len ( hextets ) ) :
16369	get the value under the index key of the hextets dictionary , remove the leading STR0 characters , substitute the result for value under the index key of the hextets dictionary .	hextets [ index ] = hextets [ index ] . lstrip ( STR0 )
16370	get the value under the index key of the hextets dictionary , if it is false ,	if not hextets [ index ] :
16371	value under the index key of the hextets dictionary is a string STR0 .	hextets [ index ] = STR0
16372	if value under the index key of the hextets dictionary equals to string STR0 ,	if hextets [ index ] == STR0 :
16373	increment doublecolon_len by integer 1 ,	doublecolon_len += 1
16374	if doublecolon_start equals integer -1 ,	if doublecolon_start == - 1 :
16375	substitute index for doublecolon_start .	doublecolon_start = index
16376	if doublecolon_len is greater than best_doublecolon_len ,	if doublecolon_len > best_doublecolon_len :
16377	substitute doublecolon_len for best_doublecolon_len .	best_doublecolon_len = doublecolon_len
16378	substitute doublecolon_start for best_doublecolon_start .	best_doublecolon_start = doublecolon_start
16379	if not ,	else :
16380	doublecolon_len is integer 0 .	doublecolon_len = 0
16381	doublecolon_start is integer -1 .	doublecolon_start = - 1
16382	if best_doublecolon_len is greater than integer 1 ,	if best_doublecolon_len > 1 :
16383	sum best_doublecolon_start and best_doublecolon_len , substitute the result for best_doublecolon_end ,	best_doublecolon_end = ( best_doublecolon_start + best_doublecolon_len )
16384	if best_doublecolon_end equals length of hextets ,	if best_doublecolon_end == len ( hextets ) :
16385	append an empty string to list hextets .	hextets += [ STR ]
16386	replace hextets list from the best_doublecolon_start index to best_doublecolon_end index with an empty string .	hextets [ best_doublecolon_start : best_doublecolon_end ] = [ STR ]
16387	if best_doublecolon_start equals integer 0 ,	if best_doublecolon_start == 0 :
16388	prepend an empty string to hextets list .	hextets = [ STR ] + hextets
16389	join elements of hextets into a string , separated with STR0 , substitute it for result .	result = STR0 . join ( hextets )
16390	convert result to lowercase and return it .	return result . lower ( )
16391	define the function _sanitize_ipv4_mapping with an argument ip_str .	def _sanitize_ipv4_mapping ( ip_str ) :
16392	convert ip_str to lowercase , if it doesnt start with a string STR0 ,	if not ip_str . lower ( ) . startswith ( STR0 ) :
16393	return ip_str .	return ip_str
16394	split ip_str into parts by STR0 , substitute the result for hextets .	hextets = ip_str . split ( STR0 )
16395	if STR0 is contained in last elements of hextets ,	if STR0 in hextets [ - 1 ] :
16396	return ip_str .	return ip_str
16397	ipv4_address is a string STR0 formated with first 2 elements of seventh element of hextets converted into hexadecimal number , second 2 elements of seventh element of hextets converted into hexadecimal number , first 2 elements of eight element of hextets converted into hexadecimal number , second 2 elements of eight element of hextets converted into hexadecimal number .	ipv4_address = STR0 % ( int ( hextets [ 6 ] [ 0 : 2 ] , 16 ) , int ( hextets [ 6 ] [ 2 : 4 ] , 16 ) , int ( hextets [ 7 ] [ 0 : 2 ] , 16 ) , int ( hextets [ 7 ] [ 2 : 4 ] , 16 ) , )
16398	join first 5 elements of hextets into a string , separated by STR0 , substitute the result for result .	result = STR0 . join ( hextets [ 0 : 6 ] )
16399	append STR0 and ipv4_address to result .	result += STR0 + ipv4_address
16400	return result .	return result
16401	define the function _unpack_ipv4 with an argument ip_str .	def _unpack_ipv4 ( ip_str ) :
16402	convert ip_str to lowercase , if it doesnt start with a string STR0 ,	if not ip_str . lower ( ) . startswith ( STR0 ) :
16403	return None .	return None
16404	split ip_str into 2 parts from right , return second element of the result .	return ip_str . rsplit ( STR0 , 1 ) [ 1 ]
16405	define the function is_valid_ipv6_address with an argument ip_str .	def is_valid_ipv6_address ( ip_str ) :
16406	from django.core.validators import validate_ipv4_address .	from django . core . validators import validate_ipv4_address
16407	if STR0 is not contained in ip_str .	if STR0 not in ip_str :
16408	return boolean False .	return False
16409	if count of occurrence of STR0 in ip_str is greater than integer 1 ,	if ip_str . count ( STR0 ) > 1 :
16410	return boolean False .	return False
16411	if string STR0 is contained in ip_str ,	if STR0 in ip_str :
16412	return boolean False .	return False
16413	if ip_str starts with STR0 : : STR1 : , but it doesnt ends with STR2 ,	if ( ( ip_str . startswith ( STR0 ) and not ip_str . startswith ( STR1 ) ) or ( ip_str . endswith ( STR2 ) and not ip_str . endswith ( STR3 ) ) ) :
16414	return boolean False .	return False
16415	if count of occurrence of STR0 in ip_str is greater than integer 7 ,	if ip_str . count ( STR0 ) > 7 :
16416	return boolean False .	return False
16417	if STR0 is not contained in ip_str and number of occurrences of STR1 in ip_str is not equal to integer 7 ,	if STR0 not in ip_str and ip_str . count ( STR1 ) != 7 :
16418	if count of occurrence of STR0 in ip_str is not equal to integer 3 ,	if ip_str . count ( STR0 ) != 3 :
16419	return boolean False .	return False
16420	call the function _explode_shorthand_ip_string with an argument ip_str , substitute the result for ip_str .	ip_str = _explode_shorthand_ip_string ( ip_str )
16421	split ip_str into parts by STR0 , for every hextet in the result ,	for hextet in ip_str . split ( STR0 ) :
16422	if count of occurrence of STR0 in ip_str is equal to integer 3 ,	if hextet . count ( STR0 ) == 3 :
16423	split ip_str by STR0 , if last element of the result is not equal to hextet .	if not ip_str . split ( STR0 ) [ - 1 ] == hextet :
16424	return boolean False .	return False
16425	try ,	try :
16426	call the function validate_ipv4_address with an argument hextet .	validate_ipv4_address ( hextet )
16427	if ValidationError exception is caught ,	except ValidationError :
16428	return boolean False .	return False
16429	if not ,	else :
16430	try ,	try :
16431	if hextet converted to hexadecimal number is smaller than hexadecimal 0 , or hextet converted to hexadecimal number is smaller than hexadecimal FFFF ,	if int ( hextet , 16 ) < 0 or int ( hextet , 16 ) > FFFF :
16432	return boolean False .	return False
16433	if ValueError exception is caught .	except ValueError :
16434	return boolean False .	return False
16435	return boolean True .	return True
16436	define the function _explode_shorthand_ip_string with an argument ip_str .	def _explode_shorthand_ip_string ( ip_str ) :
16437	call the function _is_shorthand_ip with an argument ip_str , if it evaluates to false ,	if not _is_shorthand_ip ( ip_str ) :
16438	return ip_str .	return ip_str
16439	new_ip is an empty list ,	new_ip = [ ]
16440	split ip_str by STR0 , substitute it for hextet .	hextet = ip_str . split ( STR0 )
16441	split ip_str into parts by STR0 , if STR1 is contained in the last element of the result ,	if STR0 in ip_str . split ( STR1 ) [ - 1 ] :
16442	fill_to is an integer 7 .	fill_to = 7
16443	if not ,	else :
16444	fill_to is an integer 8 .	fill_to = 8
16445	if length of hextet is greater than integer 1 ,	if len ( hextet ) > 1 :
16446	split first and second element of hextet into parts by STR0 , sum their lengths , substitute the result for sep .	sep = len ( hextet [ 0 ] . split ( STR0 ) ) + len ( hextet [ 1 ] . split ( STR1 ) )
16447	split first element of hextet into parts by STR0 , append them to new_ip .	new_ip = hextet [ 0 ] . split ( STR0 )
16448	for every __ in range of integers from 0 up to sep subtracted from fill_to ,	for __ in xrange ( fill_to - sep ) :
16449	append string STR0 to new_ip .	new_ip . append ( STR0 )
16450	split second element of hextet into parts by STR0 , append them to new_ip .	new_ip += hextet [ 1 ] . split ( STR0 )
16451	if not ,	else :
16452	split ip_str into parts by STR0 , substitute the result for new_ip .	new_ip = ip_str . split ( STR0 )
16453	ret_ip is an empty list .	ret_ip = [ ]
16454	for every hextet in new_ip ,	for hextet in new_ip :
16455	subtract length of hextet from 4 , create a string with previous result number of character STR0 , append hextet to it , convert the result into a lowercase , append it to ret_ip .	ret_ip . append ( ( STR0 * ( 4 - len ( hextet ) ) + hextet ) . lower ( ) )
16456	join elements of ret_ip into a string separated with STR0 , return it .	return STR0 . join ( ret_ip )
16457	define the function _is_shorthand_ip with an argument ip_str .	def _is_shorthand_ip ( ip_str ) :
16458	if count of occurrence of STR0 in ip_str equals integer 1 ,	if ip_str . count ( STR0 ) == 1 :
16459	return boolean True .	return True
16460	split ip_str into parts by STR0 , for every x in the result , calculate length of x , if any is smaller than integer 4 ,	if any ( len ( x ) < 4 for x in ip_str . split ( STR0 ) ) :
16461	return boolean True .	return True
16462	return boolean False .	return False
16463	define the function is_iterable with an argument x .	def is_iterable ( x ) :
16464	try ,	try :
16465	create an iterator out of x .	iter ( x )
16466	if TypeError exception is caught ,	except TypeError :
16467	return boolean False .	return False
16468	if not ,	else :
16469	return boolean True .	return True
16470	import module re .	import re
16471	derive the class Tok from the object base class .	class Tok ( object ) :
16472	num is an integer 0 .	num = 0
16473	define the method __init__ with 4 arguments : self , name , regex and next set to None .	def __init__ ( self , name , regex , next = None ) :
16474	substitute Tok.num for self.id .	self . id = Tok . num
16475	increment Tok.num with an integer 1 .	Tok . num += 1
16476	substitute name for self.name .	self . name = name
16477	substitute regex for self.regex .	self . regex = regex
16478	substitute next for self.next .	self . next = next
16479	define the function literals with 3 arguments : choices , prefix set to an empty string and suffix set to an empty string .	def literals ( choices , prefix = STR , suffix = STR ) :
16480	for every c in choices split into words , concatenate prefix , result of the function re.escape with an argument c and suffix , and join the results into a string , separated with STR0 character , return the result .	return STR0 . join ( prefix + re . escape ( c ) + suffix for c in choices . split ( ) )
16481	derive the class Lexer from the object base class .	class Lexer ( object ) :
16482	define the method __init__ with 3 arguments self , states and first .	def __init__ ( self , states , first ) :
16483	self.regexes is an empty dictionary .	self . regexes = { }
16484	self.tokens is an empty dictionary .	self . toks = { }
16485	call the method states.items , for every state and rules in the result ,	for state , rules in states . items ( ) :
16486	parts is an empty list .	parts = [ ]
16487	for every tok in rules ,	for tok in rules :
16488	groupid is a string STR0 formated with tok.id .	groupid = STR0 % tok . id
16489	substitute tok for value under the groupid key of the self.toks dictionary .	self . toks [ groupid ] = tok
16490	format a string STR0 with groupid and tok.regex , append it to the parts .	parts . append ( STR0 % ( groupid , tok . regex ) )
16491	call the function re.compile with 2 arguments : elements of parts joined into a string , separated with STR0 , and result of bitwise OR performed on 2 operands : re.MULTILINE and re.VERBOSE , substitute the result for value under the state key of the self.regexes dictionary .	self . regexes [ state ] = re . compile ( STR0 . join ( parts ) , re . MULTILINE | re . VERBOSE )
16492	substitute first for self.state .	self . state = first
16493	define the method lex with 2 arguments self and text .	def lex ( self , text ) :
16494	substitute length of text for end .	end = len ( text )
16495	substitute self.state for state .	state = self . state
16496	substitute self.regexes for regexes .	regexes = self . regexes
16497	substitute self.toks for toks .	toks = self . toks
16498	start is an integer 0 .	start = 0
16499	while start is lesser than end .	while start < end :
16500	get the value under the state key of the regexes dictionary , call the method finditer on the result with 2 arguments : text and start ,	for match in regexes [ state ] . finditer ( text , start ) :
16501	for every match in the result , substitute match.lastgroup for name .	name = match . lastgroup
16502	substitute value under the name key of the toks dictionary for tok .	tok = toks [ name ]
16503	call the method match.group with an arugument name , substitute the result for toktext .	toktext = match . group ( name )
16504	increment start by length of toktext .	start += len ( toktext )
16505	yield a tuple with 2 elements : tok.name and toktext .	yield ( tok . name , toktext )
16506	if tok.next is true ,	if tok . next :
16507	substitute tok.next for state .	state = tok . next
16508	break from the loop execution .	break
16509	substitute state for self.state .	self . state = state
16510	derive the class JsLexer from the Lexer base class .	class JsLexer ( Lexer ) :
16511	both_before is a list containing 14 elements , all of them are instances of Tok class , created with 2 arguments , a string and a raw string .	both_before = [ Tok ( STR4 , STR5 ) , Tok ( STR6 , STR7 ) , Tok ( STR8 , STR9 ) , Tok ( STR10 , literals ( STR0 , suffix = STR11 ) , next = STR31 ) , Tok ( STR12 , literals ( STR13 , suffix = STR14 ) , next = STR32 ) , Tok ( STR15 , STR1 , next = STR33 ) , Tok ( STR16 , STR17 , next = STR34 ) , Tok ( STR18 , STR19 ) , Tok ( STR20 , STR2 , next = STR35 ) , Tok ( STR21 , literals ( STR3 ) , next = STR22 ) , Tok ( STR23 , literals ( STR24 ) , next = STR36 ) , Tok ( STR25 , literals ( STR26 ) , next = STR37 ) , Tok ( STR27 , literals ( STR39 ) , next = STR40 ) , ]
16512	both_after is an list with an element instance of Tok class , created with 2 arguments : string STR0 and raw string STR1 .	both_after = [ Tok ( STR0 , STR1 ) , ]
16513	states is a dictionary with 2 arguments : appended list with an element instance of a class Tok , created with 3 arguments : STR0 , result of the function literals called with an argument string STR1 and next as a string STR3 , to the both_before , appended both_after to the previous result , for STR4 and appended list with an element instance of a class Tok , created with 3 arguments : string STR2 , raw string STR5 , and next as a string STR6 , to the both_before , appended both_after to the previous result for STR7 .	states = { STR4 : both_before + [ Tok ( STR1 , literals ( STR2 ) , next = STR5 ) , ] + both_after , STR6 : both_before + [ Tok ( STR3 , STR0 , next = STR7 ) , ] + both_after , }
16514	define the method __init__ with an argument self .	def __init__ ( self ) :
16515	call the method __init__ with 2 arguments : self.states and string STR0 from the base class of the class JsLexer .	super ( JsLexer , self ) . __init__ ( self . states , STR0 )
16516	define the function prepare_js_for_gettext with an argument js .	def prepare_js_for_gettext ( js ) :
16517	define the function escape_quotes with an argument m .	def escape_quotes ( m ) :
16518	call the method m.group with an argument integer 0 , substitute the result for s .	s = m . group ( 0 )
16519	if s equals a string STR ,	if s == STR :
16520	return an raw string STR .	return STR 
16521	if not ,	else :
16522	return s .	return s
16523	lexer is an instance of JsLexer class .	lexer = JsLexer ( )
16524	c is an empty list .	c = [ ]
16525	call the method lexer.lex with an arguments js , for every name and tok in the result ,	for name , tok in lexer . lex ( js ) :
16526	if name equals a string STR0 ,	if name == STR0 :
16527	tok is a string STR1 ,	tok = STR1
16528	otherwise if name starts with a string STR0 ,	elif name == STR0 :
16529	if tok starts with STR ,	if tok . startswith ( STR ) :
16530	call the function re.sub with 3 arguments : raw string STR0 , escape_quotes and tok without the first and last element , substitute the result for guts .	guts = re . sub ( STR0 , escape_quotes , tok [ 1 : - 1 ] )
16531	concatenate string STR , guts and string STR , substitute the result for tok .	tok = STR + guts + STR
16532	otherwise if name equals a string STR0 .	elif name == STR0 :
16533	replace every occurrence of STRspecial in tok with STR0 , substitute the result for tok .	tok = tok . replace ( STR0 , STR1 )
16534	append tok to c .	c . append ( tok )
16535	join elements of c into a string , return it .	return STR . join ( c )
16536	import module logging .	import logging
16537	import module sys .	import sys
16538	import module warnings .	import warnings
16539	from django.conf import settings into default name space .	from django . conf import settings
16540	from django.core import mail into default name space .	from django . core import mail
16541	from django.core.mail import get_connection into default name space .	from django . core . mail import get_connection
16542	from django.utils.deprecation import RemovedInNextVersionWarning into default name space .	from django . utils . deprecation import RemovedInNextVersionWarning
16543	from django.utils.module_loading import import_string into default name space .	from django . utils . module_loading import import_string
16544	from django.views.debug import ExceptionReporter and get_exception_reporter_filter into default name space .	from django . views . debug import ExceptionReporter , get_exception_reporter_filter
16545	from logging import NullHandler .	from logging import NullHandler
16546	from logging.config import dictConfig .	from logging . config import dictConfig
16547	substitute logging.getLogger for getLogger .	getLogger = logging . getLogger
16548	DEFAULT_LOGGING is a dictionary with 5 initial entries : 1 for STR0 , False for STR1 , and 3 additional pairs of dictionaries for string .	DEFAULT_LOGGING = { STR0 : 1 , STR1 : False , STR2 : { STR3 : { STR4 : STR5 , } , STR6 : { STR7 : STR8 , } , } , STR9 : { STR10 : { STR11 : STR12 , STR13 : [ STR14 ] , STR15 : STR16 , } , STR17 : { STR18 : STR19 , } , STR20 : { STR21 : STR22 , STR23 : [ STR24 ] , STR25 : STR26 } } , STR27 : { STR28 : { STR29 : [ STR30 ] , } , STR31 : { STR32 : [ STR33 ] , STR34 : STR35 , STR36 : False , } , STR37 : { STR38 : [ STR39 ] , STR40 : STR41 , STR42 : False , } , STR43 : { STR44 : [ STR45 ] , } , } }
16549	define the function configure_logging with 2 arguments : logging_config and logging_settings .	def configure_logging ( logging_config , logging_settings ) :
16550	if sys.warnoptions is false ,	if not sys . warnoptions :
16551	call the method logging.captureWarnings with an argument boolean True .	logging . captureWarnings ( True )
16552	call the function warnings.simplefilter with 2 arguments : string STR0 and RemovedInNextVersionWarning .	warnings . simplefilter ( STR0 , RemovedInNextVersionWarning )
16553	if logging_config is true ,	if logging_config :
16554	call the function import_string with an argument logging_config , substitute the result for logging_config_func .	logging_config_func = import_string ( logging_config )
16555	call the function logging_config_func with an argument DEFAULT_LOGGING .	logging_config_func ( DEFAULT_LOGGING )
16556	if logging_settings is true ,	if logging_settings :
16557	call the function logging_config_func with an argument logging_settings .	logging_config_func ( logging_settings )
16558	derive the class AdminEmailHandler from logging.Handler base class .	class AdminEmailHandler ( logging . Handler ) :
16559	define the method __init__ with 3 arguments : self , include_html set to boolean False and email_backend set to None .	def __init__ ( self , include_html = False , email_backend = None ) :
16560	call the method logging.Handler.__init__ with an argument self .	logging . Handler . __init__ ( self )
16561	substitute include_html for self.include_html .	self . include_html = include_html
16562	substitute email_backend for self.email_backend .	self . email_backend = email_backend
16563	define the method emit with 2 arguments : self and record .	def emit ( self , record ) :
16564	try ,	try :
16565	substitute record.request for request .	request = record . request
16566	subject is an string STR0 , formated with record.levelname , string STR1 if value under the STR2 key , of the request.META dictionary is contained in settings.INTERNAL_IPS , otherwise use string STR3 , and result of the method record.getMessage .	subject = STR0 % ( record . levelname , ( STR1 if request . META . get ( STR2 ) in settings . INTERNAL_IPS else STR3 ) , record . getMessage ( ) )
16567	call the function get_exception_reporter_filter with an argument request , substitute the result for filter .	filter = get_exception_reporter_filter ( request )
16568	call the method filter.get_request_repr with an argument request , format string STR0 with the result , substitute the result for request_repr .	request_repr = STR0 . format ( filter . get_request_repr ( request ) )
16569	if Exception exception is caught ,	except Exception :
16570	subject is an string STR0 formated with record.levelname and result of the method record.getMessage , respectively .	subject = STR0 % ( record . levelname , record . getMessage ( ) )
16571	request is None .	request = None
16572	request_repr is a string STR0 .	request_repr = STR0
16573	call the function self.format_subject with an argument subject , substitute the result for subject .	subject = self . format_subject ( subject )
16574	if record.exc_info is true ,	if record . exc_info :
16575	substitute record.exc_info for exc_info .	exc_info = record . exc_info
16576	if not ,	else :
16577	exc_info is an tuple with 3 elements : None , result of method record.getMessage and None .	exc_info = ( None , record . getMessage ( ) , None )
16578	message is an string STR0 formated with the result of the metod self.format with an argument record , and request_repr , respectively .	message = STR0 % ( self . format ( record ) , request_repr )
16579	reporter is an instance of ExceptionReporter class , created with 3 arguments : request , is_email as boolean True , unpacked list exc_info .	reporter = ExceptionReporter ( request , is_email = True , * exc_info )
16580	if self.include_html is true , call the method reporter.get_traceback_html and substitute the result for html_message , otherwise html_message is None .	html_message = reporter . get_traceback_html ( ) if self . include_html else None
16581	call the method mail.mail_admins with 5 arguments : subject , message , fail_silently as boolean True , tml_message as html_message , and connection as the result of the method self.connection .	mail . mail_admins ( subject , message , fail_silently = True , html_message = html_message , connection = self . connection ( ) )
16582	define the connection with an argument self .	def connection ( self ) :
16583	call the function get_connection with 2 arguments : backend set to self.email_backend and fail_silently set to boolean True .	return get_connection ( backend = self . email_backend , fail_silently = True )
16584	define the method format_subject with 2 arguments : self and subject .	def format_subject ( self , subject ) :
16585	replace every occurrence of STR0 in subject with STR1 and replace every occurrence of STRspecial in subject with STR2 , substitute the result for formatted_subject .	formatted_subject = subject . replace ( STR0 , STR1 ) . replace ( STRspecial , STR2 )
16586	return first 989 elements of formatted_subject .	return formatted_subject [ : 989 ]
16587	derive the class CallbackFilter from logging.Filter base class .	class CallbackFilter ( logging . Filter ) :
16588	define the method __init__ with 2 arguments : self and callback .	def __init__ ( self , callback ) :
16589	substitute callback for self.callback .	self . callback = callback
16590	define the method filter with 2 arguments : self and record .	def filter ( self , record ) :
16591	call the method self.callback with an argument record , if the result evaluates to true ,	if self . callback ( record ) :
16592	return integer 1 .	return 1
16593	return integer 0 .	return 0
16594	derive the class RequireDebugFalse from logging.Filter base class .	class RequireDebugFalse ( logging . Filter ) :
16595	define the method filter with 2 arguments : self and record .	def filter ( self , record ) :
16596	if settings.DEBUG is true , return boolean False , otherwise return boolean True .	return not settings . DEBUG
16597	derive the class RequireDebugTrue from logging.Filter base class .	class RequireDebugTrue ( logging . Filter ) :
16598	define the method filter with 2 arguments : self and record .	def filter ( self , record ) :
16599	return settings.DEBUG .	return settings . DEBUG
16600	try ,	try :
16601	from functools import lru_cache .	from functools import lru_cache
16602	if ImportError exception is caught .	except ImportError :
16603	from collections import namedtuple .	from collections import namedtuple
16604	from functools import update_wrapper .	from functools import update_wrapper
16605	from threading import RLock .	from threading import RLock
16606	_CacheInfo is an instance of namedtuple class created with 2 arguments : string STR0 and a list with 4 elements : string STR4 , STR1 , STR2 and STR3 .	_CacheInfo = namedtuple ( STR0 , [ STR1 , STR2 , STR3 , STR4 ] )
16607	derive class _HashedSeq from list base class .	class _HashedSeq ( list ) :
16608	__slots__ is a string STR0 .	__slots__ = STR0
16609	define the method __init__ with 3 arguments : self , tup and hash set to hash .	def __init__ ( self , tup , hash = hash ) :
16610	substitute tup for elements of self .	self [ : ] = tup
16611	get the hash value of the tup , substitute it for self.hashvalue .	self . hashvalue = hash ( tup )
16612	define the method __hash__ with an argument self .	def __hash__ ( self ) :
16613	return self.hashvalue .	return self . hashvalue
16614	define the function _make_key with 9 arguments : args , kwds , typed , kwd_mark as a tuple with an element result of the function object ,	def _make_key ( args , kwds , typed , kwd_mark = ( object ( ) , ) , fasttypes = { int , str , frozenset , type ( None ) } , sorted = sorted , tuple = tuple , type = type , len = len ) :
16615	substitute args for key .	key = args
16616	if kwds is true ,	if kwds :
16617	sort elements of kwds , substitute the result for sorted_items .	sorted_items = sorted ( kwds . items ( ) )
16618	increment key by kwd_mark .	key += kwd_mark
16619	for every item in sorted_items ,	for item in sorted_items :
16620	increment key by item .	key += item
16621	if typed is true ,	if typed :
16622	create a tuple out of types of v , for every v in args , extend key tuple with the result .	key += tuple ( type ( v ) for v in args )
16623	if kwds is true ,	if kwds :
16624	create a tuple out of types of v , for every k and v in sorted_items , extend key tuple with the result .	key += tuple ( type ( v ) for k , v in sorted_items )
16625	otherwise if length of key equals integer 1 and type of first element of key is contained in fasttypes ,	elif len ( key ) == 1 and type ( key [ 0 ] ) in fasttypes :
16626	return first element of key .	return key [ 0 ]
16627	return instance of _HashedSeq class , created with an argument key .	return _HashedSeq ( key )
16628	define the function lru_cache with 2 arguments maxsize set to integer 100 and typed set to boolean False .	def lru_cache ( maxsize = 100 , typed = False ) :
16629	define the function decorating_function with an argument user_function .	def decorating_function ( user_function ) :
16630	cache is an empty dictionary .	cache = dict ( )
16631	stats is an list with 2 elements : 2 integers 0 .	stats = [ 0 , 0 ]
16632	HITS and MISSES are integer 0 and 1 , respectively .	HITS , MISSES = 0 , 1
16633	substitute _make_key for make_key .	make_key = _make_key
16634	substitute cache.get for cache_get .	cache_get = cache . get
16635	substitute len for _len .	_len = len
16636	lock is an instance of RLock class .	lock = RLock ( )
16637	root is an empty list .	root = [ ]
16638	root is a list with elements : root , root , None and None .	root [ : ] = [ root , root , None , None ]
16639	nonlocal_root is an list with an element root .	nonlocal_root = [ root ]
16640	substitute integers 0 , 1 , 2 and 3 for PREV , NEXT , KEY and RESULT , respectivley .	PREV , NEXT , KEY , RESULT = 0 , 1 , 2 , 3
16641	if maxsize equals integer 0 ,	if maxsize == 0 :
16642	define the function wrapper with 2 arguments : unpacked list args and unpacked dictionary kwds .	def wrapper ( * args , ** kwds ) :
16643	call the function user_function with 2 arguments : unpacked list args and unpacked dictionary kwds , substitute the result for result .	result = user_function ( * args , ** kwds )
16644	increment stats dictionary value under the MISSES key by integer 1 .	stats [ MISSES ] += 1
16645	return result .	return result
16646	otherwise if maxsize is None ,	elif maxsize is None :
16647	define the function wrapper with 2 arguments : unpacked list args and unpacked dictionary kwds .	def wrapper ( * args , ** kwds ) :
16648	call the function make_key with 3 arguments : args , kwds and typed , substitute the result for key .	key = make_key ( args , kwds , typed )
16649	call the function cache_get with 2 arguments : key and root , substitute the result for result .	result = cache_get ( key , root )
16650	if result is not root ,	if result is not root :
16651	increment stats dictionary value under the HITS key by integer 1 .	stats [ HITS ] += 1
16652	return result .	return result
16653	call the function user_function with 2 arguments unpacked list args and unpacked dictionary kwds , substitute the result for result .	result = user_function ( * args , ** kwds )
16654	substitute result for cache dictionary value under the key key .	cache [ key ] = result
16655	increment stats dictionary value under the MISSES key by integer 1 .	stats [ MISSES ] += 1
16656	return result .	return result
16657	if not ,	else :
16658	define the function wrapper with 2 arguments : unpacked list args and unpacked dictionary kwds .	def wrapper ( * args , ** kwds ) :
16659	if kwds is true or typed is true , call the function make_key with 3 arguments : args , kwds and typed , substitute the result for key , otherwise substitute args for key .	key = make_key ( args , kwds , typed ) if kwds or typed else args
16660	with lock ,	with lock :
16661	call the function cache_get with an argument key , substitute the result for link .	link = cache_get ( key )
16662	if link is not None ,	if link is not None :
16663	substitute nonlocal_root for a tuple with an element root .	root , = nonlocal_root
16664	substitute link for link_prev , link_next , key and result , respectively .	link_prev , link_next , key , result = link
16665	substitute link_next for value under the NEXT key of the link_prev dictionary .	link_prev [ NEXT ] = link_next
16666	substitute link_prev for value under the PREV key of the link_next dictionary .	link_next [ PREV ] = link_prev
16667	substitute value under the PREV key of the root dictionary for last .	last = root [ PREV ]
16668	substitute link for values under the NEXT key of the last dictionary and PREV key of the root dictionary .	last [ NEXT ] = root [ PREV ] = link
16669	substitute last for value under the PREV key of the link dictionary .	link [ PREV ] = last
16670	substitute root for value under the NEXT key of the link dictionary .	link [ NEXT ] = root
16671	increment stats dictionary value under the HITS key by integer 1 .	stats [ HITS ] += 1
16672	return result .	return result
16673	call the function user_function with 2 arguments : unpacked list args and unpacked dictionary kwds , substitute the result for result .	result = user_function ( * args , ** kwds )
16674	with lock ,	with lock :
16675	substitute nonlocal_root for tuple root .	root , = nonlocal_root
16676	if key is contained in cache ,	if key in cache :
16677	do nothing .	pass
16678	otherwise if result of the call to the function _len with an argument cache is greater than or equal to maxsize ,	elif _len ( cache ) >= maxsize :
16679	substitute root for oldroot .	oldroot = root
16680	substitute key for value under the KEY key of the oldroot dictionary .	oldroot [ KEY ] = key
16681	substitute result for value under the RESULT key of the oldroot dictionary .	oldroot [ RESULT ] = result
16682	substitute value under the NEXT key of the oldroot dictionary for root and first element of nonlocal_root .	root = nonlocal_root [ 0 ] = oldroot [ NEXT ]
16683	substitute value under the KEY key of the root dictionary for oldkey .	oldkey = root [ KEY ]
16684	substitute value under the RESULT key of the root dictionary for oldvalue .	oldvalue = root [ RESULT ]
16685	root dictionary values under the KEY and RESULT keys are both None .	root [ KEY ] = root [ RESULT ] = None
16686	delete entry under the oldkey key of the cache dictionary .	del cache [ oldkey ]
16687	substitute oldroot for value under the key key of the cache dictionary .	cache [ key ] = oldroot
16688	if not ,	else :
16689	substitute value under the PREV key of the root dictionary for last .	last = root [ PREV ]
16690	link is a list with 4 elements : last , root , key and result .	link = [ last , root , key , result ]
16691	substitute link for value under the NEXT key of the last dictionary , for value under the PREV key of the root dictionary , for value under the key key of the cache dictionary .	last [ NEXT ] = root [ PREV ] = cache [ key ] = link
16692	increment stats dictionary value under the MISSES key by integer 1 .	stats [ MISSES ] += 1
16693	return result .	return result
16694	define the function cache_info .	def cache_info ( ) :
16695	with lock ,	with lock :
16696	return an instance of _CacheInfo class , created with 4 arguments : value under the HITS key of the stats dictionary , value under the MISSES key of the stats dictionary , maxsize and length of cache .	return _CacheInfo ( stats [ HITS ] , stats [ MISSES ] , maxsize , len ( cache ) )
16697	define the function cache_clear .	def cache_clear ( ) :
16698	with lock ,	with lock :
16699	call the method cache.clear .	cache . clear ( )
16700	substitute first element of nonlocal_root for root .	root = nonlocal_root [ 0 ]
16701	root is an list with 4 elements : root , root , None and None .	root [ : ] = [ root , root , None , None ]
16702	stats is a list with 2 elements : 2 integers 0 .	stats [ : ] = [ 0 , 0 ]
16703	substitute user_function for wrapper.__wrapped__ .	wrapper . __wrapped__ = user_function
16704	substitute cache_info for wrapper.cache_info .	wrapper . cache_info = cache_info
16705	substitute cache_clear for wrapper.cache_clear .	wrapper . cache_clear = cache_clear
16706	call the function update_wrapper with 2 arguments : wrapper and user_function , return the result .	return update_wrapper ( wrapper , user_function )
16707	return decorating_function .	return decorating_function
16708	from __future__ import absolute_import into default name space .	from __future__ import absolute_import
16709	import module copy .	import copy
16710	from importlib import import_module into default name space .	from importlib import import_module
16711	import module os .	import os
16712	import module sys .	import sys
16713	import module warnings .	import warnings
16714	from django.core.exceptions import ImproperlyConfigured into default name space .	from django . core . exceptions import ImproperlyConfigured
16715	from django.utils import six into default name space .	from django . utils import six
16716	from django.utils.deprecation import RemovedInDjango19Warning into default name space .	from django . utils . deprecation import RemovedInDjango19Warning
16717	define the function import_string with an argument dotted_path .	def import_string ( dotted_path ) :
16718	try ,	try :
16719	split dotted_path into two parts from the right at the STR0 character , assign the result to module_path and class_name , respectively .	module_path , class_name = dotted_path . rsplit ( STR0 , 1 )
16720	if ValueError exception is caught ,	except ValueError :
16721	msg is a string STR0 formated with dotted_path .	msg = STR0 % dotted_path
16722	call the function six.reraise with 3 arguments : ImportError , instance of ImportError class created with an argument msg , and third element of result of the function sys.exc_info .	six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )
16723	call the function import_module with an argument module_path , substitute the result for module .	module = import_module ( module_path )
16724	try ,	try :
16725	get attribute class_name form the module object , return it .	return getattr ( module , class_name )
16726	if AttributeError exception is caught ,	except AttributeError :
16727	msg is a string STR2 formated with dotted_path and class_name , respectively .	msg = STR2 % ( dotted_path , class_name )
16728	call the function six.reraise with 3 arguments : ImportError , instance of ImportError class created with an argument msg , and third element of result of the function sys.exc_info .	six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )
16729	define the function import_by_path with 2 arguments dotted_path and error_prefix set to an empty string..	def import_by_path ( dotted_path , error_prefix = STR ) :
16730	call the function warnings.warn with 3 arguments : string STR0 , RemovedInDjango19Warning and stacklevel as integer 2 .	warnings . warn ( STR0 , RemovedInDjango19Warning , stacklevel = 2 )
16731	try ,	try :
16732	call the function import_string with an argument dotted_path , substitute the result for attr .	attr = import_string ( dotted_path )
16733	if ImportError , renamed to e , exception is caught ,	except ImportError as e :
16734	msg is a string STR1 , where STR2 is replaced with error_prefix , dotted_path and e , respectively .	msg = STR1 % ( error_prefix , dotted_path , e )
16735	call the function six.reraise with 3 arguments : ImproperlyConfigured , instance of ImproperlyConfigured class created with msg , and third element of the function sys.exc_info result .	six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) , sys . exc_info ( ) [ 2 ] )
16736	return attr .	return attr
16737	define the function autodiscover_modules with 2 arguments unpacked list args and unpacked dictionary kwargs .	def autodiscover_modules ( * args , ** kwargs ) :
16738	from django.apps import apps .	from django . apps import apps
16739	get value under the STR0 key of the kwargs dictionary , substitute it for register_to .	register_to = kwargs . get ( STR0 )
16740	call the method apps.get_app_configs , for every app_config in the result ,	for app_config in apps . get_app_configs ( ) :
16741	try ,	try :
16742	if register_to is true ,	if register_to :
16743	call the method copy.copy with an argument register_to._registry , substitute the result for before_import_registry .	before_import_registry = copy . copy ( register_to . _registry )
16744	for every module_to_search in args ,	for module_to_search in args :
16745	call the function import_module with an argument string STR0 , where STR1 is replaced with app_config.name and module_to_search .	import_module ( STR0 % ( app_config . name , module_to_search ) )
16746	is exception is caught ,	except :
16747	if register_to is true ,	if register_to :
16748	substitute before_import_registry for register_to._registry .	register_to . _registry = before_import_registry
16749	if call to the function module_has_submodule with 2 arguments : app_config.module and module_to_search evaluates to true ,	if module_has_submodule ( app_config . module , module_to_search ) :
16750	raise an exception ,	raise
16751	if first and second element of sys.version_info are both equal to integer 3 ,	if sys . version_info [ : 2 ] >= ( 3 , 3 ) :
16752	if first and second element of sys.version_info are equal to integers 3 and 4 , respectively ,	if sys . version_info [ : 2 ] >= ( 3 , 4 ) :
16753	from importlib.util import find_spec as importlib_find .	from importlib . util import find_spec as importlib_find
16754	if not ,	else :
16755	from importlib import find_loader as importlib_find .	from importlib import find_loader as importlib_find
16756	define the function module_has_submodule with 2 arguments : package and module_name .	def module_has_submodule ( package , module_name ) :
16757	try ,	try :
16758	substitute package.__name__ for package_name .	package_name = package . __name__
16759	substitute package.__path__ for package_path .	package_path = package . __path__
16760	if AttributeError exception is caught ,	except AttributeError :
16761	return boolean False .	return False
16762	concatenate package_name , string STR0 and module_name , substitute it for full_module_name .	full_module_name = package_name + STR0 + module_name
16763	call the function importlib_find with 2 arguments : full_module_name and package_path , if the result is not None , return boolean True , otherwise return boolean False .	return importlib_find ( full_module_name , package_path ) is not None
16764	if not ,	else :
16765	import imp .	import imp
16766	define the function module_has_submodule with 2 arguments : package and module_name .	def module_has_submodule ( package , module_name ) :
16767	join package.__name__ and module_name into a string separated with STR0 , substitute it for name .	name = STR0 . join ( [ package . __name__ , module_name ] )
16768	try ,	try :
16769	if value under the name key of the sys.modules dictionary is not None , return boolean True , otherwise return boolean False .	return sys . modules [ name ] is not None
16770	if KeyError exception is caught ,	except KeyError :
16771	do nothing .	pass
16772	try ,	try :
16773	substitute package.__path__ for package_path .	package_path = package . __path__
16774	if AttributeError exception is caught ,	except AttributeError :
16775	return boolean False .	return False
16776	for every finder in sys.meta_path ,	for finder in sys . meta_path :
16777	if call to the method finder.find_module with 2 arguments : name and package_path evaluates to true ,	if finder . find_module ( name , package_path ) :
16778	return boolean True .	return True
16779	for every entry in package_path ,	for entry in package_path :
16780	try ,	try :
16781	substitute the value under the entry key of the sys.path_importer_cache dictionary for finder .	finder = sys . path_importer_cache [ entry ]
16782	if finder is None ,	if finder is None :
16783	try ,	try :
16784	call the method imp.find_module with 2 arguments : module_name and list containing element entry , assign the result to file_ , _ , and _ , respectively .	file_ , _ , _ = imp . find_module ( module_name , [ entry ] )
16785	if file_ is true ,	if file_ :
16786	close file_ file descriptor .	file_ . close ( )
16787	return boolean True .	return True
16788	if ImportError exception is caught ,	except ImportError :
16789	skip this loop iteration ,	continue
16790	otherwise if call to the method finder.find_module with an argument name evaluates to true ,	elif finder . find_module ( name ) :
16791	return boolean True .	return True
16792	if not ,	else :
16793	skip this loop iteration ,	continue
16794	if KeyError exception is caught ,	except KeyError :
16795	for every hook in sys.path_hooks ,	for hook in sys . path_hooks :
16796	try ,	try :
16797	call the function hook with an argument entry , substitute the result for finder .	finder = hook ( entry )
16798	if call to the method finder.find_module with an argument name evaluates to true ,	if finder . find_module ( name ) :
16799	return boolean True .	return True
16800	if not ,	else :
16801	break from the loop execution ,	break
16802	if ImportError exception is caught ,	except ImportError :
16803	skip this loop iteration ,	continue
16804	if not ,	else :
16805	if entry is a directory ,	if os . path . isdir ( entry ) :
16806	try ,	try :
16807	call the method imp.find_module with 2 arguments : module_name and list containing element entry , assign the result to file_ , _ , and _ , respectively	file_ , _ , _ = imp . find_module ( module_name , [ entry ] )
16808	if file_ is true ,	if file_ :
16809	close file_ file descriptor .	file_ . close ( )
16810	return boolean True .	return True
16811	if ImportError exception is caught ,	except ImportError :
16812	do nothing .	pass
16813	if not ,	else :
16814	return boolean False .	return False
16815	from django.conf import settings into default name space .	from django . conf import settings
16816	from django.utils.safestring import mark_safe into default name space .	from django . utils . safestring import mark_safe
16817	from django.utils import six into default name space .	from django . utils import six
16818	define the function format with 6 arguments : number , decimal_sep , decimal_pos set to None , grouping set to integer 0 ,	def format ( number , decimal_sep , decimal_pos = None , grouping = 0 , thousand_sep = STR , force_grouping = False ) :
16819	if settings.USE_L10N is true , substitute settings.USE_THOUSAND_SEPARATOR for use_grouping , otherwise substitute settings.USE_L10N for use_grouping .	use_grouping = settings . USE_L10N and settings . USE_THOUSAND_SEPARATOR
16820	if use_grouping is true substitute it for use_grouping , otherwise substitute force_grouping for use_grouping .	use_grouping = use_grouping or force_grouping
16821	if use_grouping is true and grouping is greater than integer 0 , use_grouping is boolean True , otherwise it is boolean False .	use_grouping = use_grouping and grouping > 0
16822	if number is an integer and use_grouping is false and decimal_pos is false ,	if isinstance ( number , int ) and not use_grouping and not decimal_pos :
16823	call the function six.text_type with an argument number , use the result as an argument for the call to the function mark_safe , return the result .	return mark_safe ( six . text_type ( number ) )
16824	sign is an empty string .	sign = STR
16825	call the function six.text_type with an argument number , substitute the result for str_number .	str_number = six . text_type ( number )
16826	if first element of str_number equals a string STR0 .	if str_number [ 0 ] == STR0 :
16827	sign is a string STR0 .	sign = STR0
16828	remove the first element from str_number .	str_number = str_number [ 1 : ]
16829	if STR0 is not contained in str_number ,	if STR0 in str_number :
16830	split str_number by STR0 , substitute the result for int_part and dec_part , respectively .	int_part , dec_part = str_number . split ( STR0 )
16831	if decimal_pos is not None ,	if decimal_pos is not None :
16832	substitute first decimal_pos elements of dec_part for dec_part .	dec_part = dec_part [ : decimal_pos ]
16833	if not ,	else :
16834	substitute str_number and an empty string for int_part and dec_part .	int_part , dec_part = str_number , STR
16835	if decimal_pos is not None	if decimal_pos is not None :
16836	subtract length of dec_part from decimal_pos , multiply the number of character STR0 by the result , append the resulting string to dec_part , substitute it for dec_part .	dec_part = dec_part + ( STR0 * ( decimal_pos - len ( dec_part ) ) )
16837	if dec_part is true ,	if dec_part :
16838	add decimal_sep and dec_part , substitute the result for dec_part .	dec_part = decimal_sep + dec_part
16839	if use_grouping is true ,	if use_grouping :
16840	int_part_gd is an empty string .	int_part_gd = STR
16841	for every cnt and digit in enumerated list int_part with reversed ordering of elements ,	for cnt , digit in enumerate ( int_part [ : : - 1 ] ) :
16842	if cnt is true and remained of dividing cnt with grouping is zero ,	if cnt and not cnt % grouping :
16843	increment int_part_gd by thousand_sep .	int_part_gd += thousand_sep
16844	append digit to int_part_gd .	int_part_gd += digit
16845	invert the ordering of elements of int_part_gd , substitute it for int_part .	int_part = int_part_gd [ : : - 1 ]
16846	sum sign , int_part and dec_part , return the result .	return sign + int_part + dec_part
16847	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
16848	from django.utils import six into default name space .	from django . utils import six
16849	from django.utils.six.moves import zip into default name space .	from django . utils . six . moves import zip
16850	ESCAPE_MAPPINGS is an dictionary with 10 initial entries : None for STR0 , None for STR , None for STR1 , STR2 for STR3 , STR4 for STR5 , STR for STR6 , STR7 for STR8 , STR9 for STR10 , STR11 for STR12 and None for STR13 .	ESCAPE_MAPPINGS = { STR0 : None , STR : None , STR1 : None , STR2 : STR3 , STR4 : STR5 , STR6 : STR , STR7 : STR8 , STR9 : STR10 , STR11 : STR12 , STR13 : None , }
16851	derive the class Choice from list base class .	class Choice ( list ) :
16852	derive the class Group from list base class .	class Group ( list ) :
16853	derive the class NonCapture from list base class .	class NonCapture ( list ) :
16854	define the function normalize with an argument pattern .	def normalize ( pattern ) :
16855	result is an empty list .	result = [ ]
16856	non_capturing_groups is an empty list .	non_capturing_groups = [ ]
16857	consume_next is boolean True .	consume_next = True
16858	call the function next_char with an argument iterator pattern , substitute the result for pattern_iter .	pattern_iter = next_char ( iter ( pattern ) )
16859	num_args is an integer 0 .	num_args = 0
16860	try ,	try :
16861	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16862	if StopIteration exception ,	except StopIteration :
16863	return a list with an element tuple with 2 elements : an empty string and an empty list .	return [ ( STR , [ ] ) ]
16864	try ,	try :
16865	endless loop ,	while True :
16866	if escaped is true ,	if escaped :
16867	append ch to result .	result . append ( ch )
16868	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16869	append string STR0 to result .	result . append ( STR0 )
16870	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16871	raise an NotImplementedError exception with an argument string STR0 .	raise NotImplementedError ( STR0 )
16872	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16873	do nothing .	pass
16874	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16875	skip this loop iteration .	break
16876	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16877	remove first element from non_capturing_groups , substitute it for start .	start = non_capturing_groups . pop ( )
16878	inner is an instance of NonCapture , created with elements of result from start index to the end .	inner = NonCapture ( result [ start : ] )
16879	append list with element inner to list containing first start elements of result , substitute it for result .	result = result [ : start ] + [ inner ]
16880	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16881	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16882	append ch to result .	result . append ( ch )
16883	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16884	while escaped is true or ch is not equal to a string STR0 ,	while escaped or ch != STR0 :
16885	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16886	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16887	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16888	if ch is not equal to a sring STR0 or escaped is true ,	if ch != STR0 or escaped :
16889	name is a string STR0 formated with num_args .	name = STR0 % num_args
16890	increment num_args by one .	num_args += 1
16891	instantiate a class Group with 2 arguments : string STR0 formated with name , and name , append it to result .	result . append ( Group ( ( ( STR0 % name ) , name ) ) )
16892	call the function walk_to_end with 2 arguments : ch and pattern_iter .	walk_to_end ( ch , pattern_iter )
16893	if not ,	else :
16894	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16895	if ch is contained in string STR0 ,	if ch in STR0 :
16896	call the function walk_to_end with 2 arguments : ch and pattern_iter .	walk_to_end ( ch , pattern_iter )
16897	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16898	append length of result to non_capturing_groups .	non_capturing_groups . append ( len ( result ) )
16899	otherwise if ch equals a string STR0 ,	elif ch != STR0 :
16900	raise an ValueError with an argument string STR0 formated with ch .	raise ValueError ( STR0 % ch )
16901	if not ,	else :
16902	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16903	if ch is not equal to string STR0 or string STR1 ,	if ch not in ( STR0 , STR1 ) :
16904	raise an ValueError with an argument string STR0 formated with ch .	raise ValueError ( STR0 % ch )
16905	if ch equals a string STR0 ,	if ch == STR0 :
16906	terminal_char is an string STR0 .	terminal_char = STR0
16907	if not ,	else :
16908	terminal_char is an string STR0 .	terminal_char = STR0
16909	name is an empty list .	name = [ ]
16910	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16911	while ch is not equal to terminal_char ,	while ch != terminal_char :
16912	append ch to result .	name . append ( ch )
16913	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16914	join elements of name into a string , substitute it for param .	param = STR . join ( name )
16915	if terminal_char is not equal to string STR0 ,	if terminal_char != STR0 :
16916	instantiate a class Group with 2 arguments : string STR0 formated with param , and param , append it to result .	result . append ( Group ( ( ( STR0 % param ) , param ) ) )
16917	call the function walk_to_end with 2 arguments : ch and pattern_iter .	walk_to_end ( ch , pattern_iter )
16918	if not ,	else :
16919	instantiate a class Group with 2 arguments : string STR0 formated with param , and None , append it to result .	result . append ( Group ( ( ( STR0 % param ) , None ) ) )
16920	otherwise if ch is contained in string STR0 ,	elif ch in STR0 :
16921	call the function get_quantifier with 2 arguments : ch and pattern_iter , substitute the result for count and ch , respectively .	count , ch = get_quantifier ( ch , pattern_iter )
16922	if ch is true ,	if ch :
16923	consume_next is boolean False .	consume_next = False
16924	if count is equal to integer 0 .	if count == 0 :
16925	if call to the function contains with 2 arguments : last element of result and Group , evaluates to true ,	if contains ( result [ - 1 ] , Group ) :
16926	last element of result is an instance of Choice class , created with an argument list with 2 elements : None and last element of result .	result [ - 1 ] = Choice ( [ None , result [ - 1 ] ] )
16927	if not ,	else :
16928	remove the first element from result .	result . pop ( )
16929	otherwise if count is greater than integer 1 ,	elif count > 1 :
16930	create a list with count decremented by 1 number of last element of result elements , extend list result with it .	result . extend ( [ result [ - 1 ] ] * ( count - 1 ) )
16931	if not ,	else :
16932	append ch to result .	result . append ( ch )
16933	if consume_next is true ,	if consume_next :
16934	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16935	if not ,	else :
16936	consume_next is boolean True .	consume_next = True
16937	if StopIteration exception ,	except StopIteration :
16938	do nothing .	pass
16939	if NotImplementedError exception ,	except NotImplementedError :
16940	return a list with an element tuple with 2 elements : an empty string and an empty list .	return [ ( STR , [ ] ) ]
16941	call the function flatten_result with an argument result , unpack the resulting list and zip it in the list of tuples , return the result .	return list ( zip ( * flatten_result ( result ) ) )
16942	define the function next_char with an argument input_iter .	def next_char ( input_iter ) :
16943	for every ch in input_iter ,	for ch in input_iter :
16944	if ch is not equal to string '\STR .	if ch != STRspecial :
16945	yield ch and boolean False .	yield ch , False
16946	skip this loop iteration .	continue
16947	get the next element of the iterable pattern_iter , assign the result for ch .	ch = next ( input_iter )
16948	get the value under ch key of the ESCAPE_MAPPINGS dictionary , if it exists substitute it for representative , if not substitute ch for representative .	representative = ESCAPE_MAPPINGS . get ( ch , ch )
16949	if representative is None ,	if representative is None :
16950	skip this loop iteration .	continue
16951	yield representative and boolean True .	yield representative , True
16952	define the function walk_to_end with 2 arguments ch and input_iter .	def walk_to_end ( ch , input_iter ) :
16953	if ch equal a string STR0 ,	if ch == STR0 :
16954	nesting is integer 1 .	nesting = 1
16955	if not ,	else :
16956	nesting is integer 0 .	nesting = 0
16957	for every ch and escaped in input_iter ,	for ch , escaped in input_iter :
16958	if escaped is true ,	if escaped :
16959	skip this loop iteration .	continue
16960	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16961	increment nesting by one .	nesting += 1
16962	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16963	if nesting is false ,	if not nesting :
16964	return nothing .	return
16965	decrement nesting by one .	nesting -= 1
16966	define the function get_quantifier with 2 arguments ch and input_iter .	def get_quantifier ( ch , input_iter ) :
16967	if ch is contained in string STR0 ,	if ch in STR0 :
16968	try ,	try :
16969	get the next element of the iterable pattern_iter , assign the result for ch2 and escaped , respectively .	ch2 , escaped = next ( input_iter )
16970	if StopIteration exception ,	except StopIteration :
16971	ch2 is None .	ch2 = None
16972	if ch2 equals string STR0 ,	if ch2 == STR0 :
16973	ch2 is None .	ch2 = None
16974	if ch equals string STR0 ,	if ch == STR0 :
16975	return integer 1 and ch2 .	return 1 , ch2
16976	return integer 0 and ch2 .	return 0 , ch2
16977	quant is an empty list .	quant = [ ]
16978	while ch is not equal to a string STR0 ,	while ch != STR0 :
16979	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( input_iter )
16980	append ch to quant .	quant . append ( ch )
16981	remove last element for quant .	quant = quant [ : - 1 ]
16982	join elements of quant into a string , split it by string STR0 , substitute the result for values .	values = STR . join ( quant ) . split ( STR0 )
16983	try ,	try :
16984	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( input_iter )
16985	if StopIteration exception ,	except StopIteration :
16986	ch is None .	ch = None
16987	if ch equals a string STR0 ,	if ch == STR0 :
16988	ch is None .	ch = None
16989	convert first element of values into a integer , return the result and ch .	return int ( values [ 0 ] ) , ch
16990	define the function contains with 2 arguments source and inst .	def contains ( source , inst ) :
16991	if source is an instance of inst class ,	if isinstance ( source , inst ) :
16992	return boolean True .	return True
16993	if source is an instance of NonCapture class ,	if isinstance ( source , NonCapture ) :
16994	for every elt in source ,	for elt in source :
16995	call the function contains with 2 arguments : elt and inst , if it evaluates to true ,	if contains ( elt , inst ) :
16996	return boolean True .	return True
16997	return boolean False .	return False
16998	define the function flatten_result with an argument source .	def flatten_result ( source ) :
16999	if source is None ,	if source is None :
17000	return a list containing an empty string and a list containing an empty list .	return [ STR ] , [ [ ] ]