6001	from wsgiref import simple_server into default name space .	from wsgiref import simple_server
6002	from wsgiref.util import FileWrapper	from wsgiref . util import FileWrapper
6003	from django.core.exceptions import ImproperlyConfigured into default name space .	from django . core . exceptions import ImproperlyConfigured
6004	from django.core.management.color import color_style into default name space .	from django . core . management . color import color_style
6005	from django.core.wsgi import get_wsgi_application into default name space .	from django . core . wsgi import get_wsgi_application
6006	from django.utils import six into default name space .	from django . utils import six
6007	from django.utils.module_loading import import_string into default name space .	from django . utils . module_loading import import_string
6008	from django.utils.six.moves import socketserver into default name space .	from django . utils . six . moves import socketserver
6009	__all__ is a tuple containing 2 initial elements : strigs STR0 and STR1 .	__all__ = ( STR0 , STR1 )
6010	define the funtion get_internal_wsgi_application .	def get_internal_wsgi_application ( ) :
6011	from django.conf import settings into default name space .	from django . conf import settings
6012	get STR0 attribute from the settings , substitute it for app_path .	app_path = getattr ( settings , STR0 )
6013	if app_path is None ,	if app_path is None :
6014	call the function get_wsgi_application , return the result .	return get_wsgi_application ( )
6015	try ,	try :
6016	call the import_string with app_path as an argument , return the result .	return import_string ( app_path )
6017	if ImportError , rename it to e , exception is caught ,	except ImportError as e :
6018	msg is a tuple containing one initial entry : a string STR0 , where STR1 is replaced by app_path and STR2 is replaced by e .	msg = ( STR0 % ( { STR1 : app_path , STR2 : e , } ) )
6019	call the function six.reraise with 3 arguments : ImproperlyConfigured , ImproperlyConfigured ( msg ) and third element of return value of the function sys.exc_info .	six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) , sys . exc_info ( ) [ 2 ] )
6020	derive the class WSGIServer from simple_server.WSGIServer and object base classes .	class WSGIServer ( simple_server . WSGIServer , object ) :
6021	request_queue_size is integer 10 .	request_queue_size = 10
6022	define the __init__ method with 3 arguments : self , unpacked list args and unpacked dictionary **kwargs .	def __init__ ( self , * args , ** kwargs ) :
6023	pop value under the STR0 key of the kwargs dictionary , if it is true ,	if kwargs . pop ( STR0 , False ) :
6024	substitute socket.AF_INET6 for self.address_family .	self . address_family = socket . AF_INET6
6025	call the __init__ method from the base class of the WSGIServer class , with 2 arguments : unpacked list args and unpacked dictionary kwargs .	super ( WSGIServer , self ) . __init__ ( * args , ** kwargs )
6026	define the function server_bind with an argument self .	def server_bind ( self ) :
6027	call the server_bind method from the base class of the WSGIServer class .	super ( WSGIServer , self ) . server_bind ( )
6028	call the self.setup_environ method .	self . setup_environ ( )
6029	derive the class WSGIRequestHandler from simple_server.WSGIRequestHandler and object base classes .	class WSGIRequestHandler ( simple_server . WSGIRequestHandler , object ) :
6030	define the __init__ method with 3 arguments : self , unpacked list args and unpacked dictionary **kwargs .	def __init__ ( self , * args , ** kwargs ) :
6031	call the color_style method , substitute the result for self.style .	self . style = color_style ( )
6032	call the __init__ method from the base class of the WSGIRequestHandler class , with 2 arguments : unpacked list args and unpacked dictionary kwargs .	super ( WSGIRequestHandler , self ) . __init__ ( * args , ** kwargs )
6033	define the function address_string with an argument self .	def address_string ( self ) :
6034	return the first element of self.client_address .	return self . client_address [ 0 ]
6035	define the function server_bind with an argument self .	def log_message ( self , format , * args ) :
6036	msg is a string STR0 , where STR1 are replaced with return value of the method self.log_date_time_string and formated args .	msg = STR0 % ( self . log_date_time_string ( ) , format % args )
6037	if first element of the second row of args equals a string STR0 ,	if args [ 1 ] [ 0 ] == STR0 :
6038	call the self.style.HTTP_SUCCESS with an argument msg , substitute it for msg .	msg = self . style . HTTP_SUCCESS ( msg )
6039	otherwise if first element of second row of args equals a string STR0 ,	elif args [ 1 ] [ 0 ] == STR0 :
6040	call the self.style.HTTP_INFO with an argument msg , substitute it for msg .	msg = self . style . HTTP_INFO ( msg )
6041	otherwise if second element of args equals a string STR0 ,	elif args [ 1 ] == STR0 :
6042	call the self.style.HTTP_NOT_MODIFIED with an argument msg , substitute it for msg .	msg = self . style . HTTP_NOT_MODIFIED ( msg )
6043	otherwise if first element of second row of args equals a string STR0 ,	elif args [ 1 ] [ 0 ] == STR0 :
6044	call the self.style.HTTP_REDIRECT with an argument msg , substitute it for msg .	msg = self . style . HTTP_REDIRECT ( msg )
6045	otherwise if second element of args equals a string STR0 ,	elif args [ 1 ] == STR0 :
6046	call the self.style.HTTP_NOT_FOUND with an argument msg , substitute it for msg .	msg = self . style . HTTP_NOT_FOUND ( msg )
6047	otherwise if first element of second row of args equals a string STR0 ,	elif args [ 1 ] [ 0 ] == STR0 :
6048	call the self.style.HTTP_BAD_REQUEST with an argument msg , substitute it for msg .	msg = self . style . HTTP_BAD_REQUEST ( msg )
6049	if not ,	else :
6050	call the self.style.HTTP_SERVER_ERROR with an argument msg , substitute it for msg .	msg = self . style . HTTP_SERVER_ERROR ( msg )
6051	call the sys.stderr.write function with an argument msg .	sys . stderr . write ( msg )
6052	define the function run with 5 arguments : addr , port , wsgi_handler , ipv6 set to boolean False and threading set to boolean False .	def run ( addr , port , wsgi_handler , ipv6 = False , threading = False ) :
6053	server_address is a tuple containing 2 initial elements : addr and port .	server_address = ( addr , port )
6054	if threading is true ,	if threading :
6055	call the function type with 3 arguments : string STR0 , tuple containing 2 elements : socketserver.ThreadingMixIn and WSGIServer , and an empty dictionary , substitute the result for httpd_cls .	httpd_cls = type ( str ( STR0 ) , ( socketserver . ThreadingMixIn , WSGIServer ) , { } )
6056	if not ,	else :
6057	substitute WSGIServer for httpd_cls .	httpd_cls = WSGIServer
6058	call the httpd_cls function with 4 arguments : server_address , WSGIRequestHandler and ipv6 set to ipv6 , substitute the result for httpd .	httpd = httpd_cls ( server_address , WSGIRequestHandler , ipv6 = ipv6 )
6059	if threading is true ,	if threading :
6060	httpd.daemon_threads is boolean True .	httpd . daemon_threads = True
6061	call the method httpd.set_app with an argument wsgi_handler .	httpd . set_app ( wsgi_handler )
6062	call the method httpd.serve_forever .	httpd . serve_forever ( )
6063	import module importlib .	import importlib
6064	import module os .	import os
6065	import module sys .	import sys
6066	__version__ is a string STR0 .	__version__ = STR0
6067	__all__ is a list containing a string STR0 .	__all__ = [ STR0 ]
6068	FASTCGI_OPTIONS is a dictionary containing 16 initial entries : STR0 for STR1 , None for STR2 , None for STR3 ,	FASTCGI_OPTIONS = { STR0 : STR1 , STR2 : None , STR3 : None , STR4 : None , STR5 : STR6 , STR7 : None , STR8 : STR9 , STR10 : None , STR11 : 5 , STR12 : 2 , STR13 : 50 , STR14 : 0 , STR15 : None , STR16 : None , STR17 : None , STR18 : None , }
6069	define the method fastcgi_help with an argument message set to None .	def fastcgi_help ( message = None ) :
6070	print FASTCGI_HELP to the standard output .	print ( FASTCGI_HELP )
6071	if message is true ,	if message :
6072	print message to the standard output .	print ( message )
6073	return boolean False .	return False
6074	define the function runfastcgi with 2 arguments : argset set to an empty list and unpacked dictionary kwargs .	def runfastcgi ( argset = [ ] , ** kwargs ) :
6075	call the method FASTCGI_OPTIONS.copy , substitute the result for options .	options = FASTCGI_OPTIONS . copy ( )
6076	call the options.update method with an argument kwargs .	options . update ( kwargs )
6077	for every x in argset ,	for x in argset :
6078	if character STR0 is contained in x ,	if STR0 in x :
6079	call the x.split method with arguments : character STR0 and integer 1 , store the result in k and v , respectively .	k , v = x . split ( STR0 , 1 )
6080	if not ,	else :
6081	substitute x for k and boolean True for v .	k , v = x , True
6082	substitute v for value under the k converted to lower case key of options dictionary .	options [ k . lower ( ) ] = v
6083	if string STR0 is contained in options ,	if STR0 in options :
6084	call the fastcgi_help function , return the result .	return fastcgi_help ( )
6085	try ,	try :
6086	import flup	import flup
6087	if ImportError , renamed to e , exception is caught ,	except ImportError as e :
6088	call the method sys.stderr.write with an argument string STR0 , where STR1 is replaced by e .	sys . stderr . write ( STR0 % e )
6089	call the method sys.stderr.write with an argument string STR0 .	sys . stderr . write ( STR0 )
6090	call the method sys.stderr.write with an argument string STR0 .	sys . stderr . write ( STR0 )
6091	call the method sys.stderr.write with an argument string STR0 .	sys . stderr . write ( STR0 )
6092	call the method sys.stderr.write with an argument string STR0 .	sys . stderr . write ( STR0 )
6093	return boolean False .	return False
6094	append value under the STR0 key of the options dictionary to the string STR1 , substitute it for flup_module .	flup_module = STR0 + options [ STR1 ]
6095	if value under the STR0 key of the options dictionary equals to string STR1 or STR2 ,	if options [ STR0 ] in ( STR1 , STR2 ) :
6096	wsgi_opts is a dictionary with 4 initial entries : value under the key STR0 of options dictionary converted to an integer , for STR1 , value under the key STR2 of options dictionary converted to an integer for STR3 , value under the key STR4 of options dictionary converted to an integer , for STR5 , and value under the key STR6 of options dictionary converted to an integer , for STR7 .	wsgi_opts = { STR4 : int ( options [ STR0 ] ) , STR5 : int ( options [ STR1 ] ) , STR6 : int ( options [ STR2 ] ) , STR7 : int ( options [ STR3 ] ) , }
6097	append string STR0 to flup_module .	flup_module += STR0
6098	otherwise if value under the STR0 key of optins dictionary equals to string STR1 or STR2 ,	elif options [ STR0 ] in ( STR1 , STR2 ) :
6099	wsgi_opts is a dictionary with 4 initial entries : value under the key STR0 of options dictionary converted to an integer , for STR1 , value under the key STR2 of options dictionary converted to an integer for STR3 , and value under the key STR4 of options dictionary converted to an integer , for STR5 .	wsgi_opts = { STR3 : int ( options [ STR0 ] ) , STR4 : int ( options [ STR1 ] ) , STR5 : int ( options [ STR2 ] ) , }
6100	if not ,	else :
6101	call the function fastcgi_help with an argument string STR0 , return the result .	return fastcgi_help ( STR0 )
6102	if value under the STR0 key of options dictionary is not None , substitute it for value under the STR1 key of wsgi_opts dictionary .	wsgi_opts [ STR0 ] = options [ STR1 ] is not None
6103	try ,	try :
6104	call the function importlib.import_module with 2 arguments : flup_module converted to string and appended to STR0 character , and string STR1 , substitute the result for module .	module = importlib . import_module ( STR0 % flup_module , STR1 )
6105	substitute module.WSGIServer for WSGIServer .	WSGIServer = module . WSGIServer
6106	if Exception exception is caught ,	except Exception :
6107	append flup_module to string STR0 , print it to the standard output .	print ( STR0 + flup_module )
6108	return boolean False .	return False
6109	from django.core.servers.basehttp import get_internal_wsgi_application into default name space .	from django . core . servers . basehttp import get_internal_wsgi_application
6110	if value under the STR0 key of the options dictionary is false and values under the STR1 and STR2 keys of the options dictionary are true ,	if options [ STR0 ] and options [ STR1 ] and not options [ STR2 ] :
6111	set the value under the STR0 key of the wsgi_opts dictionary to a tuple containing 2 elements : value under the STR1 key , of the options dictionary and value under the STR2 key of the options dictionary converted into an integer .	wsgi_opts [ STR2 ] = ( options [ STR0 ] , int ( options [ STR1 ] ) )
6112	if value under the STR0 key of the options dictionary is true and values under the STR1 and STR2 keys of the options dictionary are false ,	elif options [ STR0 ] and not options [ STR1 ] and not options [ STR2 ] :
6113	substitute the value under the STR0 key of options dictionary for value under the STR1 key of wsgi_opts dictionary .	wsgi_opts [ STR1 ] = options [ STR0 ]
6114	if values under the STR0 , STR1 and STR2 keys of the options dictionary are false ,	elif not options [ STR0 ] and not options [ STR1 ] and not options [ STR2 ] :
6115	set value under the STR0 key of wsgi_opts to None .	wsgi_opts [ STR0 ] = None
6116	if not ,	else :
6117	call the fastcgi_help function with an argument string STR0 , return it .	return fastcgi_help ( STR0 )
6118	if value under the STR0 of options dictionary is None ,	if options [ STR0 ] is None :
6119	if the value under the STR0 key of the wsgi_opts dictionary is not None , set daemonize to boolean True , if not , set it to boolean False .	daemonize = ( wsgi_opts [ STR0 ] is not None )
6120	if not ,	else :
6121	convert the value under the STR0 key of options dictionary to lowercase , if it equals to string STR1 , STR2 or STR3 ,	if options [ STR0 ] . lower ( ) in ( STR1 , STR2 , STR3 ) :
6122	daemonize is boolean True .	daemonize = True
6123	convert the value under the STR0 key of options dictionary to lowercase , if it equals to string STR1 , STR2 or STR3 ,	elif options [ STR0 ] . lower ( ) in ( STR1 , STR2 , STR3 ) :
6124	daemonize is boolean False .	daemonize = False
6125	if not ,	else :
6126	call the fastcgi_help function with an argument string STR0 , return it .	return fastcgi_help ( STR0 )
6127	daemon_kwargs is an empty dictionary .	daemon_kwargs = { }
6128	if value under the STR0 key of options dictionary is true ,	if options [ STR0 ] :
6129	substitute the value under the STR0 key of options dictionary for value under the STR1 key of daemon_kwargs dictionary .	daemon_kwargs [ STR0 ] = options [ STR1 ]
6130	if value under the STR0 key of options dictionary is true ,	if options [ STR0 ] :
6131	substitute the value under the STR0 key of options dictionary for value under the STR1 key of daemon_kwargs dictionary .	daemon_kwargs [ STR0 ] = options [ STR1 ]
6132	if value under the STR0 key of options dictionary is true ,	if options [ STR0 ] :
6133	convert the value under the STR0 key of options dictionary into an integer of base 8 , substitute it for value under the STR1 key of daemon_kwargs dictionary .	daemon_kwargs [ STR0 ] = int ( options [ STR1 ] , 8 )
6134	if daemonize is true ,	if daemonize :
6135	from django.utils.daemonize import become_daemon into default name space .	from django . utils . daemonize import become_daemon
6136	call the function become_daemon with 2 arguments : our_home_dir set to the value under the STR0 key of options dictionary and , unpacked dictionary daemon_kwargs .	become_daemon ( our_home_dir = options [ STR0 ] , ** daemon_kwargs )
6137	if value under the STR0 of options dictionary exists ,	if options [ STR0 ] :
6138	open the file whose name is stored in the value under the STR0 key of options dictionary and mode STR1 , with the file descriptor as fp ,	with open ( options [ STR0 ] , STR1 ) as fp :
6139	call the method fp.write with an argument string STR0 % d ' replaced by os.getpid function return value .	fp . write ( STR0 % os . getpid ( ) )
6140	create the object WSGIServer with 2 arguments : get_internal_wsgi_application return value and unpacked dictionary wsgi_opts , call the method run on it .	WSGIServer ( get_internal_wsgi_application ( ) , ** wsgi_opts ) . run ( )
6141	if __name__ equals a string STR0 .	if __name__ == STR0 :
6142	call the function runfastcgi with an argument all the elements , except the first from the sys.argv list .	runfastcgi ( sys . argv [ 1 : ] )
6143	from django.dispatch import Signal into default name space .	from django . dispatch import Signal
6144	request_started is a instance of a Signal class .	request_started = Signal ( )
6145	request_finished is a instance of a Signal class .	request_finished = Signal ( )
6146	got_request_exception is a instance of a Signal class , created with an argument providing_args as the list containing string STR0 .	got_request_exception = Signal ( providing_args = [ STR0 ] )
6147	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
6148	import module base64 .	import base64
6149	import module json .	import json
6150	import module time .	import time
6151	import module zlib .	import zlib
6152	from django.conf import settings into default name space .	from django . conf import settings
6153	from django.utils import baseconv into default name space .	from django . utils import baseconv
6154	from django.utils.crypto import constant_time_compare and salted_hmac into default name space .	from django . utils . crypto import constant_time_compare , salted_hmac
6155	from django.utils.encoding import force_bytes , force_str and force_text into default name space .	from django . utils . encoding import force_bytes , force_str , force_text
6156	from django.utils.module_loading import import_string into default name space .	from django . utils . module_loading import import_string
6157	derive the class BadSignature from the Exception base class .	class BadSignature ( Exception ) :
6158	do nothing .	pass
6159	derive the class SignatureExpired from the BadSignature base class .	class SignatureExpired ( BadSignature ) :
6160	do nothing .	pass
6161	define the function b64_encode with an argument s .	def b64_encode ( s ) :
6162	call the method base64.urlsafe_b64encode with an argument s , on the result call the strip function with STR0 as the argument , return the result .	return base64 . urlsafe_b64encode ( s ) . strip ( STR0 )
6163	define the function b64_decode with an argument s .	def b64_decode ( s ) :
6164	calculate negative length of s , by modulus integer 4 , use the result as the number of STR0 characters to be stored in pad .	pad = STR0 * ( - len ( s ) % 4 )
6165	call the method base64.urlsafe_b64decode with sum of s and pad as argument .	return base64 . urlsafe_b64decode ( s + pad )
6166	define the function b64_hmac with arguments salt , value and key .	def base64_hmac ( salt , value , key ) :
6167	call the salted_hmac with 3 arguments : salt , value and key , call the digest method on the result , use the result as an argument for the call to the b64_encode function , return the result .	return b64_encode ( salted_hmac ( salt , value , key ) . digest ( ) )
6168	define the function get_cookie_signer with an argument salt set to string STR0 .	def get_cookie_signer ( salt = STR0 ) :
6169	call the import_string function with an argument settings.SIGNING_BACKEND , substitute the result for Signer .	Signer = import_string ( settings . SIGNING_BACKEND )
6170	call the force_bytes function with an argument settings.SECRET_KEY , substitute the result for key .	key = force_bytes ( settings . SECRET_KEY )
6171	create the Singer class with 2 arguments : key appended to string STR0 and salt set to salt , return it .	return Signer ( STR0 + key , salt = salt )
6172	derive the class JSONSerializer from the object base class .	class JSONSerializer ( object ) :
6173	define the method dumps with arguments self and obj .	def dumps ( self , obj ) :
6174	call the json.dumps function with 2 arguments : obj and separators set to tuple containing STR0 and STR1 characters , call the encode method on the result with string STR2 as an argument , return the result .	return json . dumps ( obj , separators = ( STR0 , STR1 ) ) . encode ( STR2 )
6175	define the method loads with arguments self and data .	def loads ( self , data ) :
6176	call the data.decode method with a string STR0 as an argument , use the result as an argument for the call to the json.load function , return the result .	return json . loads ( data . decode ( STR0 ) )
6177	define the function dumps with 5 arguments : obj , key set to None , salt set to string STR0 ,	def dumps ( obj , key = None , salt = STR0 , serializer = JSONSerializer , compress = False ) :
6178	call the serializer function , call the dumps method on the result with an argument obj , substitute result for data .	data = serializer ( ) . dumps ( obj )
6179	is_compressed is boolean False .	is_compressed = False
6180	if compress is true ,	if compress :
6181	call the function zlib.compress with an argument data , substitute the result for compressed .	compressed = zlib . compress ( data )
6182	if length of compressed is lesser than length of data decremented by 1 ,	if len ( compressed ) < ( len ( data ) - 1 ) :
6183	substitute compressed for data .	data = compressed
6184	is_compressed is boolean True .	is_compressed = True
6185	call the b64_encode function with an argument data , substitute the result for base64d .	base64d = b64_encode ( data )
6186	if is_compressed is true ,	if is_compressed :
6187	prefix the base64d with a STR0 character .	base64d = STR0 + base64d
6188	instantiate the TimestampSigner object with arguments key and salt set to salt , call its method sign with an argument base64 , return it .	return TimestampSigner ( key , salt = salt ) . sign ( base64d )
6189	define the function loads with 5 arguments : s , key set to None , salt set to string STR0 ,	def loads ( s , key = None , salt = STR0 , serializer = JSONSerializer , max_age = None ) :
6190	instantiate TimestampSigner object with arguments key and salt set to salt , call its method unsign with arguments : s and max_age set to max_age , use it as an argument for the force_bytes function , substitute the result for base64d .	base64d = force_bytes ( TimestampSigner ( key , salt = salt ) . unsign ( s , max_age = max_age ) )
6191	decompress is boolean False .	decompress = False
6192	if first element of base64d equals to a STR0 character ,	if base64d [ : 1 ] == STR0 :
6193	substitute first element of base64d for base64d .	base64d = base64d [ 1 : ]
6194	decompress is boolean True .	decompress = True
6195	call the method b64_decode with an argument base64 , substitute the result for data .	data = b64_decode ( base64d )
6196	if decompress is true ,	if decompress :
6197	call the function zlib.decompress with an argument data , substitute the result for data .	data = zlib . decompress ( data )
6198	call the serializer function , call the loads method on the return value with an argument data , return the result .	return serializer ( ) . loads ( data )
6199	derive the class Signer from the object base class .	class Signer ( object ) :
6200	define the method __init__ with 4 arguments : self , key set to None , sep set to STR0 and salt set to None .	def __init__ ( self , key = None , sep = STR0 , salt = None ) :
6201	call the function force_str with an argument sep , substitute the result for self.sep .	self . sep = force_str ( sep )
6202	if key exists , substitute it for self.key , if not substitute settings.SECRET_KEY for key .	self . key = key or settings . SECRET_KEY
6203	call the force_str function with an argument : salt , if it exists , if not with a string STR0 , with STR1 replaced by , self.__class__.__module__ and self.__class__.__name__ , respectively , substitute the result for self.salt .	self . salt = force_str ( salt or STR0 % ( self . __class__ . __module__ , self . __class__ . __name__ ) )
6204	define the method signature with arguments self and value .	def signature ( self , value ) :
6205	call the function base64_hmac with 3 arguments : string STR0 appended to self.salt , value and self.key , substitute the result for signature .	signature = base64_hmac ( self . salt + STR0 , value , self . key )
6206	call the function force_str with an argument signature , return the result .	return force_str ( signature )
6207	define the method sign with arguments self and value .	def sign ( self , value ) :
6208	call the function force_str with an argument value , substitute the result for value .	value = force_str ( value )
6209	convert value , self.sep and return value of a method self.signature called with an argument value , concatenate them together , return the result .	return str ( STR0 ) % ( value , self . sep , self . signature ( value ) )
6210	define the method unsign with arguments self and signed_value .	def unsign ( self , signed_value ) :
6211	call the function signed_value with an argument value , substitute the result for signed_value .	signed_value = force_str ( signed_value )
6212	if self.sep is not contained in signed_value ,	if self . sep not in signed_value :
6213	raise an BadSignature exception with an argument string STR1 , where STR2 is replaced by self.sep .	raise BadSignature ( STR1 % self . sep )
6214	call the signed_value.rsplit method with arguments self.sep and integer 1 , substitute the result for value and sig , respectively .	value , sig = signed_value . rsplit ( self . sep , 1 )
6215	call the function constant_time_compare with 2 arguments : sig and return value of the self.signature method with an argument value , if it evaluates to true ,	if constant_time_compare ( sig , self . signature ( value ) ) :
6216	call the force_text function with an argument value , return the result .	return force_text ( value )
6217	raise an BadSignature exception with an argument string STR1 , where STR2 is replaced by sig .	raise BadSignature ( STR1 % sig )
6218	derive the class TimestampSigner from the Signer base class .	class TimestampSigner ( Signer ) :
6219	define the method timestamp with an argument self .	def timestamp ( self ) :
6220	call the method baseconv.base62.encode with result of the time.time function converted to an integer , as an argument , return the result .	return baseconv . base62 . encode ( int ( time . time ( ) ) )
6221	define the method sign with arguments self and value .	def sign ( self , value ) :
6222	call the force_str function with an argument value , substitute the result for value .	value = force_str ( value )
6223	convert value , self.sep and return value of the function timestamp , concatenate them , substitute the result for value .	value = str ( STR0 ) % ( value , self . sep , self . timestamp ( ) )
6224	call the sign method from the base class of the TimestampSigner class with an argument value , return the result	return super ( TimestampSigner , self ) . sign ( value )
6225	define the method unsign with arguments self , value and max_age set to None .	def unsign ( self , value , max_age = None ) :
6226	call the unsign method from the base class of the TimestampSigner class with an argument value , substitute the result for result .	result = super ( TimestampSigner , self ) . unsign ( value )
6227	call the result.rsplit method with arguments self.sep and integer 1 , substitute the result for value and timestamp , respectively .	value , timestamp = result . rsplit ( self . sep , 1 )
6228	call the baseconv.base62.decode method with an argument timestamp , substitute the result for timestamp .	timestamp = baseconv . base62 . decode ( timestamp )
6229	if max_age is not None ,	if max_age is not None :
6230	subtract timestamp from the return value of the function time.time , substitute the result for age .	age = time . time ( ) - timestamp
6231	if age is greater than max_age ,	if age > max_age :
6232	raise an SignatureExpired exception with an argument string STR0 , where STR1 is replaced by age and max_age , respectively .	raise SignatureExpired ( STR0 % ( age , max_age ) )
6233	return value .	return value
6234	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
6235	import module functools .	import functools
6236	from importlib import import_module into default name space .	from importlib import import_module
6237	import module re .	import re
6238	from threading import local into default name space .	from threading import local
6239	import module warnings .	import warnings
6240	from django.http import Http404 into default name space .	from django . http import Http404
6241	from django.core.exceptions import ImproperlyConfigured and ViewDoesNotExist into default name space .	from django . core . exceptions import ImproperlyConfigured , ViewDoesNotExist
6242	from django.utils.datastructures import MultiValueDict into default name space .	from django . utils . datastructures import MultiValueDict
6243	from django.utils.deprecation import RemovedInDjango20Warning into default name space .	from django . utils . deprecation import RemovedInDjango20Warning
6244	from django.utils.encoding import force_str , force_text and iri_to_uri into default name space .	from django . utils . encoding import force_str , force_text , iri_to_uri
6245	from django.utils.functional import lazy into default name space .	from django . utils . functional import lazy
6246	from django.utils.http import urlquote into default name space .	from django . utils . http import urlquote
6247	from django.utils.module_loading import module_has_submodule into default name space .	from django . utils . module_loading import module_has_submodule
6248	from django.utils.regex_helper import normalize into default name space .	from django . utils . regex_helper import normalize
6249	from django.utils import six and lru_cache into default name space .	from django . utils import six , lru_cache
6250	from django.utils.translation import get_language into default name space .	from django . utils . translation import get_language
6251	call the function local , substitute the result for _prefixes .	_prefixes = local ( )
6252	call the function local , substitute the result _urlconf .	_urlconfs = local ( )
6253	derive the class ResolverMatch with object as base class .	class ResolverMatch ( object ) :
6254	define the __init__ method with 7 arguments : self , func , args , kwargs , url_name set to None , app_name set to None and namespaces set to None .	def __init__ ( self , func , args , kwargs , url_name = None , app_name = None , namespaces = None ) :
6255	substitute func for self.func .	self . func = func
6256	substitute args for self.args .	self . args = args
6257	substitute kwargs for self.kwargs .	self . kwargs = kwargs
6258	substitute url_name for self.url_name .	self . url_name = url_name
6259	substitute app_name for self.app_name .	self . app_name = app_name
6260	if namespaces is true ,	if namespaces :
6261	append x to self.namespaces list for every x in namespaces , only if x is true .	self . namespaces = [ x for x in namespaces if x ]
6262	if not ,	else :
6263	self.namespaces is an empty list .	self . namespaces = [ ]
6264	join self.namespaces into a string separated with character STR0 , substitute it for self.namespace .	self . namespace = STR0 . join ( self . namespaces )
6265	if func doesnt have a attribute STR0 ,	if not hasattr ( func , STR0 ) :
6266	join func.__class__.__module__ and func.__class__.__name__ into a string , separated by character STR0 , substitute it for self._func_path .	self . _func_path = STR0 . join ( [ func . __class__ . __module__ , func . __class__ . __name__ ] )
6267	if not ,	else :
6268	join func.__module__ and func.__name__ into a string , separated by character STR0 , substitute it for self._func_path .	self . _func_path = STR0 . join ( [ func . __module__ , func . __name__ ] )
6269	if url_name exists substitute it for view_path , if not substitute .self._func_path for view_path .	view_path = url_name or self . _func_path
6270	append list containing view_path to self.namespaces list , join all the elements into a string separated by character STR0 , substitute it for self.view_name .	self . view_name = STR0 . join ( self . namespaces + [ view_path ] )
6271	define the method __getitem__ with arguments self and index .	def __getitem__ ( self , index ) :
6272	return the element at the index index of the tuple containing 3 elements : self.func , self.args and self.kwargs .	return ( self . func , self . args , self . kwargs ) [ index ]
6273	define the method __repr__ with an argument self .	def __repr__ ( self ) :
6274	in the string STR0 , replace all the occurrences of : string STR1 with self._func_path , self.args , self.kwargs , self.url_name , self.app_name and self.namespaces , respectively .	return STR0 % ( self . _func_path , self . args , self . kwargs , self . url_name , self . app_name , self . namespaces )
6275	derive the class Resolver404 with Http404 as base class .	class Resolver404 ( Http404 ) :
6276	do nothing .	pass
6277	derive the class NoReverseMatch with Exception as base class .	class NoReverseMatch ( Exception ) :
6278	do nothing .	pass
6279	method lru_cache.lru_cache with an argument maxsize set to None , as a decorator ,	@ lru_cache . lru_cache ( maxsize = None )
6280	define the function get_callable with arguments lookup_view and can_fail set to boolean False .	def get_callable ( lookup_view , can_fail = False ) :
6281	if lookup_view is a callable object ,	if callable ( lookup_view ) :
6282	return lookup_view .	return lookup_view
6283	call the function get_mod_func with an argument lookup_view , store the result in mod_name and func_name , respectively .	mod_name , func_name = get_mod_func ( lookup_view )
6284	if func_name is false ,	if not func_name :
6285	if can_fail is true ,	if can_fail :
6286	return lookup_view .	return lookup_view
6287	if not ,	else :
6288	raise an ImportError exception with an argument string STR0 , where STR1 is replaced by lookup_view .	raise ImportError ( STR0 % lookup_view )
6289	try ,	try :
6290	call the function import_module with an argument mod_name .	mod = import_module ( mod_name )
6291	if ImportError exception is caught .	except ImportError :
6292	if can_fail is true ,	if can_fail :
6293	return lookup_view	return lookup_view
6294	if not ,	else :
6295	call the function get_mod_func with an argument mod_name , store the result in parentmod and submod , respectively .	parentmod , submod = get_mod_func ( mod_name )
6296	if submod is true and return value of the function module_has_submodule called with 2 arguments : result of the function : import_module called with an argument parentmod and submod , evaluates to false .	if submod and not module_has_submodule ( import_module ( parentmod ) , submod ) :
6297	raise an ViewDoesNotExist exception with an argument string STR0 , where string STR1 is replaced by lookup_view and mod_name , respectively .	raise ViewDoesNotExist ( STR0 % ( lookup_view , mod_name ) )
6298	if not ,	else :
6299	raise an exception .	raise
6300	if not ,	else :
6301	try ,	try :
6302	get func_name attribute from the mod object , substitute it for view_func .	view_func = getattr ( mod , func_name )
6303	if AttributeError exception is caught .	except AttributeError :
6304	if can fail is true ,	if can_fail :
6305	return lookup_view	return lookup_view
6306	if not ,	else :
6307	raise an ViewDoesNotExist exception with an argument string STR0 , where string STR1 is replaced by lookup_view and mod_name , respectively .	raise ViewDoesNotExist ( STR0 % ( lookup_view , mod_name ) )
6308	if not ,	else :
6309	if view_function is not a callable function ,	if not callable ( view_func ) :
6310	raise an ViewDoesNotExist exception with an argument string STR0 , where string STR1 is replaced by mod_name and func_name , respectively .	raise ViewDoesNotExist ( STR0 % ( mod_name , func_name ) )
6311	return view_func .	return view_func
6312	method lru_cache.lru_cache with an argument maxsize set to None , as a decorator ,	@ lru_cache . lru_cache ( maxsize = None )
6313	define the function get_resolver with an argument urlconf .	def get_resolver ( urlconf ) :
6314	if urlconf is None ,	if urlconf is None :
6315	from django.conf import settings into default name space .	from django . conf import settings
6316	substitute settings.ROOT_URLCONF for urlconf .	urlconf = settings . ROOT_URLCONF
6317	return an instance of a class RegexURLResolver created with arguments : raw string STR0 and urlconf .	return RegexURLResolver ( STR0 , urlconf )
6318	method lru_cache.lru_cache with an argument maxsize set to None , as a decorator ,	@ lru_cache . lru_cache ( maxsize = None )
6319	define the function get_ns_resolver with arguments ns_pattern and resolver .	def get_ns_resolver ( ns_pattern , resolver ) :
6320	ns_resolver is class instance of a class RegexURLResolver , created with 2 arguments : ns_pattern and resolver.url_patterns .	ns_resolver = RegexURLResolver ( ns_pattern , resolver . url_patterns )
6321	return an instance of a class RegexURLResolver created with arguments : raw string STR0 and a list containing an element ns_resolver .	return RegexURLResolver ( STR0 , [ ns_resolver ] )
6322	define the function get_mod_func with an argument callback .	def get_mod_func ( callback ) :
6323	try ,	try :
6324	call the method callback.rindex with an argument character STR0 , substitute the result for dot .	dot = callback . rindex ( STR0 )
6325	if ValueError exception is caught ,	except ValueError :
6326	return callback and a empty string .	return callback , STR
6327	return callback split into two lists at the dot index , without the element at the dot index .	return callback [ : dot ] , callback [ dot + 1 : ]
6328	derive the class LocaleRegexProvider with object as base class .	class LocaleRegexProvider ( object ) :
6329	define the method __init__ with arguments self and regex .	def __init__ ( self , regex ) :
6330	substitute regex for self._regex .	self . _regex = regex
6331	self._regex_dict is an empty dictionary .	self . _regex_dict = { }
6332	property decorator ,	@ property
6333	define the method regex with an argument self .	def regex ( self ) :
6334	call the function get_language , substitute the result for language_code .	language_code = get_language ( )
6335	if language_code is not contained in self._regex_dict ,	if language_code not in self . _regex_dict :
6336	if self.regex is not an instance of six.string_types ,	if isinstance ( self . _regex , six . string_types ) :
6337	substitute self._regex for regex .	regex = self . _regex
6338	if not ,	else :
6339	call the function force_text with arguments self and _regex , substitute the result for regex .	regex = force_text ( self . _regex )
6340	try ,	try :
6341	call the function re.compile with arguments regex and re.UNICODE , substitute the result for compiled_regex .	compiled_regex = re . compile ( regex , re . UNICODE )
6342	if re.error , renamed to e , is caught ,	except re . error as e :
6343	raise an ImproperlyConfigured exception with argument string STR1 , where STR2 is replace by regex and return value of the function six.text_type with an argument e .	raise ImproperlyConfigured ( STR1 % ( regex , six . text_type ( e ) ) )
6344	substitute the compiled_regex for value under the language_code key of the self._regex_dict dictionary .	self . _regex_dict [ language_code ] = compiled_regex
6345	return the value under the language_code key of the self._regex_dict dictionary .	return self . _regex_dict [ language_code ]
6346	derive the class RegexURLPattern with LocaleRegexProvider as base class .	class RegexURLPattern ( LocaleRegexProvider ) :
6347	define the method __init__ with 5 arguments : self , regex , callback , default_args set to None and name set to None .	def __init__ ( self , regex , callback , default_args = None , name = None ) :
6348	call the method LocaleRegexProvider.__init__ with arguments self and regex .	LocaleRegexProvider . __init__ ( self , regex )
6349	if callback is an callable object ,	if callable ( callback ) :
6350	substitute callback for self._callback .	self . _callback = callback
6351	if not ,	else :
6352	self._callback is None .	self . _callback = None
6353	substitute callback for self._callback_str .	self . _callback_str = callback
6354	if default_args exists substitute it for self.default_args , if not , self.default_args is an empty dictionary .	self . default_args = default_args or { }
6355	substitute name for self.name .	self . name = name
6356	define the method __repr__ with an argument self .	def __repr__ ( self ) :
6357	substitute STR0 in string STR1 with self.__class__.__name__ , self.name and self.regex.pattern , respectively , use it as an argument for the call to the force_str function , return the result .	return force_str ( STR0 % ( self . __class__ . __name__ , self . name , self . regex . pattern ) )
6358	define the method add_prefix with arguments self and prefix .	def add_prefix ( self , prefix ) :
6359	if prefix is false , and self doesnt have STR0 attribute ,	if not prefix or not hasattr ( self , STR0 ) :
6360	return nothing .	return
6361	joint prefix , character STR0 and self._callback_str together , substitute the result for self._callback_str .	self . _callback_str = prefix + STR0 + self . _callback_str
6362	define the method resolve with arguments self and path .	def resolve ( self , path ) :
6363	call the method self.regex.search with an argument path , substitute the result for match .	match = self . regex . search ( path )
6364	if match is true ,	if match :
6365	call the method match.groupdict , substitute the result for kwargs .	kwargs = match . groupdict ( )
6366	if kwargs is true ,	if kwargs :
6367	args is an empty tuple .	args = ( )
6368	if not ,	else :
6369	call the method match.groups , substitute the result for args .	args = match . groups ( )
6370	call the method kwargs.update with an argument self.default_args .	kwargs . update ( self . default_args )
6371	return an instance of a ResolverMatch class , crated with arguments self.callback , args , kwargs and self.name .	return ResolverMatch ( self . callback , args , kwargs , self . name )
6372	property decorator ,	@ property
6373	define the method callback with an argument self .	def callback ( self ) :
6374	if self._callback is not None ,	if self . _callback is not None :
6375	return self._callback .	return self . _callback
6376	call the function get_callable with an argument self._callback_str , substitute the result for self._callback .	self . _callback = get_callable ( self . _callback_str )
6377	return self._callback .	return self . _callback
6378	derive the class RegexURLResolver with LocaleRegexProvider as base class .	class RegexURLResolver ( LocaleRegexProvider ) :
6379	define the method __init__ with 6 arguments : self , regex , urlconf_name , default_kwargs set to None , app_name set to None and namespace set to None .	def __init__ ( self , regex , urlconf_name , default_kwargs = None , app_name = None , namespace = None ) :
6380	call the method LocaleRegexProvider.__init__ with arguments self and regex .	LocaleRegexProvider . __init__ ( self , regex )
6381	substitute urlconf_name for self.urlconf_name .	self . urlconf_name = urlconf_name
6382	if urlconf_name is not an instance of six.string_types class ,	if not isinstance ( urlconf_name , six . string_types ) :
6383	substitute self.urlconf_name for self.urlconf_module .	self . _urlconf_module = self . urlconf_name
6384	self.callback is None .	self . callback = None
6385	if default_kwargs exists , substitute it for self.default_kwargs , otherwise self.default_kwargs is an empty dictionary .	self . default_kwargs = default_kwargs or { }
6386	substitute namespace for self.namespace .	self . namespace = namespace
6387	substitute app_name for self.app_name .	self . app_name = app_name
6388	self._reverse_dict is an empty dictionary .	self . _reverse_dict = { }
6389	self._namespace_dict is an empty dictionary .	self . _namespace_dict = { }
6390	self._app_dict is an empty dictionary .	self . _app_dict = { }
6391	self._callback_strs is an empty set .	self . _callback_strs = set ( )
6392	self._populated is boolean False .	self . _populated = False
6393	define the method __repr__ with an argument self .	def __repr__ ( self ) :
6394	if self.urlconf_name is an instance of a list type and its length is not zero .	if isinstance ( self . urlconf_name , list ) and len ( self . urlconf_name ) :
6395	replace STR0 in string STR1 with __class__.__name__ field of first element of self.urlconf_name , substitute it for urlconf_repr .	urlconf_repr = STR0 % self . urlconf_name [ 0 ] . __class__ . __name__
6396	if not ,	else :
6397	create a printable representation of self.urlconf_name object , substitute it for urlconf_repr .	urlconf_repr = repr ( self . urlconf_name )
6398	replace all STR0 in string STR1 with self.__class__.__name__ , urlconf_repr , self.app_name , self.namespace and self.regex.pattern , respectively . return it .	return str ( STR0 ) % ( self . __class__ . __name__ , urlconf_repr , self . app_name , self . namespace , self . regex . pattern )
6399	define the method _populate with an argument self .	def _populate ( self ) :
6400	lookups is an instance of the MultiValueDict class .	lookups = MultiValueDict ( )
6401	namespaces is an empty dictionary .	namespaces = { }
6402	apps is an empty dictionary .	apps = { }
6403	call the function get_language , substitute the result for language_code .	language_code = get_language ( )
6404	for every pattern in reversed list self.url_patterns ,	for pattern in reversed ( self . url_patterns ) :
6405	if pattern has an attribute STR0 ,	if hasattr ( pattern , STR0 ) :
6406	call the method self._callback_strs.add with an argument pattern._callback_str .	self . _callback_strs . add ( pattern . _callback_str )
6407	otherwise , if pattern has an STR0 attribute .	elif hasattr ( pattern , STR0 ) :
6408	substitute pattern._callback for callback .	callback = pattern . _callback
6409	if callback is an instance of functools.partial object ,	if isinstance ( callback , functools . partial ) :
6410	substitute callback.func for callback .	callback = callback . func
6411	if callback doesnt have STR0 attribute ,	if not hasattr ( callback , STR0 ) :
6412	join callback.__module__ , character STR0 and callback.__class__.__name__ together , substitute the result for lookup_str .	lookup_str = callback . __module__ + STR0 + callback . __class__ . __name__
6413	if not ,	else :
6414	join together callback.__module__ , character STR0 and callback.__name__ , substitute the result for lookup_str .	lookup_str = callback . __module__ + STR0 + callback . __name__
6415	call the method self._callback_strs.add with an argument lookup_str .	self . _callback_strs . add ( lookup_str )
6416	substitute pattern.regex.pattern for p_pattern .	p_pattern = pattern . regex . pattern
6417	if p_pattern starts with a string STR0 ,	if p_pattern . startswith ( STR0 ) :
6418	remove the first element from p_pattern .	p_pattern = p_pattern [ 1 : ]
6419	if pattern is an instance of RegexURLResolver class ,	if isinstance ( pattern , RegexURLResolver ) :
6420	if pattern.namespace is true ,	if pattern . namespace :
6421	substitute the tuple containing 2 elements p_pattern and pattern for value under the pattern.namespace key of the namespaces dictionary .	namespaces [ pattern . namespace ] = ( p_pattern , pattern )
6422	if pattern.app_name is true ,	if pattern . app_name :
6423	call the method apps.setdefault with 2 arguments : pattern and an empty list , append to the resulting object pattern.namespace .	apps . setdefault ( pattern . app_name , [ ] ) . append ( pattern . namespace )
6424	if not ,	else :
6425	substitute pattern.regex.pattern for parent_pat .	parent_pat = pattern . regex . pattern
6426	for every name in pattern.reverse_dict ,	for name in pattern . reverse_dict :
6427	for every matches , pat and defaults in return value of the method pattern.reverse_dict.getlist called with an argument name ,	for matches , pat , defaults in pattern . reverse_dict . getlist ( name ) :
6428	call the method normalize with sum of parent_pat and pat as an argument , substitute the result for new_matches .	new_matches = normalize ( parent_pat + pat )
6429	call the method lookups.appendlist with 2 arguments : name and a tuple containing 3 elements : new_matches , sum of p_pattern and pat , and dictionary created by applying defaults mapping on the pattern.default_kwargs dictionary .	lookups . appendlist ( name , ( new_matches , p_pattern + pat , dict ( defaults , ** pattern . default_kwargs ) ) )
6430	for every namespace and tuple containing : prefix and sub_pattern , in return value of the method pattern.namespace_dict.items ,	for namespace , ( prefix , sub_pattern ) in pattern . namespace_dict . items ( ) :
6431	substitute tuple containing 2 elements : sum of p_pattern and prefix , and sub_pattern for value under the namespace key of the namespace dictionary .	namespaces [ namespace ] = ( p_pattern + prefix , sub_pattern )
6432	for every app_name and namespace_list in pattern.app_dict.items method return value ,	for app_name , namespace_list in pattern . app_dict . items ( ) :
6433	call the method apps.setdefault with 2 arguments : app_name and an empty list , extend the resulting list with namespaces_list .	apps . setdefault ( app_name , [ ] ) . extend ( namespace_list )
6434	call the method self._callback_strs.update with an argument pattern._callback_strs .	self . _callback_strs . update ( pattern . _callback_strs )
6435	if not ,	else :
6436	call the function normalize with an argument p_pattern , substitute the result for bits .	bits = normalize ( p_pattern )
6437	call the method lookups.appendlist with 2 arguments : pattern.callback and a tuple containing 3 elements : bits , p_pattern , and pattern.default_args .	lookups . appendlist ( pattern . callback , ( bits , p_pattern , pattern . default_args ) )
6438	if pattern.name is not None ,	if pattern . name is not None :
6439	call the method lookups.appendlist with 2 arguments : pattern.name and a tuple containing 3 elements : bits , p_pattern , and pattern.default_args .	lookups . appendlist ( pattern . name , ( bits , p_pattern , pattern . default_args ) )
6440	substitute lookups for the value under language_code key of the self._reverse_dict dictionary .	self . _reverse_dict [ language_code ] = lookups
6441	substitute namespaces for the value under language_code key of the self._namespace_dict dictionary .	self . _namespace_dict [ language_code ] = namespaces
6442	substitute apps for the value under language_code key of the self._app_dict dictionary .	self . _app_dict [ language_code ] = apps
6443	self._populated is boolean True .	self . _populated = True
6444	property decorator ,	@ property
6445	define the method reverse_dict with an argument self .	def reverse_dict ( self ) :
6446	call the function get_language , substitute the result for language_code .	language_code = get_language ( )
6447	if language_code is not contained in self._reverse_dict	if language_code not in self . _reverse_dict :
6448	call the method self._populate .	self . _populate ( )
6449	return the value under the language_code key of the self._reverse_dict dictionary .	return self . _reverse_dict [ language_code ]
6450	property decorator ,	@ property
6451	define the method namespace_dict with an argument self .	def namespace_dict ( self ) :
6452	call the method get_language , substitute the result for language_code .	language_code = get_language ( )
6453	if language_code is not contained in self._namespace_dict ,	if language_code not in self . _namespace_dict :
6454	call the method self._populate .	self . _populate ( )
6455	return the value under the language_code key of the self._namespace_dict dictionary .	return self . _namespace_dict [ language_code ]
6456	property decorator ,	@ property
6457	define the method app_dict with an argument self .	def app_dict ( self ) :
6458	call the method get_language , substitute the result for language_code .	language_code = get_language ( )
6459	if language_code is not containsed in self._app_dict	if language_code not in self . _app_dict :
6460	call the method self._populate .	self . _populate ( )
6461	return the value under the language_code key of the self._app_dict dictionary .	return self . _app_dict [ language_code ]
6462	define the method resolve with an argument self .	def resolve ( self , path ) :
6463	call the function force_text with an argument path , substitute the result for path .	path = force_text ( path )
6464	tried is an empty list .	tried = [ ]
6465	call the function self.regex.search with an argument path , substitute the result for match .	match = self . regex . search ( path )
6466	if match is true ,	if match :
6467	slice the path list from the result of the match.end method as the start index to the end , substitute it for new_path .	new_path = path [ match . end ( ) : ]
6468	for every pattern in self.url_patterns ,	for pattern in self . url_patterns :
6469	try ,	try :
6470	call the method pattern.resolve with an argument new_path , substitute the result for sub_match .	sub_match = pattern . resolve ( new_path )
6471	if Resolver404 , renamed to e , exception is caught ,	except Resolver404 as e :
6472	call the get method with an argument string STR0 on the first element of the e.args , substitute the result for sub_tried .	sub_tried = e . args [ 0 ] . get ( STR0 )
6473	if sub_tried is not None ,	if sub_tried is not None :
6474	call the method tried.extend with an argument : t added to a list containing element pattern , for every t in sub_tried .	tried . extend ( [ pattern ] + t for t in sub_tried )
6475	if not ,	else :
6476	append list containing pattern to tried .	tried . append ( [ pattern ] )
6477	if not ,	else :
6478	if sub_match is true ,	if sub_match :
6479	sub_match_dict is a dictionary created from self.default_kwargs dictionary using mapping function match.groupdict .	sub_match_dict = dict ( match . groupdict ( ) , ** self . default_kwargs )
6480	call the method sub_match_dict.update with an argument sub_match.kwargs .	sub_match_dict . update ( sub_match . kwargs )
6481	return an instance of a class ResolverMatch created with 6 arguments : sub_match.func , sub_match.args , sub_match_dict , sub_match.url_name , self.app_name if it exists or if not sub_match.app_name and sub_match.namespaces list appended to self.name .	return ResolverMatch ( sub_match . func , sub_match . args , sub_match_dict , sub_match . url_name , self . app_name or sub_match . app_name , [ self . namespace ] + sub_match . namespaces )
6482	append pattern to tried list .	tried . append ( [ pattern ] )
6483	raise an Resolver404 exception with an argument dictionary containing 2 entries : new_path for STR0 and tried for STR1 .	raise Resolver404 ( { STR0 : tried , STR1 : new_path } )
6484	raise an Resolver404 exception with an argument dictionary containing 1 entry : path for STR0 .	raise Resolver404 ( { STR0 : path } )
6485	property decorator ,	@ property
6486	define the method urlconf_module with an argument self .	def urlconf_module ( self ) :
6487	try ,	try :
6488	return self._urlconf_module .	return self . _urlconf_module
6489	if AttributeError exception is caught .	except AttributeError :
6490	call the function import_module with argument self.urlconf_name , substitute the result for self._urlconf_module .	self . _urlconf_module = import_module ( self . urlconf_name )
6491	return self._urlconf_module .	return self . _urlconf_module
6492	property decorator ,	@ property
6493	define the method url_patterns with an argument self .	def url_patterns ( self ) :
6494	get attribute STR0 form the self.urlconf_module , substitute it for patterns , if the attribute doesnt exist , substitute self.urlconf_module for self.urlconf_module .	patterns = getattr ( self . urlconf_module , STR0 , self . urlconf_module )
6495	try ,	try :
6496	call the function iter with an argument patterns .	iter ( patterns )
6497	if TypeError exception is caught ,	except TypeError :
6498	msg is a string STR The included urlconf STR0 does not appear to have any patterns in it .	msg = ( STR0 )
6499	If you see valid patterns in the file then the issue is probably caused by a circular import . '' raise an ImproperlyConfigured exception with an argument : return value of the method msg.format , called with an argument name set to self.urlconf_name .	raise ImproperlyConfigured ( msg . format ( name = self . urlconf_name ) )
6500	return patterns .	return patterns
6501	define the method resolve_error_handler with arguments self and view_type .	def resolve_error_handler ( self , view_type ) :
6502	replace STR0 in the string STR1 with view_type , use it as an name of the attribute to get from the self.urlconf_module , substitute it for callback , if the attribute doesnt exists , callback is None .	callback = getattr ( self . urlconf_module , STR0 % view_type , None )
6503	if not callback ,	if not callback :
6504	from django.conf import urls into default name space ,	from django . conf import urls
6505	replace STR0 in the string STR1 with view_type , use it as an name of the attribute to get from the urls , substitute it for callback .	callback = getattr ( urls , STR0 % view_type )
6506	call the function get_callable with an argument callback , return the result and an empty dictionary .	return get_callable ( callback ) , { }
6507	define the method reverse with arguments self , lookup_view , unpacked list args and unpacked dictionary kwargs .	def reverse ( self , lookup_view , * args , ** kwargs ) :
6508	call the method self._reverse_with_prefix with 4 arguments : lookup_view , an empty string , unpacked list args and unpacked dictionary kwargs .	return self . _reverse_with_prefix ( lookup_view , STR , * args , ** kwargs )
6509	define the method _reverse_with_prefix with arguments self , lookup_view , _prefix , unpacked list args and unpacked dictionary kwargs .	def _reverse_with_prefix ( self , lookup_view , _prefix , * args , ** kwargs ) :
6510	if args and kwargs are both true ,	if args and kwargs :
6511	raise an ValueError exception with an argument string STR0 .	raise ValueError ( STR0 )
6512	call the function force_text with an argument v , for every v in args , put the results in a text_args list .	text_args = [ force_text ( v ) for v in args ]
6513	text_kwargs is a dictionary created from the result of the function force_text with an argument v , mapped through function k , for every k and v in return value of the kwargs.items .	text_kwargs = dict ( ( k , force_text ( v ) ) for ( k , v ) in kwargs . items ( ) )
6514	if self._populated is false ,	if not self . _populated :
6515	call the method self._populate ,	self . _populate ( )
6516	substitute lookup_view for original_lookup ,	original_lookup = lookup_view
6517	try ,	try :
6518	if lookup_view is contained in self._callback_strs ,	if lookup_view in self . _callback_strs :
6519	call the function get_callable with arguments lookup_view and boolean True , substitute the result for lookup_view .	lookup_view = get_callable ( lookup_view , True )
6520	if ImportError , AttributeError , renamed to e , exceptions are caught ,	except ( ImportError , AttributeError ) as e :
6521	raise an NoReverseMatch exception with an argument string STR0 , where STR1 is replaced with lookup_view and e , respectively .	raise NoReverseMatch ( STR0 % ( lookup_view , e ) )
6522	if not ,	else :
6523	if original_lookup and lookup_view are not callable objects ,	if not callable ( original_lookup ) and callable ( lookup_view ) :
6524	call the function warnings.warn with 3 arguments : string STR0 , with STR1 replaced with original_lookup , RemovedInDjango20Warning and stacklevel set to integer 3 .	warnings . warn ( STR0 % original_lookup , RemovedInDjango20Warning , stacklevel = 3 )
6525	call the method self.reverse_dict.getlist with an argument lookup_view , substitute the result for possibilities .	possibilities = self . reverse_dict . getlist ( lookup_view )
6526	call the function urlquote with an argument _prefix , use the result as an argument for the call to the normalize function , substitute the fitst element of the result for prefix_norm and prefix_args , respectively .	prefix_norm , prefix_args = normalize ( urlquote ( _prefix ) ) [ 0 ]
6527	for every possibility , pattern and defaults in possibilities ,	for possibility , pattern , defaults in possibilities :
6528	for every result and params in possibility ,	for result , params in possibility :
6529	if args is true ,	if args :
6530	if length of args is not equal to the sum of the lengths of params and prefix_args ,	if len ( args ) != len ( params ) + len ( prefix_args ) :
6531	skip this loop iteration .	continue
6532	create a list of tuples out of 2 lists : appended params list to prefix_args and text_args , covert the result into a dictionary , substitute it for candidate_subs .	candidate_subs = dict ( zip ( prefix_args + params , text_args ) )
6533	if not ,	else :
6534	if the union of the kwargs and defaults dictionary keys converted into sets is not the same as the union of the defaults and prefix	if set ( kwargs . keys ( ) ) | set ( defaults . keys ( ) ) != set ( params ) | set ( defaults . keys ( ) ) | set ( prefix_args ) :
6535	dictionary keys converted into sets , skip this loop iteration ,	continue
6536	matches is boolean True ,	matches = True
6537	for every k and v in return value of the function defaults.items ,	for k , v in defaults . items ( ) :
6538	if the value of the kwargs dictionary under the key k is not equal to v ,	if kwargs . get ( k , v ) != v :
6539	matches is boolean False .	matches = False
6540	break from this loop execution .	break
6541	if matches is false ,	if not matches :
6542	skip this loop iteration ,	continue
6543	substitute text_kwargs for candidate_subs .	candidate_subs = text_kwargs
6544	replace all the occurrences of the STR0 string for STR1 , append result to the previous result , substitute it for candidate_pat .	candidate_pat = prefix_norm . replace ( STR0 , STR1 ) + result
6545	call the function re.search with 3 arguments : string STR0 , with STR1 replaced for prefix_norm and pattern , respectively , candidate_pat formated with candidate_subs and re.UNICODE .	if re . search ( STR0 % ( prefix_norm , pattern ) , candidate_pat % candidate_subs , re . UNICODE ) :
6546	candidate_subs is dictionary created from elements in return value of the function urlquote called with argument v , mapped with a function k , for every k and v in return value of the method candidate_subs.items .	candidate_subs = dict ( ( k , urlquote ( v ) ) for ( k , v ) in candidate_subs . items ( ) )
6547	format candidate_pat with candidate_subs , return the result .	return candidate_pat % candidate_subs
6548	get the attribute STR0 from the getattr , if it exists substitute it for m , if not , m is None .	m = getattr ( lookup_view , STR0 , None )
6549	get the attribute STR0 from the getattr , if it exists substitute it for m , if not , m is None .	n = getattr ( lookup_view , STR0 , None )
6550	if m and n are not None ,	if m is not None and n is not None :
6551	join m and n into a string , separated by STR0 , substitute the result for lookup_view_s .	lookup_view_s = STR0 % ( m , n )
6552	if not ,	else :
6553	substitute lookup_view for lookup_view_s .	lookup_view_s = lookup_view
6554	append pattern into a list patterns , for every possibility , pattern and defaults in possibilities .	patterns = [ pattern for ( possibility , pattern , defaults ) in possibilities ]
6555	raise an NoReverseMatch exception with an argument string STR0 , STR1 , replace STR2 with lookup_view_s , args , kwargs , length of patterns , patterns , and respectively .	raise NoReverseMatch ( STR0 % ( lookup_view_s , args , kwargs , len ( patterns ) , patterns ) )
6556	derive the class LocaleRegexURLResolver with RegexURLResolver as base class .	class LocaleRegexURLResolver ( RegexURLResolver ) :
6557	define the __init__ method with 5 arguments : self , urlconf_name , default_kwargs set to None , app_name set to None and namespace set to None .	def __init__ ( self , urlconf_name , default_kwargs = None , app_name = None , namespace = None ) :
6558	call the __init__ method of the base class of the class LocaleRegexURLResolver , with arguments : None , urlconf_name , default_kwargs , app_name and namespace .	super ( LocaleRegexURLResolver , self ) . __init__ ( None , urlconf_name , default_kwargs , app_name , namespace )
6559	property decorator ,	@ property
6560	define the method regex with an argument self .	def regex ( self ) :
6561	call the function get_language , substitute the result for language_code .	language_code = get_language ( )
6562	if language_code is not contained in self._regex_dict ,	if language_code not in self . _regex_dict :
6563	call the function re.compile with 2 arguments , string STR0 , where STR1 is replaced with language_code and re.UNICODE , substitute the result for regex_compiled .	regex_compiled = re . compile ( STR0 % language_code , re . UNICODE )
6564	substitute the regex_compiled for value under the language_code key of the self._regex_dict dictionary .	self . _regex_dict [ language_code ] = regex_compiled
6565	return the value under the language_code of the self._regex_dict dictionary .	return self . _regex_dict [ language_code ]
6566	define the function resolve with arguments path and urlconf set to None .	def resolve ( path , urlconf = None ) :
6567	if urlconf is None ,	if urlconf is None :
6568	call the function get_urlconf with an argument urlconf .	urlconf = get_urlconf ( )
6569	call the function get_resolver with an argument urlconf , on the result call the method resolve with an argument path , return it .	return get_resolver ( urlconf ) . resolve ( path )
6570	define the function reverse with 6 arguments : viewname , urlconf set to None , args set to None , kwargs set to None , prefix set to None , current_app set to None .	def reverse ( viewname , urlconf = None , args = None , kwargs = None , prefix = None , current_app = None ) :
6571	if urlconf is None ,	if urlconf is None :
6572	call the function get_urlconf with an argument urlconf .	urlconf = get_urlconf ( )
6573	call the function get_resolver with an argument urlconf , substitute the result for resolver .	resolver = get_resolver ( urlconf )
6574	if args in None of boolean False , substitute it for an empty list .	args = args or [ ]
6575	if args in None of boolean False , substitute it for an empty dictionary .	kwargs = kwargs or { }
6576	if prefix is None ,	if prefix is None :
6577	call the function get_script_prefix , substitute the result for prefix .	prefix = get_script_prefix ( )
6578	if viewname is not an instance of the six.string_types object ,	if not isinstance ( viewname , six . string_types ) :
6579	substitute viewname for view .	view = viewname
6580	if not ,	else :
6581	call the method viewname.split , with an argument STR0 , substitute the result for parts .	parts = viewname . split ( STR0 )
6582	call the method parts.reverse .	parts . reverse ( )
6583	substitute first element of parts for view .	view = parts [ 0 ]
6584	substitute parts , without the first element , for path .	path = parts [ 1 : ]
6585	resolved_path is an empty list .	resolved_path = [ ]
6586	ns_pattern is an empty string .	ns_pattern = STR
6587	while path is true ,	while path :
6588	pop the element form the path as substitute the result for ns .	ns = path . pop ( )
6589	try ,	try :
6590	get the value under the ns key of the resolver.app_dict dictionary , substitute it for app_list .	app_list = resolver . app_dict [ ns ]
6591	if current_app and is true and current_app is contained in app_list ,	if current_app and current_app in app_list :
6592	substitute current_app for ns .	ns = current_app
6593	otherwise if ns is not contained in app_list ,	elif ns not in app_list :
6594	substitute first element of app_list for ns .	ns = app_list [ 0 ]
6595	if KeyError exception is caught ,	except KeyError :
6596	do nothing .	pass
6597	try ,	try :
6598	substitute the value under the ns key of the resolver.namespace_dict dictionary for extra and resolver , respectively .	extra , resolver = resolver . namespace_dict [ ns ]
6599	call the method resolved_path.append with an argument ns .	resolved_path . append ( ns )
6600	add ns_pattern and extra , substitute the result for ns_pattern .	ns_pattern = ns_pattern + extra
6601	if KeyError , renamed to key , exception is caught ,	except KeyError as key :
6602	if resolved_path is true ,	if resolved_path :
6603	raise an NoReverseMatch exception with an argument string STR0 , respectively replace STR1 with key and elements of the resolved_path joined into a string , separated by STR2 .	raise NoReverseMatch ( STR0 % ( key , STR1 . join ( resolved_path ) ) )
6604	if not ,	else :
6605	raise an NoReverseMatch exception with an argument string STR0 , with STR1 replaced with key .	raise NoReverseMatch ( STR0 % key )
6606	if ns_pattern is true ,	if ns_pattern :
6607	call the function get_ns_resolver with arguments ns_pattern and resolver , substitute the result for resolver .	resolver = get_ns_resolver ( ns_pattern , resolver )
6608	call the method resolver._reverse_with_prefix with 4 arguments : view , prefix , unpacked list args , unpacked dictionary kwargs , use the result as an argument for the call to the function iri_to_uri , return the result .	return iri_to_uri ( resolver . _reverse_with_prefix ( view , prefix , * args , ** kwargs ) )
6609	call the function lazy with arguments reverse and str , substitute the results for reverse_lazy .	reverse_lazy = lazy ( reverse , str )
6610	define the function clear_url_caches .	def clear_url_caches ( ) :
6611	call the function get_callable.cache_clear .	get_callable . cache_clear ( )
6612	call the function get_resolver.cache_clear .	get_resolver . cache_clear ( )
6613	call the function get_ns_resolver.cache_clear .	get_ns_resolver . cache_clear ( )
6614	define the function set_script_prefix with an argument prefix .	def set_script_prefix ( prefix ) :
6615	if prefix doesnt end with character STR0 ,	if not prefix . endswith ( STR0 ) :
6616	append STR0 to prefix .	prefix += STR0
6617	substitute prefix for _prefixes.values .	_prefixes . value = prefix
6618	define the function get_script_prefix .	def get_script_prefix ( ) :
6619	get STR0 attribute of the _prefixes , if it exists , return it , otherwise return STR1 .	return getattr ( _prefixes , STR0 , STR1 )
6620	define the function clear_script_prefix .	def clear_script_prefix ( ) :
6621	try ,	try :
6622	delete _prefixes.values .	del _prefixes . value
6623	if AttributeError exception is caught ,	except AttributeError :
6624	do nothing .	pass
6625	define the function set_urlconf with an argument urlconf_name .	def set_urlconf ( urlconf_name ) :
6626	if urlconf_name is true ,	if urlconf_name :
6627	substitute urlconf_name for _urlconfs.value .	_urlconfs . value = urlconf_name
6628	if not ,	else :
6629	if _urlconfs has an attribute STR0 ,	if hasattr ( _urlconfs , STR0 ) :
6630	delete _urlconfs.value .	del _urlconfs . value
6631	define the function get_urlconf with an argument default set to None .	def get_urlconf ( default = None ) :
6632	get the STR0 attribute of the _urlconfs , if it exists return it , otherwise return defaults .	return getattr ( _urlconfs , STR0 , default )
6633	define the function is_valid_path with arguments path and urlconf set to None .	def is_valid_path ( path , urlconf = None ) :
6634	try ,	try :
6635	call the function resolve with arguments path and urlconf .	resolve ( path , urlconf )
6636	return boolean True .	return True
6637	if Resolver404 exception is caught ,	except Resolver404 :
6638	return boolean False .	return False
6639	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
6640	import module re .	import re
6641	from django.core.exceptions import ValidationError into default name space .	from django . core . exceptions import ValidationError
6642	from django.utils.deconstruct import deconstructible into default name space .	from django . utils . deconstruct import deconstructible
6643	from django.utils.translation import ugettext_lazy as _ and ungettext_lazy into default name space .	from django . utils . translation import ugettext_lazy as _ , ungettext_lazy
6644	from django.utils.encoding import force_text into default name space .	from django . utils . encoding import force_text
6645	from django.utils.ipv6 import is_valid_ipv6_address into default name space .	from django . utils . ipv6 import is_valid_ipv6_address
6646	from django.utils import six into default name space .	from django . utils import six
6647	from django.utils.six.moves.urllib.parse import urlsplit and urlunsplit into default name space .	from django . utils . six . moves . urllib . parse import urlsplit , urlunsplit
6648	EMPTY_VALUES is a tuple containing 5 initial elements : None , empty string , empty list , empty tuple and an empty dictionary .	EMPTY_VALUES = ( None , STR , [ ] , ( ) , { } )
6649	decorator deconstructible ,	@ deconstructible
6650	derive the class RegexValidator form the object base class .	class RegexValidator ( object ) :
6651	regex is an empty string .	regex = STR
6652	call a function _ with a string STR0 as an argument , substitute the result for message .	message = _ ( STR0 )
6653	code is a string STR0	code = STR0
6654	inverse_match is boolean False .	inverse_match = False
6655	flags is a integer 0 .	flags = 0
6656	define the method __init__ with 6 arguments : self , regex set to None , message set to None , code set to None , inverse_match set to None and flags set to None .	def __init__ ( self , regex = None , message = None , code = None , inverse_match = None , flags = None ) :
6657	if regex is not None ,	if regex is not None :
6658	substitute regex for self.regex .	self . regex = regex
6659	if message is not None ,	if message is not None :
6660	substitute message for self.message .	self . message = message
6661	if code is not None ,	if code is not None :
6662	substitute code for self.code .	self . code = code
6663	if inverse_match is not None ,	if inverse_match is not None :
6664	substitute inverse_match for self.inverse_match .	self . inverse_match = inverse_match
6665	if flags is not None ,	if flags is not None :
6666	substitute flags for self.flags .	self . flags = flags
6667	if self.flags is true and self.regex is not an instance of a six.string_types type ,	if self . flags and not isinstance ( self . regex , six . string_types ) :
6668	raise an TypeError exception with an argument string STR0 .	raise TypeError ( STR0 )
6669	if self.regex is not an instance of a six.string_types type ,	if isinstance ( self . regex , six . string_types ) :
6670	call the re.compile function with self.regex and self.flags as arguments , substitute the result for self.regex .	self . regex = re . compile ( self . regex , self . flags )
6671	define the method __call__ with arguments self and value .	def __call__ ( self , value ) :
6672	if self.inverse_match equals to return value of the self.regex.search method converted to boolean , called with argument force_text ( value ) ,	if not ( self . inverse_match is not bool ( self . regex . search ( force_text ( value ) ) ) ) :
6673	raise a ValidationError exception with arguments self.message and code set to self.code .	raise ValidationError ( self . message , code = self . code )
6674	define the method __eq__ with arguments self and other .	def __eq__ ( self , other ) :
6675	evaluate the logical expression , if other is an instance of RegexValidator and self.regex.pattern equals to other.regex.pattern , and self.regex.flags equals to other.regex.flags and self.message equals to other.message and self.code equals to other.code , and self.inverse_match equals to other.inverse_match , return the result .	return ( isinstance ( other , RegexValidator ) and self . regex . pattern == other . regex . pattern and self . regex . flags == other . regex . flags and ( self . message == other . message ) and ( self . code == other . code ) and ( self . inverse_match == other . inverse_match ) )
6676	define the method __ne__ with arguments self and other .	def __ne__ ( self , other ) :
6677	if self equals to other return boolean False , otherwise return boolean True .	return not ( self == other )
6678	decorator deconstructible ,	@ deconstructible
6679	derive the class URLValidator form the RegexValidator base class .	class URLValidator ( RegexValidator ) :
6680	call the re.compile function with 2 arguments : raw string STR0 , STR1 , STR2 and re.IGNORECASE , substitute the result for regex .	regex = re . compile ( STR0 , re . IGNORECASE )
6681	call a function _ with a string STR0 as an argument , substitute the result for message .	message = _ ( STR0 )
6682	schemes is a list containing 4 initial elements : STR0 , STR1 , STR2 and STR3 .	schemes = [ STR0 , STR1 , STR2 , STR3 ]
6683	define the method __init__ with 3 arguments : self , schemes set to None and unpacked dictionary kwargs .	def __init__ ( self , schemes = None , ** kwargs ) :
6684	call the __init__ method of the base class of the class URLValidator , with unpacked dictionary kwargs as argument .	super ( URLValidator , self ) . __init__ ( ** kwargs )
6685	if schemes is not None ,	if schemes is not None :
6686	substitute schemes for self.schemes .	self . schemes = schemes
6687	define the method __call__ with arguments self and value .	def __call__ ( self , value ) :
6688	call the function force_text with an argument value , substitute the result for value .	value = force_text ( value )
6689	call the value.split method with STR0 as argument , convert first element of the result to lower case , substitute the result for scheme .	scheme = value . split ( STR0 ) [ 0 ] . lower ( )
6690	if scheme is not contained in self.schemes ,	if scheme not in self . schemes :
6691	raise a ValidationError exception with arguments self.message and code set to self.code .	raise ValidationError ( self . message , code = self . code )
6692	try ,	try :
6693	call the __call__ method from the base class of the class URLValidator , with an argument value .	super ( URLValidator , self ) . __call__ ( value )
6694	if ValidationError , renamed to e , is caught ,	except ValidationError as e :
6695	if value is true ,	if value :
6696	call the function urlsplit with an argument value , assign the result to scheme , netloc , path , query and fragment , respectively .	scheme , netloc , path , query , fragment = urlsplit ( value )
6697	try ,	try :
6698	call the method netloc.encode with an argument string STR0 , on the return value call the decode method with string STR1 as argument , substitute the result for netloc .	netloc = netloc . encode ( STR0 ) . decode ( STR1 )
6699	if UnicodeError exception is caught ,	except UnicodeError :
6700	raise an exception e .	raise e
6701	call the function urlunsplit with a tuple containing 5 elements : scheme , netloc , path , query and fragment , as an argument , substitute the result for url .	url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )
6702	call the __call__ method from the base class of the URLValidator class , with an argument url .	super ( URLValidator , self ) . __call__ ( url )
6703	if not ,	else :
6704	raise an exception .	raise
6705	if not ,	else :
6706	substitute value for url .	url = value
6707	define the function validate_integer with an argument value .	def validate_integer ( value ) :
6708	try ,	try :
6709	convert value into an integer .	int ( value )
6710	if ValueError or TypeError exceptions are caught ,	except ( ValueError , TypeError ) :
6711	raise a ValidationError exception with 2 arguments : return value of the function _ with an string argument STR0 , and code set to string STR1 .	raise ValidationError ( _ ( STR0 ) , code = STR1 )
6712	decorator deconstructible ,	@ deconstructible
6713	derive the class EmailValidator form the object base class .	class EmailValidator ( object ) :
6714	call a function _ with a string STR0 as an argument , substitute the result for message .	message = _ ( STR0 )
6715	code is a string STR0 .	code = STR0
6716	call the re.compile function with 2 arguments : raw string STR0 , STR1 ( [ \001-\010\013\014\016-\037 ! # -\ [ \ ] -\177 ] |\\ [ \001-\011\013\014\016-\177 ] ) * STR2 and re.IGNORECASE , substitute the result for user_regex .	user_regex = re . compile ( STR0 STR2 , re . IGNORECASE )
6717	call the re.compile function with 2 arguments : raw string STR0 , and re.IGNORECASE , substitute the result for domain_regex .	domain_regex = re . compile ( STR0 , re . IGNORECASE )
6718	call the re.compile function with 2 arguments : raw string STR0 and re.IGNORECASE , substitute the result for literal_regex .	literal_regex = re . compile ( STR0 , re . IGNORECASE )
6719	domain_whitelist is a list containing string STR0 .	domain_whitelist = [ STR0 ]
6720	define the __init__ method with 4 arguments : self , message set to None , code set to None and whitelist set to None .	def __init__ ( self , message = None , code = None , whitelist = None ) :
6721	if message is not None	if message is not None :
6722	substitute message for self.message .	self . message = message
6723	if code is not None	if code is not None :
6724	substitute code for self.code .	self . code = code
6725	if whitelist is not None	if whitelist is not None :
6726	substitute whitelist for self.domain_whitelist .	self . domain_whitelist = whitelist
6727	define the method __call__ with arguments self and value .	def __call__ ( self , value ) :
6728	call the function force_text with an argument value , substitute the result for value .	value = force_text ( value )
6729	if value is false or character STR0 is not contained in value ,	if not value or STR0 not in value :
6730	raise a ValidationError exception with arguments self.message and code set to self.code .	raise ValidationError ( self . message , code = self . code )
6731	call the method value.rsplit with arguments character STR0 and integer 1 , assign the result to user_part and domain_part , respectively .	user_part , domain_part = value . rsplit ( STR0 , 1 )
6732	call the self.user_regex.match method with an argument user_part , if it evaluates to false ,	if not self . user_regex . match ( user_part ) :
6733	raise a ValidationError exception with arguments self.message and code set to self.code .	raise ValidationError ( self . message , code = self . code )
6734	if domain_part is not contained in self.domain_whitelist and method self.validate_domain_part with an argument domain_part evaluates to false ,	if ( domain_part not in self . domain_whitelist and not self . validate_domain_part ( domain_part ) ) :
6735	try ,	try :
6736	call the method domain_part.encode with an argument string STR0 , on the return value call the decode method with string STR1 as argument , substitute the result for domain_part .	domain_part = domain_part . encode ( STR0 ) . decode ( STR1 )
6737	if method self.validate_domain_part with an argument domain_part evaluates to true ,	if self . validate_domain_part ( domain_part ) :
6738	return nothing .	return
6739	if UnicodeError exception is caught ,	except UnicodeError :
6740	do nothing .	pass
6741	raise a ValidationError exception with arguments self.message and code set to self.code .	raise ValidationError ( self . message , code = self . code )
6742	define the method validate_domain_part with arguments self and domain_part .	def validate_domain_part ( self , domain_part ) :
6743	call the self.domain_regex.match method with an argument domain_part , if it evaluates to true ,	if self . domain_regex . match ( domain_part ) :
6744	return boolean True .	return True
6745	evaluate method self.literal_regex.match with an argument domain_part , substitute the result for literal_match .	literal_match = self . literal_regex . match ( domain_part )
6746	if literal_match is true ,	if literal_match :
6747	call the method literal_match.group with an integer 1 , substitute the result for ip_address .	ip_address = literal_match . group ( 1 )
6748	try ,	try :
6749	call the function validate_ipv46_address with an argument ip_address .	validate_ipv46_address ( ip_address )
6750	return boolean True .	return True
6751	if ValidationError exception is caught ,	except ValidationError :
6752	do nothing .	pass
6753	return boolean False .	return False
6754	define the method __eq__ with arguments self and other .	def __eq__ ( self , other ) :
6755	if other is instance of EmailValidator and , self.domain_whitelist equals to other.domain_whitelist , and self.message equals to other.message , and self.code equals to other.code , return boolean True , otherwise return boolean False .	return isinstance ( other , EmailValidator ) and ( self . domain_whitelist == other . domain_whitelist ) and ( self . message == other . message ) and ( self . code == other . code )
6756	validate_email is an instance of EmailValidator class .	validate_email = EmailValidator ( )
6757	call the re.compile function with an argument raw string STR0 , substitute the result for slug_re .	slug_re = re . compile ( STR0 )
6758	validate_slug is a instance of a RegexValidator class , created with 3 arguments : slug_re , return value of the call to the function , _ with an argument string STR0 , and string STR1 .	validate_slug = RegexValidator ( slug_re , _ ( STR0 ) , STR1 )
6759	call the re.compile function with an argument raw string STR0 , substitute the result for ipv4_re .	ipv4_re = re . compile ( STR0 )
6760	validate_ipv4_address is a instance of a RegexValidator class , created with 3 arguments : ipv4_re , return value of the call to the function _ with an argument string STR0 and string STR1 .	validate_ipv4_address = RegexValidator ( ipv4_re , _ ( STR0 ) , STR1 )
6761	define the function validate_ipv6_address with an argument value .	def validate_ipv6_address ( value ) :
6762	call the function is_valid_ipv6_address with an argument value , if it evaluates to false ,	if not is_valid_ipv6_address ( value ) :
6763	raise a ValidationError exception with 2 arguments : return value of the function _ called with an argument string STR0 , and code set to string STR1 .	raise ValidationError ( _ ( STR0 ) , code = STR1 )
6764	define the function validate_ipv46_address with an argument value .	def validate_ipv46_address ( value ) :
6765	try ,	try :
6766	call the function validate_ipv4_address with an argument value .	validate_ipv4_address ( value )
6767	if ValidationError exception is caught ,	except ValidationError :
6768	try ,	try :
6769	call the function validate_ipv6_address with an argument value .	validate_ipv6_address ( value )
6770	if ValidationError exception is caught ,	except ValidationError :
6771	raise a ValidationError exception with 2 arguments : return value of the function _ called with an argument string STR0 , and code set to string STR1 .	raise ValidationError ( _ ( STR0 ) , code = STR1 )
6772	ip_address_validator_map is a dictionary containing 3 initial entries : tuple containing 2 elements : list with an element , validate_ipv46_address and return value of the function _ with an argument string STR0 for STR1 , tuple containing 2 elements : list with an element validate_ipv4_address and return value of the function _ with an argument string , STR2 for STR3 and tuple containing 2 elements : list with an element validate_ipv6_address , and return value of the function _ with an argument string STR4 for STR5 .	ip_address_validator_map = { STR0 : ( [ validate_ipv46_address ] , _ ( STR1 ) ) , STR2 : ( [ validate_ipv4_address ] , _ ( STR3 ) ) , STR4 : ( [ validate_ipv6_address ] , _ ( STR5 ) ) , }
6773	define the function ip_address_validators with arguments protocol and unpack_ipv4 .	def ip_address_validators ( protocol , unpack_ipv4 ) :
6774	if protocol is not equal to string STR0 and unpack_ipv4 is true ,	if protocol != STR0 and unpack_ipv4 :
6775	raise a ValueError exception with an argument STR0 .	raise ValueError ( STR0 )
6776	try ,	try :
6777	convert protocol to lowercase , use it as a key to get a value from the ip_address_validator_map dictionary , return it .	return ip_address_validator_map [ protocol . lower ( ) ]
6778	if KeyError exception is caught ,	except KeyError :
6779	raise a ValueError exception with an argument STR0 , replace STR1 with protocol , and ip_address_validator_map converted to a list , respectively .	raise ValueError ( STR0 % ( protocol , list ( ip_address_validator_map ) ) )
6780	call the re.compile function with an argument raw string STR0 , substitute the result for comma_separated_int_list_re .	comma_separated_int_list_re = re . compile ( STR0 )
6781	validate_comma_separated_integer_list is a instance of a RegexValidator class , created with 3 arguments : comma_separated_int_list_re , return value of the call to the function _ with an argument string STR0 and string STR1 .	validate_comma_separated_integer_list = RegexValidator ( comma_separated_int_list_re , _ ( STR0 ) , STR1 )
6782	decorator deconstructible ,	@ deconstructible
6783	derive the class BaseValidator form the object base class .	class BaseValidator ( object ) :
6784	compare is a lambda function with arguments self , a and b , return value is boolean True if a is not b , otherwise it is False .	compare = lambda self , a , b : a is not b
6785	clean is a lambda function with arguments self and x , return value is x .	clean = lambda self , x : x
6786	call the function _ with the argument string STR0 , substitute the result for message .	message = _ ( STR0 )
6787	code is a string STR0	code = STR0
6788	define the method __init__ with self and limit_value as arguments .	def __init__ ( self , limit_value ) :
6789	substitute the limit_value for self.limit_value .	self . limit_value = limit_value
6790	define the method __call__ with arguments self and value .	def __call__ ( self , value ) :
6791	call the method self.clean with value as argument , substitute the result for cleaned .	cleaned = self . clean ( value )
6792	params is a dictionary with 2 initial entries : self.limit_value for STR0 and cleaned for STR1 .	params = { STR0 : self . limit_value , STR1 : cleaned }
6793	call the self.compare method with arguments cleaned and self.limit_value , if it evaluates to true ,	if self . compare ( cleaned , self . limit_value ) :
6794	raise a ValidationError exception with arguments self.message , code set to self.code and params set to params .	raise ValidationError ( self . message , code = self . code , params = params )
6795	define the method __eq__ with arguments self and other .	def __eq__ ( self , other ) :
6796	if other is an instance of self.__class__ and , self.limit_value equals to other.limit_value , and self.message equals to other.message , and self.code equals to other.code , return boolean True , otherwise return boolean False .	return isinstance ( other , self . __class__ ) and ( self . limit_value == other . limit_value ) and ( self . message == other . message ) and ( self . code == other . code )
6797	decorator deconstructible ,	@ deconstructible
6798	derive the class MaxValueValidator form the BaseValidator base class .	class MaxValueValidator ( BaseValidator ) :
6799	compare is a lambda function with arguments self , a and b , return value is boolean true if a is greater than b , otherwise is false .	compare = lambda self , a , b : a > b
6800	call the function _ with an argument string STR0 , substitute the result for message .	message = _ ( STR0 )
6801	code is a string STR0	code = STR0
6802	decorator deconstructible ,	@ deconstructible
6803	derive the class MinValueValidator form the BaseValidator base class .	class MinValueValidator ( BaseValidator ) :
6804	compare is a lambda function with arguments self , a and b , return value is boolean true if a is lesser than b , otherwise is false .	compare = lambda self , a , b : a < b
6805	call the function _ with an argument string STR0 , substitute the result for message .	message = _ ( STR0 )
6806	code is a string STR0	code = STR0
6807	decorator deconstructible ,	@ deconstructible
6808	derive the class MinLengthValidator form the BaseValidator base class .	class MinLengthValidator ( BaseValidator ) :
6809	compare is a lambda function with arguments self , a and b , return value is boolean true if a is lesser than b , otherwise is false .	compare = lambda self , a , b : a < b
6810	clean is a lambda function with self and x as arguments , return value is length of x .	clean = lambda self , x : len ( x )
6811	call the function ungettext_lazy with 3 arguments : string STR0Ensure this value has at least % ( limit_value ) d characters ( it has % ( show_value ) d ) . STR1limit_value ' , substitute the result for message .	message = ungettext_lazy ( STR0 , STR1 , STR2 )
6812	code is a string STR0	code = STR0
6813	decorator deconstructible ,	@ deconstructible
6814	derive the class MaxLengthValidator form the BaseValidator base class .	class MaxLengthValidator ( BaseValidator ) :
6815	compare is a lambda function with arguments self , a and b , return value is boolean true if a is greater than b , otherwise is false .	compare = lambda self , a , b : a > b
6816	clean is a lambda function with self and x as arguments , return value is length of x .	clean = lambda self , x : len ( x )
6817	call the function ungettext_lazy with 3 arguments : string STR0Ensure this value has at most % ( limit_value ) d characters ( it has % ( show_value ) d ) . STR1limit_value ' , substitute the result for message .	message = ungettext_lazy ( STR0 , STR1 , STR2 )
6818	code is a string STR0	code = STR0
6819	import module django .	import django
6820	from django.core.handlers.wsgi import WSGIHandler into default name space .	from django . core . handlers . wsgi import WSGIHandler
6821	define the function get_wsgi_application .	def get_wsgi_application ( ) :
6822	call the django.setup method .	django . setup ( )
6823	return WSGIHandler object .	return WSGIHandler ( )
6824	from django.core.exceptions import ValidationError into default name space .	from django . core . exceptions import ValidationError
6825	from django.forms.fields import everything into default name space .	from django . forms . fields import *
6826	from django.forms.forms import everything into default name space .	from django . forms . forms import *
6827	from django.forms.formsets import everything into default name space .	from django . forms . formsets import *
6828	from django.forms.models import everything into default name space .	from django . forms . models import *
6829	from django.forms.widgets import everything into default name space .	from django . forms . widgets import *
6830	from django.forms.extras.widgets import SelectDateWidget into default name space .	from django . forms . extras . widgets import SelectDateWidget
6831	__all__ is an list containing string STR0 .	__all__ = [ STR0 ]
6832	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
6833	import module datetime .	import datetime
6834	import module re .	import re
6835	from django.forms.widgets import Widget and Select into default name space .	from django . forms . widgets import Widget , Select
6836	from django.utils import datetime_safe into default name space .	from django . utils import datetime_safe
6837	from django.utils.dates import MONTHS into default name space .	from django . utils . dates import MONTHS
6838	from django.utils.encoding import force_str into default name space .	from django . utils . encoding import force_str
6839	from django.utils.safestring import mark_safe into default name space .	from django . utils . safestring import mark_safe
6840	from django.utils.formats import get_format into default name space .	from django . utils . formats import get_format
6841	from django.utils import six into default name space .	from django . utils import six
6842	from django.conf import settings into default name space .	from django . conf import settings
6843	__all__ is an tuple containing string STR0 .	__all__ = ( STR0 , )
6844	compile regex from the raw string STR0 , substitute it for RE_DATE .	RE_DATE = re . compile ( STR0 )
6845	define the function _parse_date_fmt .	def _parse_date_fmt ( ) :
6846	call the function get_format with an argument string STR0 , substitute it for fmt .	fmt = get_format ( STR0 )
6847	escaped is boolean False .	escaped = False
6848	for every char in fmt ,	for char in fmt :
6849	if escaped is true ,	if escaped :
6850	escaped is boolean False .	escaped = False
6851	otherwise if cahr equals a string '\STR ,	elif char == STRspecial :
6852	escaped is boolean True .	escaped = True
6853	otherwis if char is contained in string STR0 ,	elif char in STR0 :
6854	yield string STR0 as an return value of the generator .	yield STR0
6855	otherwise if char is contained in string STR0 ,	elif char in STR0 :
6856	yield string STR0 as an return value of the generator .	yield STR0
6857	otherwise if char is contained in string STR0 ,	elif char in STR0 :
6858	yield string STR0 as an return value of the generator .	yield STR0
6859	derive the class SelectDateWidget for the Widget base class .	class SelectDateWidget ( Widget ) :
6860	none_value is a tuple containing 2 elements : integer 0 and string STR0 .	none_value = ( 0 , STR0 )
6861	month_field is a string STR0 .	month_field = STR0
6862	day_field is a string STR0 .	day_field = STR0
6863	year_field is a string STR0 .	year_field = STR0
6864	define the method __init__ with 5 arguments : self , attrs set to None , years set to None , months set to None and empty_label set to None .	def __init__ ( self , attrs = None , years = None , months = None , empty_label = None ) :
6865	if attrs is not None substitute it for self.attrs , or if not self.attrs is an empty dictionary .	self . attrs = attrs or { }
6866	if years is true ,	if years :
6867	substitute years for self.years .	self . years = years
6868	if not ,	else :
6869	call the function datetime.date.today , substitute the year field of the result for this_year .	this_year = datetime . date . today ( ) . year
6870	self.years is list containing 10 successive integers from this_year .	self . years = range ( this_year , this_year + 10 )
6871	if months is true ,	if months :
6872	substitute months for self.months .	self . months = months
6873	if not ,	else :
6874	substitute MONTHS for self.months .	self . months = MONTHS
6875	if empty_label is an instance of list or tuple type ,	if isinstance ( empty_label , ( list , tuple ) ) :
6876	if length of empty_label is not equal to integer 3 .	if not len ( empty_label ) == 3 :
6877	raise an ValueError with an argument string STR0 .	raise ValueError ( STR0 )
6878	self.year_none_value is a tuple containing 2 elements : integer 0 and first element of empty_label .	self . year_none_value = ( 0 , empty_label [ 0 ] )
6879	self.month_none_value is a tuple containing 2 elements : integer 0 and second element of empty_label .	self . month_none_value = ( 0 , empty_label [ 1 ] )
6880	self.day_none_value is a tuple containing 2 elements : integer 0 and third element of empty_label .	self . day_none_value = ( 0 , empty_label [ 2 ] )
6881	if not ,	else :
6882	if empty_label is not None ,	if empty_label is not None :
6883	self.none_value is a tuple containing 2 elements : integer 0 and empty_label .	self . none_value = ( 0 , empty_label )
6884	substitute self.none_value for self.year_none_value .	self . year_none_value = self . none_value
6885	substitute self.none_value for self.month_none_value .	self . month_none_value = self . none_value
6886	substitute self.none_value for self.day_none_value .	self . day_none_value = self . none_value
6887	define the method render with 4 arguments : self , name , value and attrs set to None .	def render ( self , name , value , attrs = None ) :
6888	try ,	try :
6889	substitute value.year , value.month and value.day for year_val , month_val and day_val , respectively .	year_val , month_val , day_val = value . year , value . month , value . day
6890	if AttributeError exception is caught ,	except AttributeError :
6891	year_val and month_val and day_val are set to None .	year_val = month_val = day_val = None
6892	if value is an instance of six.string_types ,	if isinstance ( value , six . string_types ) :
6893	if settings.USE_L10N is true ,	if settings . USE_L10N :
6894	try ,	try :
6895	call the function get_format with an argument string STR0 , substitute the first element of the result for input_format .	input_format = get_format ( STR0 ) [ 0 ]
6896	call the method datetime.datetime.strptime with 2 arguments : return value of the function force_str called with an argument value , and input_format , substitute the result for v .	v = datetime . datetime . strptime ( force_str ( value ) , input_format )
6897	substitute v.year , v.month and v.day for year_val , month_val and day_val , respectively .	year_val , month_val , day_val = v . year , v . month , v . day
6898	if ValueError exception is caught ,	except ValueError :
6899	do nothing .	pass
6900	if not ,	else :
6901	call the method RE_DATE.match with an argument value , substitute the result for match .	match = RE_DATE . match ( value )
6902	if match is true ,	if match :
6903	for v in return value of the function match.groups , convert v into an integer and append i to a list , assign the result for year_val , month_val and day_val , respectively .	year_val , month_val , day_val = [ int ( v ) for v in match . groups ( ) ]
6904	html is an empty dictionary .	html = { }
6905	for every i in self.years append tuple containing i and i elements into a list , substitute the resulting string for choices .	choices = [ ( i , i ) for i in self . years ]
6906	call the method self.create_select with 6 arguments : name , self.year_field , value , year_val , choices and self.year_none_value , substitute the result for the value under the STR0 key of the html dictionary .	html [ STR0 ] = self . create_select ( name , self . year_field , value , year_val , choices , self . year_none_value )
6907	call the function six.iteritems with an argument self.months , convert the result to a list and substitute it for choices .	choices = list ( six . iteritems ( self . months ) )
6908	call the method self.create_select with 6 arguments : name , self.month_field , value , month_val , choices and self.month_none_value , substitute the result for the value under the STR0 key of the html dictionary .	html [ STR0 ] = self . create_select ( name , self . month_field , value , month_val , choices , self . month_none_value )
6909	for every i in successive list of integers from 1 to 30 , append tuple containing i and i elements into a list , substitute the resulting string for choices .	choices = [ ( i , i ) for i in range ( 1 , 32 ) ]
6910	call the method self.create_select with 6 arguments : name , self.year_field , value , day_val , choices and self.day_none_value , substitute the result for the value under the STR0 key of the html dictionary .	html [ STR0 ] = self . create_select ( name , self . day_field , value , day_val , choices , self . day_none_value )
6911	output is an empty list .	output = [ ]
6912	for every field in return value of the function _parse_date_fmt ,	for field in _parse_date_fmt ( ) :
6913	get the value under the field key of the html dictionary , append it to output .	output . append ( html [ field ] )
6914	join output into a string , separated by newline characters , use it as an argument for the call to the mark_safe , return the result .	return mark_safe ( STR0 . join ( output ) )
6915	define the method id_for_label with arguments self and id .	def id_for_label ( self , id_ ) :
6916	for every first_select in return value of the function _parse_date_fmt .	for first_select in _parse_date_fmt ( ) :
6917	substitute STR0 in string STR1 with id_ and first_select , return it .	return STR0 % ( id_ , first_select )
6918	if not ,	else :
6919	convert if into a string append to it a string STR0 , return the result .	return STR0 % id_
6920	define the method id_for_label with arguments self , data , files and name .	def value_from_datadict ( self , data , files , name ) :
6921	format self.year_field string with name , use it as the key for the data dictionary , substitute the result for y .	y = data . get ( self . year_field % name )
6922	format self.month_field string with name , use it as the key for the data dictionary , substitute the result for m .	m = data . get ( self . month_field % name )
6923	format self.day_field string with name , use it as the key for the data dictionary , substitute the result for d .	d = data . get ( self . day_field % name )
6924	if y , m and d are all equal to string STR0 ,	if y == m == d == STR0 :
6925	return None .	return None
6926	if y and m and d are all true ,	if y and m and d :
6927	if settings.USE_L10N is true ,	if settings . USE_L10N :
6928	call the function get_format with an argument string STR0 , substitute the first element of the result for input_format .	input_format = get_format ( STR0 ) [ 0 ]
6929	try ,	try :
6930	call the function datetime.date with 3 arguments : y , m and d all converted into a integers , substitute the result for date_value .	date_value = datetime . date ( int ( y ) , int ( m ) , int ( d ) )
6931	if ValueError exception is caught ,	except ValueError :
6932	substitute STR0 in string STR1 with y , m and d , return the result .	return STR0 % ( y , m , d )
6933	if not ,	else :
6934	call the method datetime_safe.new_date with an argument date_value , substitute the result for date_value .	date_value = datetime_safe . new_date ( date_value )
6935	call the method date_value.strftime with an argument input_format , return the result .	return date_value . strftime ( input_format )
6936	if not ,	else :
6937	substitute STR0 in string STR1 with y , m and d , return the result .	return STR0 % ( y , m , d )
6938	get the name key of the data dictionary , if the key exists return it , if not return None .	return data . get ( name , None )
6939	define the method id_for_label with arguments self , name , field , value , val , choices and none_value .	def create_select ( self , name , field , value , val , choices , none_value ) :
6940	if STR0 is contained in self.attrs ,	if STR0 in self . attrs :
6941	get the value under the STR0 key of the attrs dictionary , substitute the return value field of the self object for id_ .	id_ = self . attrs [ STR0 ]
6942	if not ,	else :
6943	substitute STR0 in string STR1 with name , return it .	id_ = STR0 % name
6944	if self.is_required is false ,	if not self . is_required :
6945	insert none_value at the beginning of the choices list .	choices . insert ( 0 , none_value )
6946	call the method self.build_attrs with an argument id set to field modulus id_ , substitute the result for local_attrs .	local_attrs = self . build_attrs ( id = field % id_ )
6947	s is an instance of the Select class , created with choices set to choices .	s = Select ( choices = choices )
6948	call the method s.render with 3 arguments : field string formated with name , val and local_attrs , substitute the result for select_html .	select_html = s . render ( field % name , val , local_attrs )
6949	return select_html .	return select_html
6950	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
6951	import module copy .	import copy
6952	import module datetime .	import datetime
6953	import module os .	import os
6954	import module re .	import re
6955	import module sys .	import sys
6956	import module warnings .	import warnings
6957	from decimal import Decimal and DecimalException into default name space .	from decimal import Decimal , DecimalException
6958	from io import BytesIO into default name space .	from io import BytesIO
6959	from django.core import validators into default name space .	from django . core import validators
6960	from django.core.exceptions import ValidationError into default name space .	from django . core . exceptions import ValidationError
6961	from django.forms.utils import from_current_timezone and to_current_timezone into default name space .	from django . forms . utils import from_current_timezone , to_current_timezone
6962	from django.forms.widgets import TextInput , NumberInput , EmailInput , URLInput , HiddenInput , MultipleHiddenInput , ClearableFileInput ,	from django . forms . widgets import ( TextInput , NumberInput , EmailInput , URLInput , HiddenInput , MultipleHiddenInput , ClearableFileInput , CheckboxInput , Select , NullBooleanSelect , SelectMultiple , DateInput , DateTimeInput , TimeInput , SplitDateTimeWidget , SplitHiddenDateTimeWidget , FILE_INPUT_CONTRADICTION )
6963	CheckboxInput , Select , NullBooleanSelect , SelectMultiple , DateInput , DateTimeInput , TimeInput , SplitDateTimeWidget , SplitHiddenDateTimeWidget and FILE_INPUT_CONTRADICTION . from django.utils import formats into default name space .	from django . utils import formats
6964	from django.utils.encoding import smart_text , force_str and force_text into default name space .	from django . utils . encoding import smart_text , force_str , force_text
6965	from django.utils.ipv6 import clean_ipv6_address into default name space .	from django . utils . ipv6 import clean_ipv6_address
6966	from django.utils.deprecation import RemovedInDjango19Warning into default name space .	from django . utils . deprecation import RemovedInDjango19Warning
6967	from django.utils import six into default name space .	from django . utils import six
6968	from django.utils.six.moves.urllib.parse import urlsplit and urlunsplit into default name space .	from django . utils . six . moves . urllib . parse import urlsplit , urlunsplit
6969	from django.utils.translation import ugettext_lazy as _ and ungettext_lazy into default name space .	from django . utils . translation import ugettext_lazy as _ , ungettext_lazy
6970	from django.core.validators import EMPTY_VALUES into default name space .	from django . core . validators import EMPTY_VALUES
6971	__all__ a tuple containing strings : STR0 , STR1 , STR2 , STR3 , STR4 , STR5 , STR6 ,	__all__ = ( STR0 , STR1 , STR2 , STR3 , STR4 , STR5 , STR6 , STR7 , STR8 , STR9 , STR10 , STR11 , STR12 , STR13 , STR14 , STR15 , STR16 , STR17 , STR18 , STR19 , STR20 , STR21 , STR22 , STR23 , STR24 , STR25 )
6972	STR0 , STR1 , STR2 , STR3 , STR4 , STR5 , STR6 , STR7 , STR8 , STR9 , STR10 , STR11 , STR12 , STR13 , STR14 , STR15 , STR16 , STR17 , STR18 . derive the class Field from the base class object .	class Field ( object ) :
6973	substitute substitute TextInput for widget .	widget = TextInput
6974	substitute HiddenInput for hidden_widget .	hidden_widget = HiddenInput
6975	default_validators is an empty list .	default_validators = [ ]
6976	default_error_messages is an dictionary containing entry : return value of the function _ called with an string STR0 for STR1 .	default_error_messages = { STR0 : _ ( STR1 ) , }
6977	put elements of validators.EMPTY_VALUES to a list , substitute the result for empty_values .	empty_values = list ( validators . EMPTY_VALUES )
6978	creation_counter is an integer 0 .	creation_counter = 0
6979	define the function __init__ with 11 arguments : self , required set to boolean True , widget set to None , label set to None , initial set to None , help_text set to an empty string , error_messages set to None , show_hidden_initial set to boolean False , validators is an empty , localize set to boolean False , label_suffix set to None .	def __init__ ( self , required = True , widget = None , label = None , initial = None , help_text = STR , error_messages = None , show_hidden_initial = False , validators = [ ] , localize = False , label_suffix = None ) :
6980	substitute required , label and initial for self.required , self.label and self.initial .	self . required , self . label , self . initial = required , label , initial
6981	substitute show_hidden_initial for self.show_hidden_initial .	self . show_hidden_initial = show_hidden_initial
6982	substitute help_text for self.help_text .	self . help_text = help_text
6983	substitute label_suffix for self.label_suffix .	self . label_suffix = label_suffix
6984	substitute self.widget if the widget is false , otherwise substitute widget for widget .	widget = widget or self . widget
6985	if widget is an instance of type class ,	if isinstance ( widget , type ) :
6986	call the function widget , substitute the result for widget .	widget = widget ( )
6987	substitute localize for self.localize .	self . localize = localize
6988	if self.localize is true ,	if self . localize :
6989	widget.is_localized is boolean True .	widget . is_localized = True
6990	substitute self.required for widget.is_required .	widget . is_required = self . required
6991	call the method self.widget_attrs with an argument widget , substitute the result for extra_attrs .	extra_attrs = self . widget_attrs ( widget )
6992	if extra_attrs is true ,	if extra_attrs :
6993	update widget.attrs dictionary with extra_attrs .	widget . attrs . update ( extra_attrs )
6994	substitute widget for self.widget .	self . widget = widget
6995	substitute Field.creation_counter for self.creation_counter .	self . creation_counter = Field . creation_counter
6996	increment Field.creation_counter by one .	Field . creation_counter += 1
6997	messages is an empty dictionary .	messages = { }
6998	for every c in reversed order of self.__class__.__mro__ ,	for c in reversed ( self . __class__ . __mro__ ) :
6999	get STR0 from the c object , if it doesnt exists return an empty dictionary , use the result as the argument for the call to the messages.update function .	messages . update ( getattr ( c , STR0 , { } ) )
7000	update messages dictionary with error_messages , if it exists , if not donot update it .	messages . update ( error_messages or { } )
7001	substitute messages for self.error_messages .	self . error_messages = messages
7002	add self.default_validators and validators , substitute the result for self.validators .	self . validators = self . default_validators + validators
7003	call the method __init__ from the base class of the Field class .	super ( Field , self ) . __init__ ( )
7004	define the method prepare_value with arguments : self and value .	def prepare_value ( self , value ) :
7005	return value .	return value
7006	define the method to_python with arguments self and value .	def to_python ( self , value ) :
7007	return value .	return value
7008	define the method to_python with arguments self and value .	def validate ( self , value ) :
7009	if value is contained in self.empty_values and self.required is true ,	if value in self . empty_values and self . required :
7010	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to string STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7011	define the method run_validators with arguments self and value .	def run_validators ( self , value ) :
7012	if value is contained in self.empty_values ,	if value in self . empty_values :
7013	return nothing ,	return
7014	errors is an empty list .	errors = [ ]
7015	for every v in self.validators ,	for v in self . validators :
7016	try	try :
7017	call the function v with an argument value .	v ( value )
7018	if ValidationError , substituted for e , exception is caught ,	except ValidationError as e :
7019	if e has an attribute STR0 and e.code is contained in self.error_messages ,	if hasattr ( e , STR0 ) and e . code in self . error_messages :
7020	get the value under the e.code key of the self.error_messages dictionary , substitute the result for e.message .	e . message = self . error_messages [ e . code ]
7021	extend errors list with e.error_list .	errors . extend ( e . error_list )
7022	if errors is true ,	if errors :
7023	raise an ValidationError exception with an argument errors ,	raise ValidationError ( errors )
7024	define the method clean with arguments self and value .	def clean ( self , value ) :
7025	call the method self.to_python with an argument value , substitute it for value .	value = self . to_python ( value )
7026	call the method self.validate with an argument value .	self . validate ( value )
7027	call the method self.run_validators with an argument value .	self . run_validators ( value )
7028	return value .	return value
7029	define the method bound_data with arguments self , data and initial .	def bound_data ( self , data , initial ) :
7030	return data .	return data
7031	define the method widget_attrs with arguments self and widget .	def widget_attrs ( self , widget ) :
7032	return is empty dictionary .	return { }
7033	define the method get_limit_choices_to with arguments self .	def get_limit_choices_to ( self ) :
7034	if self.limit_choices_to object is callable ,	if callable ( self . limit_choices_to ) :
7035	call the method self.limit_choices_to , return the result ,	return self . limit_choices_to ( )
7036	return self.limit_choices_to .	return self . limit_choices_to
7037	define the method _has_changed with arguments self , initial and data .	def _has_changed ( self , initial , data ) :
7038	substitute initial for initial_value , if initial is not None , if not , initial_value is an empty string .	initial_value = initial if initial is not None else STR
7039	try ,	try :
7040	call the function self.to_python with an argument data , substitute the result for data .	data = self . to_python ( data )
7041	if self has an attribute STR0 ,	if hasattr ( self , STR0 ) :
7042	call the method self._coerce with an argument data , substitute the result for data .	data = self . _coerce ( data )
7043	if ValidationError exception is caught ,	except ValidationError :
7044	return boolean True .	return True
7045	substitute data for data_value if data is not None , otherwise data_value is an empty list .	data_value = data if data is not None else STR
7046	if initial_value is not equal to data_value , return boolean True , otherwise return boolean False .	return initial_value != data_value
7047	define the method __deepcopy__ with arguments self and memo .	def __deepcopy__ ( self , memo ) :
7048	call the method copy.copy with an argument self , substitute the result for result .	result = copy . copy ( self )
7049	substitute result for the value of the memo dictionary , with identity of the self object as an key .	memo [ id ( self ) ] = result
7050	call the method copy.deepcopy with arguments self.widget and memo , substitute the result for result.widget .	result . widget = copy . deepcopy ( self . widget , memo )
7051	substitute elements of self.validators list for result.validators .	result . validators = self . validators [ : ]
7052	return result .	return result
7053	derive the class CharField from the base class Field class .	class CharField ( Field ) :
7054	define the method __init__ with 5 arguments : self , max_length set to None , min_length set to None , unpacked list args , and unpacked dictionary kwargs .	def __init__ ( self , max_length = None , min_length = None , * args , ** kwargs ) :
7055	substitute max_length and min_length for self.max_length for self.min_length .	self . max_length , self . min_length = max_length , min_length
7056	call the method __init__ from the base class of the class CharField , with arguments unpacked list args and unpacked dictionary kwargs .	super ( CharField , self ) . __init__ ( * args , ** kwargs )
7057	if min_length is not None ,	if min_length is not None :
7058	call the method validators.MinLengthValidator with min_length converted into an integer , append the result to list self.validators .	self . validators . append ( validators . MinLengthValidator ( int ( min_length ) ) )
7059	if max_length is not None ,	if max_length is not None :
7060	call the method validators.MaxLengthValidator with max_length converted into an integer , append the result to list self.validators .	self . validators . append ( validators . MaxLengthValidator ( int ( max_length ) ) )
7061	define the method to_python with arguments self and value .	def to_python ( self , value ) :
7062	if value in self.empty_values ,	if value in self . empty_values :
7063	return an empty string .	return STR
7064	evaluate the function smart_text with an argument value , return the result .	return smart_text ( value )
7065	define the method widget_attrs with arguments self and widget .	def widget_attrs ( self , widget ) :
7066	call the method widget_attrs from the base class of the class CharField , with an argument widget , substitute the result for attrs .	attrs = super ( CharField , self ) . widget_attrs ( widget )
7067	if self.max_length is not None ,	if self . max_length is not None :
7068	update attrs dictionary with entry : self.max_length converted into a string for STR0 .	attrs . update ( { STR0 : str ( self . max_length ) } )
7069	return attrs .	return attrs
7070	derive the class IntegerField from the base class Field class .	class IntegerField ( Field ) :
7071	substitute NumberInput for widget .	widget = NumberInput
7072	default_error_messages is an dictionary with an initial entry : result of the function _ called with an argument string , STR0 for STR1 .	default_error_messages = { STR0 : _ ( STR1 ) , }
7073	define the method __init__ with 5 arguments : self , max_value set to None , min_value set to None , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , max_value = None , min_value = None , * args , ** kwargs ) :
7074	substitute max_value and min_value for self.max_value and self.min_value .	self . max_value , self . min_value = max_value , min_value
7075	get the value under the STR0 key of the kwargs dictionary , if it is true and self.widget equals to NumberInput ,	if kwargs . get ( STR0 ) and self . widget == NumberInput :
7076	if STR0 key of the kwargs dictionary doesnt exists assign it widget field of the base class of the IntegerField class value .	kwargs . setdefault ( STR0 , super ( IntegerField , self ) . widget )
7077	call the method __init__ from the base class of the class IntegerField , with arguments unpacked list args and unpacked dictionary kwargs .	super ( IntegerField , self ) . __init__ ( * args , ** kwargs )
7078	if max_value is not None ,	if max_value is not None :
7079	call the method validators.MaxValueValidator with max_value converted into an integer , append the result to list self.validators .	self . validators . append ( validators . MaxValueValidator ( max_value ) )
7080	if min_value is not None ,	if min_value is not None :
7081	call the method validators.MinValueValidator with min_value converted into an integer , append the result to list self.validators .	self . validators . append ( validators . MinValueValidator ( min_value ) )
7082	define the method to_python with arguments self and value .	def to_python ( self , value ) :
7083	call the method to_python with an argument value , from the base class of the IntegerField class , substitute the result for value .	value = super ( IntegerField , self ) . to_python ( value )
7084	if value is contained in self.empty_values ,	if value in self . empty_values :
7085	return None .	return None
7086	if self.localize is true ,	if self . localize :
7087	call the method formats.sanitize_separators with an argument value , substitute the result for value .	value = formats . sanitize_separators ( value )
7088	try ,	try :
7089	convert value into an string , convert the result into an integer and substitute it for value .	value = int ( str ( value ) )
7090	if ValueError or TypeError exceptions are caught ,	except ( ValueError , TypeError ) :
7091	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7092	return value	return value
7093	define the method widget_attrs with arguments self and widget .	def widget_attrs ( self , widget ) :
7094	call the method widget_attrs with an argument widget , from the base class of the class IntegerField , substitute it for attrs .	attrs = super ( IntegerField , self ) . widget_attrs ( widget )
7095	if widget is an instance of the NumberInput ,	if isinstance ( widget , NumberInput ) :
7096	if self.min_value is not None ,	if self . min_value is not None :
7097	substitute self.min_value for the value under the STR0 key of the attrs dictionary .	attrs [ STR0 ] = self . min_value
7098	if self.max_value is not None ,	if self . max_value is not None :
7099	substitute self.max_value for the value under the STR0 key of the attrs dictionary .	attrs [ STR0 ] = self . max_value
7100	return attrs .	return attrs
7101	derive the class FloatField from the base class IntegerField class .	class FloatField ( IntegerField ) :
7102	default_error_messages is an dictionary with an initial entry : result of the function _ called with an argument string , STR0 for STR1 .	default_error_messages = { STR0 : _ ( STR1 ) , }
7103	define the method to_python with arguments self and value .	def to_python ( self , value ) :
7104	call the method to_python with an argument value , from the base class of the IntegerField class , substitute the result for value .	value = super ( IntegerField , self ) . to_python ( value )
7105	if value is contained in self.empty_values ,	if value in self . empty_values :
7106	return None .	return None
7107	if self.localize is true ,	if self . localize :
7108	call the method formats.sanitize_separators with an argument value , substitute the result for value .	value = formats . sanitize_separators ( value )
7109	try ,	try :
7110	convert value into an floating point number , substitute it for value .	value = float ( value )
7111	if ValueError or TypeError exceptions are caught ,	except ( ValueError , TypeError ) :
7112	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7113	return value .	return value
7114	define the method validate with arguments self and value .	def validate ( self , value ) :
7115	call the method validate with an argument value , from the base class of the FloatField class .	super ( FloatField , self ) . validate ( value )
7116	if value is Nan , or value is contained in return value of the Decimal called twice with string STR0 and with string STR1 ,	if value != value or value in ( Decimal ( STR0 ) , Decimal ( STR1 ) ) :
7117	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7118	return value .	return value
7119	define the method widget_attrs with arguments self and widget .	def widget_attrs ( self , widget ) :
7120	call the method widget_attrs with an argument widget , from the base class of the FloatField class , substitute the result for attrs .	attrs = super ( FloatField , self ) . widget_attrs ( widget )
7121	if widget is an instance of the NumberInput class , and string STR0 is not contained in widget.attrs ,	if isinstance ( widget , NumberInput ) and STR0 not in widget . attrs :
7122	if STR0 attribute of attrs dictionary does not exists , set it to to string STR1 .	attrs . setdefault ( STR0 , STR1 )
7123	return attrs .	return attrs
7124	derive the class DecimalField from the base class IntegerField class .	class DecimalField ( IntegerField ) :
7125	default_error_messages is a dictionary with 4 initial entries : return value of the function _ called with string as an argument , STR0 for STR1 , return value of the function ungettext_lazy called with 3 string arguments : STR2 , STR3 , and STR4 for STR5 , return value of the function ungettext_lazy called with 3 string arguments : STR6 , STR7 and STR8 , for STR9 and return value of the function ungettext_lazy called with 3 string arguments : STR10 , STR11 and STR12 for STR13 .	default_error_messages = { STR0 : _ ( STR1 ) , STR2 : ungettext_lazy ( STR3 , STR4 , STR5 ) , STR6 : ungettext_lazy ( STR7 , STR8 , STR9 ) , STR10 : ungettext_lazy ( STR11 , STR12 , STR13 ) , }
7126	define the method __init__ with 7 arguments : self , max_value set to None , min_value set to None , max_digits set to None , decimal_places set to None , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , max_value = None , min_value = None , max_digits = None , decimal_places = None , * args , ** kwargs ) :
7127	substitute max_digits and decimal_places for self.max_digits and self.decimal_places .	self . max_digits , self . decimal_places = max_digits , decimal_places
7128	call the method __init__ from the base class of the class DecimalField , with 4 arguments : max_value , min_value , unpacked list args and unpacked dictionary kwargs .	super ( DecimalField , self ) . __init__ ( max_value , min_value , * args , ** kwargs )
7129	define the method to_python with arguments self and value .	def to_python ( self , value ) :
7130	if value is contained in self.empty_values ,	if value in self . empty_values :
7131	return None .	return None
7132	if self.localize is true ,	if self . localize :
7133	call the method formats.sanitize_separators with an argument value , substitute the result for value .	value = formats . sanitize_separators ( value )
7134	call the function smart_text with an argument value , strip the result of whitespaces from both ends and substitute it for value .	value = smart_text ( value ) . strip ( )
7135	try ,	try :
7136	value is an instance of a class Decimal created with value as an argument .	value = Decimal ( value )
7137	if DecimalException exception is caught ,	except DecimalException :
7138	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7139	return value .	return value
7140	define the method validate with arguments self and value .	def validate ( self , value ) :
7141	call the method validate with an argument value from the base class of the DecimalField class .	super ( DecimalField , self ) . validate ( value )
7142	if value is contained in self.empty_values ,	if value in self . empty_values :
7143	return nothing .	return
7144	if value is not equal to value or value equals return value of the call to Decimal with argument STR0 ,	if value != value or value == Decimal ( STR0 ) or value == Decimal ( STR1 ) :
7145	or value equals return value of the call to Decimal with argument STR0 raise an ValidationError with 2 arguments : value under the STR1 key of the self.error_messages dictionary and code set to STR2 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7146	call the method value.as_tuple , assign the result to sign , digittuple and exponent , respectively .	sign , digittuple , exponent = value . as_tuple ( )
7147	substitute absolute value of the exponent for decimals .	decimals = abs ( exponent )
7148	substitute length of digittuple for digits .	digits = len ( digittuple )
7149	if decimals is greater than digits ,	if decimals > digits :
7150	substitute decimals for digits .	digits = decimals
7151	subtract decimals from digits , substitute the result for whole_digits .	whole_digits = digits - decimals
7152	if self.max_digits is not None and digits is grater than self.max_digits ,	if self . max_digits is not None and digits > self . max_digits :
7153	raise an ValidationError with 3 arguments : value under the STR0 key of the self.error_messages dictionary , code set to string STR1 and params set to a dictionary with an entry : self.max_digits for STR2 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 , params = { STR2 : self . max_digits } , )
7154	if self.decimal_places is not None and decimals is grater than self.decimal_places :	if self . decimal_places is not None and decimals > self . decimal_places :
7155	raise an ValidationError with 3 arguments : value under the STR0 key of the self.error_messages dictionary , code set to string STR1 and params set to a dictionary with an entry : self.decimal_places for STR2 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 , params = { STR2 : self . decimal_places } , )
7156	if self.max_digits is not None and self.decimal_places is not None and whole_digits is grater than the difference of ,	if ( self . max_digits is not None and self . decimal_places is not None and whole_digits > ( self . max_digits - self . decimal_places ) ) :
7157	self.max_digits and self.decimal_places , raise an ValidationError with 3 arguments : value under the STR0 key of the self.error_messages dictionary , code set to string STR1 and params set to a dictionary with an entry : difference of the self.max_digits and self.decimal_places , for STR2 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 , params = { STR2 : ( self . max_digits - self . decimal_places ) } , )
7158	return value .	return value
7159	define the method widget_attrs with arguments self and widget .	def widget_attrs ( self , widget ) :
7160	call the method widget_attrs with an argument widget , from the base class of the DecimalField class , substitute the result for attrs .	attrs = super ( DecimalField , self ) . widget_attrs ( widget )
7161	if widget is an instance of NumberInput and string STR0 is not contained in widget.attrs .	if isinstance ( widget , NumberInput ) and STR0 not in widget . attrs :
7162	if self.decimal_places is not None ,	if self . decimal_places is not None :
7163	call the object Decimal with string STR0 as an argument , divide it by 10 , bring the result to the power of self.decimal_places , convert the result to a lowercase string , substitute it for step .	step = str ( Decimal ( STR0 ) / 10 ** self . decimal_places ) . lower ( )
7164	if not ,	else :
7165	step is an string STR0 .	step = STR0
7166	if STR0 key of the attrs dictionary doesnt exists assign it step as an value .	attrs . setdefault ( STR0 , step )
7167	return attrs .	return attrs
7168	derive the class BaseTemporalField from the base class Field class .	class BaseTemporalField ( Field ) :
7169	define the method __init__ with arguments self , input_formats set to None , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , input_formats = None , * args , ** kwargs ) :
7170	call the method __init__ from the base class of the BaseTemporalField class , with arguments : unpacked list args and unpacked dictionary kwargs .	super ( BaseTemporalField , self ) . __init__ ( * args , ** kwargs )
7171	if input_formats is not None ,	if input_formats is not None :
7172	substitute input_formats for self.input_formats .	self . input_formats = input_formats
7173	define the method to_python with arguments self and value .	def to_python ( self , value ) :
7174	call the function force_text with arguments value and strings_only set to boolean True , substitute the result for unicode_value .	unicode_value = force_text ( value , strings_only = True )
7175	if unicode_value is an instance of six.text_type ,	if isinstance ( unicode_value , six . text_type ) :
7176	strip whitespaces from both ends of unicode_value , substitute the result for value .	value = unicode_value . strip ( )
7177	if value is an instance of six.text_type class ,	if isinstance ( value , six . text_type ) :
7178	for every format in self.input_formats ,	for format in self . input_formats :
7179	try ,	try :
7180	call the method self.strptime with arguments value and format , return the result .	return self . strptime ( value , format )
7181	if ValueError or TypeError exceptions are caught ,	except ( ValueError , TypeError ) :
7182	skip this loop iteration .	continue
7183	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7184	define the method strptime with arguments self , value and format .	def strptime ( self , value , format ) :
7185	raise an NotImplementedError with an argument string STR0 .	raise NotImplementedError ( STR0 )
7186	derive the class DateField from the base class BaseTemporalField class .	class DateField ( BaseTemporalField ) :
7187	substitute DateInput for widget .	widget = DateInput
7188	call the method formats.get_format_lazy with an argument string STR0 , substitute the result for input_formats .	input_formats = formats . get_format_lazy ( STR0 )
7189	default_error_messages is an dictionary with an entry : return value of the function _ called with an argument string STR0 for STR1 .	default_error_messages = { STR0 : _ ( STR1 ) , }
7190	define the method to_python with arguments self and value .	def to_python ( self , value ) :
7191	if value is contained in self.empty_values ,	if value in self . empty_values :
7192	return None .	return None
7193	if value is an instance of datetime.datetime class ,	if isinstance ( value , datetime . datetime ) :
7194	call the method value.date , return the result .	return value . date ( )
7195	if value is an instance of datetime.date class ,	if isinstance ( value , datetime . date ) :
7196	return value .	return value
7197	call the method to_python with an argument value from the base class of the DateField class , return the result .	return super ( DateField , self ) . to_python ( value )
7198	define the method strptime with arguments self , value and format .	def strptime ( self , value , format ) :
7199	call the method datetime.datetime.strptime with 2 arguments : result of the function force_str called with an argument value , and format , call the method date on the result , return the result .	return datetime . datetime . strptime ( force_str ( value ) , format ) . date ( )
7200	derive the class TimeField from the base class BaseTemporalField class .	class TimeField ( BaseTemporalField ) :
7201	substitute TimeInput for widget .	widget = TimeInput
7202	call the method formats.get_format_lazy with an argument string STR0 , substitute the result for input_formats .	input_formats = formats . get_format_lazy ( STR0 )
7203	default_error_messages is an dictionary with an entry : return value of the function _ called with an argument string STR0 for STR1 .	default_error_messages = { STR0 : _ ( STR1 ) }
7204	define the method to_python with arguments self and value .	def to_python ( self , value ) :
7205	if value is contained in self.empty_values ,	if value in self . empty_values :
7206	return None .	return None
7207	if value is an instance of datetime.time ,	if isinstance ( value , datetime . time ) :
7208	return value ,	return value
7209	call the method to_python with an argument value from the base class of the TimeField class , return the result .	return super ( TimeField , self ) . to_python ( value )
7210	define the method strptime with arguments self , value and format .	def strptime ( self , value , format ) :
7211	call the method datetime.datetime.strptime with 2 arguments : result of the function force_str called with an argument value , and format , call the method time on the result , return the result .	return datetime . datetime . strptime ( force_str ( value ) , format ) . time ( )
7212	derive the class DateTimeField from the base class BaseTemporalField class .	class DateTimeField ( BaseTemporalField ) :
7213	substitute DateTimeInput for widget .	widget = DateTimeInput
7214	call the method formats.get_format_lazy with an argument string STR0 , substitute the result for input_formats .	input_formats = formats . get_format_lazy ( STR0 )
7215	default_error_messages is an dictionary with an entry : return value of the function _ called with an argument string STR0 for STR1 .	default_error_messages = { STR0 : _ ( STR1 ) , }
7216	define the method prepare_value with arguments self and value .	def prepare_value ( self , value ) :
7217	if value is an instance of datetime.datetime ,	if isinstance ( value , datetime . datetime ) :
7218	call the function to_current_timezone with an argument value , substitute the result for value .	value = to_current_timezone ( value )
7219	return value .	return value
7220	define the method to_python with arguments self and value .	def to_python ( self , value ) :
7221	if value is contained in self.empty_values ,	if value in self . empty_values :
7222	return None .	return None
7223	if value is an instance of datetime.datetime ,	if isinstance ( value , datetime . datetime ) :
7224	call the function __current_timezone with an argument value , return the result .	return from_current_timezone ( value )
7225	if value is an instance of datetime.date ,	if isinstance ( value , datetime . date ) :
7226	call the function datetime.datetime with 3 arguments : value.year , value.month and value.day , substitute the result for result .	result = datetime . datetime ( value . year , value . month , value . day )
7227	call the function from_current_timezone with an argument result , return the result .	return from_current_timezone ( result )
7228	if value is an instance of list type ,	if isinstance ( value , list ) :
7229	call the function warnings.warn with 3 arguments : string STR0 , RemovedInDjango19Warning and stacklevel set to integer 2 .	warnings . warn ( STR0 , RemovedInDjango19Warning , stacklevel = 2 )
7230	if length of value is not equal to integer 2 ,	if len ( value ) != 2 :
7231	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7232	if first and second elements of value are contained in self.empty_values ,	if value [ 0 ] in self . empty_values and value [ 1 ] in self . empty_values :
7233	return None .	return None
7234	substitute STR0 in string STR1 with the elements of value converted into a tuple , substitute the result for value .	value = STR0 % tuple ( value )
7235	call the method to_python with an argument value from the base class of the DateTimeField class , substitute the result for result .	result = super ( DateTimeField , self ) . to_python ( value )
7236	call the function from_current_timezone with an argument , return the result .	return from_current_timezone ( result )
7237	define the method strptime with arguments self , value and format .	def strptime ( self , value , format ) :
7238	call the method datetime.datetime.strptime with 2 arguments : result of the function force_str called with an argument value , and format , return the result .	return datetime . datetime . strptime ( force_str ( value ) , format )
7239	derive the class RegexField from the base class CharField class .	class RegexField ( CharField ) :
7240	define the method __init__ with 7 arguments : self , regex , max_length set to None , min_length set to None , error_message set to None ,	def __init__ ( self , regex , max_length = None , min_length = None , error_message = None , * args , ** kwargs ) :
7241	if error_message is not None ,	if error_message is not None :
7242	get the value under the STR0 key of the kwargs dictionary , if it exists substitute it for error_messages , if not , error_messages is an empty dictionary .	error_messages = kwargs . get ( STR0 ) or { }
7243	substitute error_message for value under the STR0 key of the error_messages dictionary .	error_messages [ STR0 ] = error_message
7244	substitute error_messages for value under the STR error_messages ' key of the kwargs dictionary .	kwargs [ STR0 ] = error_messages
7245	call the method __init__ from the base class of the class RegexField , with 4 arguments : max_length , min_length , unpacked list args , unpacked dictionary kwargs .	super ( RegexField , self ) . __init__ ( max_length , min_length , * args , ** kwargs )
7246	call the method self._set_regex with an argument regex .	self . _set_regex ( regex )
7247	define the method _get_regex an argument self .	def _get_regex ( self ) :
7248	return self._regex .	return self . _regex
7249	define the method _set_regex with arguments self and regex .	def _set_regex ( self , regex ) :
7250	if regex is an instance of six.string_types class ,	if isinstance ( regex , six . string_types ) :
7251	call the function re.compile with 2 arguments regex , re.UNICODE and substitute the result for regex .	regex = re . compile ( regex , re . UNICODE )
7252	substitute regex for self._regex .	self . _regex = regex
7253	if self has an STR0 attribute and self._regex_validator is contained in self.validators ,	if hasattr ( self , STR0 ) and self . _regex_validator in self . validators :
7254	remove self._regex_validator from self.validators .	self . validators . remove ( self . _regex_validator )
7255	call the method validators.RegexValidator with an argument regex set to regex , substitute it for self._regex_validator .	self . _regex_validator = validators . RegexValidator ( regex = regex )
7256	append self._regex_validator to self.validators .	self . validators . append ( self . _regex_validator )
7257	regex is an property object of this class , with _get_regex getter and _set_regex setter function .	regex = property ( _get_regex , _set_regex )
7258	derive the class EmailField from the base class CharField class .	class EmailField ( CharField ) :
7259	substitute EmailInput for widget .	widget = EmailInput
7260	default_validators is a list with an element validators.validate_email .	default_validators = [ validators . validate_email ]
7261	define the method clean with 2 arguments self and value .	def clean ( self , value ) :
7262	call the method self.to_python with an argument value , strip the whitespaces from the both ends of the result and substitute it for value .	value = self . to_python ( value ) . strip ( )
7263	call the method clean with an argument value from the base class of the EmailField class .	return super ( EmailField , self ) . clean ( value )
7264	derive the class FileField from the base class Field class .	class FileField ( Field ) :
7265	substitute ClearableFileInput for widget .	widget = ClearableFileInput
7266	default_error_messages is an dictionary with 5 initial entries : return value of the function _ called with an argument string , STR0 for STR3 , return value of the function _ called with an argument , string STR1 for STR4 , return value of the function _ called with an argument STR2 , for STR5 , return value of the function ungettext_lazy called with 3 arguments : string STR6 , string STR7 and string STR8 for STR9 , and return value of the function _ called with an argument string , STR10 for STR11 .	default_error_messages = { STR3 : _ ( STR0 ) , STR4 : _ ( STR1 ) , STR5 : _ ( STR2 ) , STR6 : ungettext_lazy ( STR7 , STR8 , STR9 ) , STR10 : _ ( STR11 ) }
7267	define the method __init__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , * args , ** kwargs ) :
7268	remove the value under STR0 key from the kwargs dictionary and if the key exists substitute it for self.max_length , if not self.max_length is None .	self . max_length = kwargs . pop ( STR0 , None )
7269	remove the value under STR0 key from the kwargs dictionary and if the key exists , substitute it for self.allow_empty_file , if not self.allow_empty_file is boolean False .	self . allow_empty_file = kwargs . pop ( STR0 , False )
7270	call the method __init__ from the base class of the FileField class , with 2 arguments : unpacked list args and unpacked dictionary .	super ( FileField , self ) . __init__ ( * args , ** kwargs )
7271	define the method to_python with arguments self and data .	def to_python ( self , data ) :
7272	if data in self.empty_values is true ,	if data in self . empty_values :
7273	return None .	return None
7274	try ,	try :
7275	substitute data.name for file_name .	file_name = data . name
7276	substitute data.size for file_name .	file_size = data . size
7277	if AttributeError exception is caught ,	except AttributeError :
7278	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7279	if self.max_length is not None and length of file_name is grater than self.max_length ,	if self . max_length is not None and len ( file_name ) > self . max_length :
7280	params is a dictionary with 2 initial entries : self.max_length for STR0 and length of file_name for STR1 .	params = { STR0 : self . max_length , STR1 : len ( file_name ) }
7281	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 , params = params )
7282	if file_name is false ,	if not file_name :
7283	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7284	if self.allow_empty_file and file_size are both false ,	if not self . allow_empty_file and not file_size :
7285	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7286	return data .	return data
7287	define the method clean with arguments self , data and initial set to None .	def clean ( self , data , initial = None ) :
7288	if data is bound to the same object as FILE_INPUT_CONTRADICTION ,	if data is FILE_INPUT_CONTRADICTION :
7289	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7290	if data is boolean False ,	if data is False :
7291	if self.required is false ,	if not self . required :
7292	return boolean False .	return False
7293	data is None .	data = None
7294	if data is false and initial is true ,	if not data and initial :
7295	return initial .	return initial
7296	call the method clean with an argument data from the base class of the class FileField , return the result .	return super ( FileField , self ) . clean ( data )
7297	define the method bound_data with arguments self , data and initial .	def bound_data ( self , data , initial ) :
7298	if data is not None or FILE_INPUT_CONTRADICTION ,	if data in ( None , FILE_INPUT_CONTRADICTION ) :
7299	return initial .	return initial
7300	return data .	return data
7301	define the method _has_changed with arguments self , data and initial .	def _has_changed ( self , initial , data ) :
7302	if data is None ,	if data is None :
7303	return is boolean False .	return False
7304	return is boolean True .	return True
7305	derive the class ImageField from the base class FileField class .	class ImageField ( FileField ) :
7306	default_error_messages is an dictionary with an entry : return value of the function _ called with an argument string , STR1 for STR2 .	default_error_messages = { STR1 : _ ( STR0 ) , }
7307	define the method to_python with arguments self and data .	def to_python ( self , data ) :
7308	call the method to_python with an argument data from the base class of the class ImageField , substitute the result for f .	f = super ( ImageField , self ) . to_python ( data )
7309	if f is None ,	if f is None :
7310	return None .	return None
7311	from PIL import Image into default namespace .	from PIL import Image
7312	if data has an STR0 attribute ,	if hasattr ( data , STR0 ) :
7313	substitute the result of the function data.temporary_file_path for file .	file = data . temporary_file_path ( )
7314	if not ,	else :
7315	if data has an attribute STR0 ,	if hasattr ( data , STR0 ) :
7316	file is an instance of BytesIO class created with an argument : return value of the method data.read .	file = BytesIO ( data . read ( ) )
7317	if not ,	else :
7318	file is an instance of BytesIO class created with an argument : value under the STR0 key of the data dictionary .	file = BytesIO ( data [ STR0 ] )
7319	try ,	try :
7320	call the method Image.open with an argument file , on the result call the verify method	Image . open ( file ) . verify ( )
7321	if Exception exception is caught ,	except Exception :
7322	call the function six.reraise with 3 arguments : ValidationError , ValidationError created with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to a string STR1 , and third element of the return value of the function sys.exc_info .	six . reraise ( ValidationError , ValidationError ( self . error_messages [ STR0 ] , code = STR1 , ) , sys . exc_info ( ) [ 2 ] )
7323	if f has an attribute STR0 and if f.seek is an callable object ,	if hasattr ( f , STR0 ) and callable ( f . seek ) :
7324	call the method f.seek with an argument integer 0 .	f . seek ( 0 )
7325	return f .	return f
7326	derive the class URLField from the base class CharField class .	class URLField ( CharField ) :
7327	substitute URLInput for widget .	widget = URLInput
7328	default_error_messages is an dictionary with an entry : return value of the function _ called with an argument string STR0 for STR1 .	default_error_messages = { STR0 : _ ( STR1 ) , }
7329	default_validators is a list with an element , return value of the validators.URLValidator method .	default_validators = [ validators . URLValidator ( ) ]
7330	define the method to_python with arguments self and data .	def to_python ( self , value ) :
7331	define the function split_url with an argument url .	def split_url ( url ) :
7332	try ,	try :
7333	call the urlsplit with an argument url , convert the result into a list and return it .	return list ( urlsplit ( url ) )
7334	if ValueError exception is caught ,	except ValueError :
7335	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7336	call the method to_python with an argument data from the base class of the class URLField , substitute the result for value .	value = super ( URLField , self ) . to_python ( value )
7337	if value is true ,	if value :
7338	call the function split_url with an argument value , substitute the result for url_fields .	url_fields = split_url ( value )
7339	if first element of the url_fields is false ,	if not url_fields [ 0 ] :
7340	first element of url_fields is string STR0 .	url_fields [ 0 ] = STR0
7341	if second element of url_fields is false ,	if not url_fields [ 1 ] :
7342	substitute third element of url_fields for second element of url_fields .	url_fields [ 1 ] = url_fields [ 2 ]
7343	third element of url_fields is an empty string .	url_fields [ 2 ] = STR
7344	call the function urlunsplit with an argument url_fields , use the result as an argument for the call to the function split_url , substitute the result for url_fields .	url_fields = split_url ( urlunsplit ( url_fields ) )
7345	call the function urlunsplit with an argument url_fields , substitute the result for value .	value = urlunsplit ( url_fields )
7346	return value .	return value
7347	define the method clean with arguments self and value .	def clean ( self , value ) :
7348	call the method self.to_python with an argument value , strip the whitespaces from the result , substitute it for value .	value = self . to_python ( value ) . strip ( )
7349	call the method clean with an argument data from the base class of the class URLField , return the result .	return super ( URLField , self ) . clean ( value )
7350	derive the class BooleanField from the base class Field class .	class BooleanField ( Field ) :
7351	substitute CheckboxInput for widget .	widget = CheckboxInput
7352	define the method to_python with arguments self and value .	def to_python ( self , value ) :
7353	if value is an instance of six.string_types and value converted to lowercase is not equal to strings STR0 or STR1 ,	if isinstance ( value , six . string_types ) and value . lower ( ) in ( STR0 , STR1 ) :
7354	value is boolean False .	value = False
7355	if not ,	else :
7356	convert value into boolean and substitute it for value .	value = bool ( value )
7357	call the method to_python with an argument data from the base class of the class BooleanField , return the result .	return super ( BooleanField , self ) . to_python ( value )
7358	define the method validate with arguments self and value .	def validate ( self , value ) :
7359	if value is false and self.required is true ,	if not value and self . required :
7360	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7361	define the method _has_changed with arguments self , initial and data .	def _has_changed ( self , initial , data ) :
7362	if initial equals a string STR0 ,	if initial == STR0 :
7363	initial is boolean False .	initial = False
7364	convert initial and data into boolean , if they are not equal return boolean True , if they are return boolean False .	return bool ( initial ) != bool ( data )
7365	derive the class NullBooleanField from the base class BooleanField class .	class NullBooleanField ( BooleanField ) :
7366	substitute NullBooleanSelect for widget .	widget = NullBooleanSelect
7367	define the method to_python with arguments self and value .	def to_python ( self , value ) :
7368	if value is boolean True , string STR0 or string STR1 ,	if value in ( True , STR0 , STR1 ) :
7369	return boolean True .	return True
7370	otherwise if value is boolean False , string STR0 or string STR1	elif value in ( False , STR0 , STR1 ) :
7371	return boolean False ,	return False
7372	if not ,	else :
7373	return None .	return None
7374	define the method validate with arguments self and value .	def validate ( self , value ) :
7375	do nothing .	pass
7376	define the method _has_changed with arguments self , initial and data .	def _has_changed ( self , initial , data ) :
7377	if initial is not None ,	if initial is not None :
7378	convert initial into boolean and substitute it for initial .	initial = bool ( initial )
7379	if data is not None ,	if data is not None :
7380	convert data into boolean and substitute it for data .	data = bool ( data )
7381	if initial is not equal to data , return boolean True , if it is return boolean False .	return initial != data
7382	derive the class ChoiceField from the base class Field class .	class ChoiceField ( Field ) :
7383	substitute Select for widget .	widget = Select
7384	default_error_messages is an dictionary with an entry : return value of the function _ called with an argument string , STR0 for STR1 .	default_error_messages = { STR0 : _ ( STR1 ) , }
7385	define the method __init__ with 9 arguments : self , choices set to an empty tuple , required set to boolean True , widget set to None , label set to None , initial set to None , help_text set to an empty string , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , choices = ( ) , required = True , widget = None , label = None , initial = None , help_text = STR , * args , ** kwargs ) :
7386	call the __init__ method of the base class of the class ChoiceField , called with 7 arguments : required set to required , widget set to widget , label set to label , initial set to initial , help_text set to help_text , unpacked list args , and unpacked dictionary kwargs .	super ( ChoiceField , self ) . __init__ ( required = required , widget = widget , label = label , initial = initial , help_text = help_text , * args , ** kwargs )
7387	substitute choices for self.choices .	self . choices = choices
7388	define the method __deepcopy__ with arguments self and memo .	def __deepcopy__ ( self , memo ) :
7389	call the method __deepcopy__ with an argument memo from the base class of the class ChoiceField , substitute the result for result .	result = super ( ChoiceField , self ) . __deepcopy__ ( memo )
7390	call the method copy.deepcopy with arguments self._choices and memo , substitute the result for result._choices .	result . _choices = copy . deepcopy ( self . _choices , memo )
7391	return result .	return result
7392	define the method _get_choices with an argument self .	def _get_choices ( self ) :
7393	return self._choices .	return self . _choices
7394	define the method _set_choices with arguments self and value .	def _set_choices ( self , value ) :
7395	self._choices and self.widget.choices are assigned value converted into a list .	self . _choices = self . widget . choices = list ( value )
7396	choices is an property object of this class where _get_choices is a getter and _set_choices is a setter function .	choices = property ( _get_choices , _set_choices )
7397	define the method to_python with arguments self and value .	def to_python ( self , value ) :
7398	if value is contained in self.empty_values ,	if value in self . empty_values :
7399	return an empty string .	return STR
7400	call the function smart_text with an argument value , return the result .	return smart_text ( value )
7401	define the method validate with arguments self and value .	def validate ( self , value ) :
7402	call the method validate with an argument value from the base class of the class ChoiceField .	super ( ChoiceField , self ) . validate ( value )
7403	if value is true and method self.valid_value called with an argument value evaluates to false ,	if value and not self . valid_value ( value ) :
7404	raise an ValidationError with 3 arguments : value under the STR0 key of the self.error_messages dictionary , code set to an string STR1 and dictionary params with an entry : value for STR2 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 , params = { STR2 : value } , )
7405	define the method valid_value with arguments self and value .	def valid_value ( self , value ) :
7406	call the function force_text with an argument value , substitute the result for text_value .	text_value = force_text ( value )
7407	for every k and v in self.choices ,	for k , v in self . choices :
7408	if v is an instance of list or tuple type ,	if isinstance ( v , ( list , tuple ) ) :
7409	for every k2 and v2 in v ,	for k2 , v2 in v :
7410	if value equals k2 or text_value equals return value of the function force_text called with argument k2 ,	if value == k2 or text_value == force_text ( k2 ) :
7411	return boolean True .	return True
7412	if not ,	else :
7413	if value equals k or text_value equals return value of the function force_text called with argument k ,	if value == k or text_value == force_text ( k ) :
7414	return boolean True .	return True
7415	return boolean False .	return False
7416	derive the class TypedChoiceField from the base class ChoiceField class .	class TypedChoiceField ( ChoiceField ) :
7417	define the method __init__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , * args , ** kwargs ) :
7418	if STR0 key of the kwargs dictionary exists remove it and substitute its value for self.coerce ,	self . coerce = kwargs . pop ( STR0 , lambda val : val )
7419	if not , self.coerce is an identity lambda function with an argument val . if STR0 key of the kwargs dictionary exists remove it and substitute its value for self.empty_value , if not , sself.empty_value is an empty string .	self . empty_value = kwargs . pop ( STR0 , STR )
7420	call the method __init__ with 2 arguments : unpacked list args and unpacked dictionary kwargs , from the base class of the class TypedChoiceField .	super ( TypedChoiceField , self ) . __init__ ( * args , ** kwargs )
7421	define the method _coerce with arguments self and value .	def _coerce ( self , value ) :
7422	if value equals self.empty_value or value is contained in self.empty_values ,	if value == self . empty_value or value in self . empty_values :
7423	return self.empty_value .	return self . empty_value
7424	try ,	try :
7425	call the function self.coerce with an argument value , substitute it for value .	value = self . coerce ( value )
7426	if ValueError , TypeError or ValidationError exception is caught ,	except ( ValueError , TypeError , ValidationError ) :
7427	raise an ValidationError with 3 arguments : value under the STR0 key of the self.error_messages dictionary , code set to an string STR1 and dictionary params with an entry : value for STR2 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 , params = { STR2 : value } , )
7428	return value .	return value
7429	define the method clean with arguments self and value .	def clean ( self , value ) :
7430	call the method clean with an argument value from the base class of the class TypedChoiceField , substitute the result for value .	value = super ( TypedChoiceField , self ) . clean ( value )
7431	call the method self._coerce with an argument value , return the result .	return self . _coerce ( value )
7432	derive the class MultipleChoiceField from the base class ChoiceField class .	class MultipleChoiceField ( ChoiceField ) :
7433	substitute MultipleHiddenInput for hidden_widget .	hidden_widget = MultipleHiddenInput
7434	substitute SelectMultiple for widget .	widget = SelectMultiple
7435	default_error_messages is an dictionary with an entry : return value of the function _ called with an argument string , STR0 for STR1 , and return value of the function _ called with an argument string STR2 for STR3 .	default_error_messages = { STR0 : _ ( STR1 ) , STR2 : _ ( STR3 ) , }
7436	define the method to_python with arguments self and value .	def to_python ( self , value ) :
7437	if value is false ,	if not value :
7438	return an empty list .	return [ ]
7439	otherwise if value is not an instance of list ot tuple type ,	elif not isinstance ( value , ( list , tuple ) ) :
7440	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7441	for every val in value call the function smart_text with an argument val , return the results in a lit .	return [ smart_text ( val ) for val in value ]
7442	define the method validate with arguments self and value .	def validate ( self , value ) :
7443	if self.required is true and value is false ,	if self . required and not value :
7444	raise an ValidationError with 3 arguments : value under the STR0 key of the self.error_messages dictionary , and code set to an string STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7445	for every val in value ,	for val in value :
7446	call the method self.valid_value with an argument val , if it evaluates to false ,	if not self . valid_value ( val ) :
7447	raise an ValidationError with 3 arguments : value under the STR0 key of the self.error_messages dictionary , code set to an string STR1 and dictionary params with an entry : val for STR2 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 , params = { STR2 : val } , )
7448	define the method _has_changed with arguments self , initial and data .	def _has_changed ( self , initial , data ) :
7449	if initial is None ,	if initial is None :
7450	initial is an empty list .	initial = [ ]
7451	if data is None ,	if data is None :
7452	data is an empty list .	data = [ ]
7453	if lengths of initial and data are not the same ,	if len ( initial ) != len ( data ) :
7454	return boolean True .	return True
7455	for every value in initial call the function force_text with an argument value , add the results into a set , substitute the resulting set for initial_set .	initial_set = set ( force_text ( value ) for value in initial )
7456	for every value in data call the function force_text with an argument value , add the results into a set , substitute the resulting set for data_set .	data_set = set ( force_text ( value ) for value in data )
7457	if data_set is not equal to initial_set , return boolean True , otherwise return boolean False .	return data_set != initial_set
7458	derive the class TypedMultipleChoiceField from the base class MultipleChoiceField class .	class TypedMultipleChoiceField ( MultipleChoiceField ) :
7459	define the method __init__ with 3 arguments : self unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , * args , ** kwargs ) :
7460	if STR0 key of the kwargs dictionary exists remove it and substitute its value for self.coerce , if not , self.coerce is an identity lambda function with an argument val .	self . coerce = kwargs . pop ( STR0 , lambda val : val )
7461	if STR0 key of the kwargs dictionary exists remove it and substitute its value for self.empty_value , if not , self.empty_value is an empty list .	self . empty_value = kwargs . pop ( STR0 , [ ] )
7462	call the method __init__ with 2 arguments : unpacked list args and unpacked dictionary kwargs , from the base class of the class TypedMultipleChoiceField .	super ( TypedMultipleChoiceField , self ) . __init__ ( * args , ** kwargs )
7463	define the method _coerce with arguments self and value .	def _coerce ( self , value ) :
7464	if value equals self.empty_value or value is contained in self.empty_values ,	if value == self . empty_value or value in self . empty_values :
7465	return self.empty_value .	return self . empty_value
7466	new_value is an empty list .	new_value = [ ]
7467	for every choice in value ,	for choice in value :
7468	try ,	try :
7469	call the method self.coerce with an argument choice , append the result to new_value .	new_value . append ( self . coerce ( choice ) )
7470	if ValueError , TypeError or ValidationError exception is caught ,	except ( ValueError , TypeError , ValidationError ) :
7471	raise an ValidationError with 3 arguments : value under the STR0 key of the self.error_messages dictionary , code set to an string STR1 and dictionary params with an entry : choice for STR2 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 , params = { STR2 : choice } , )
7472	return new_value .	return new_value
7473	define the method clean with arguments self and value .	def clean ( self , value ) :
7474	call the method clean with an argument value from the base class of the class TypedMultipleChoiceField , substitute the result for value .	value = super ( TypedMultipleChoiceField , self ) . clean ( value )
7475	call the method self._coerce with an argument value , return the result .	return self . _coerce ( value )
7476	define the method validate with arguments self and value .	def validate ( self , value ) :
7477	if value is not equal self.empty_value ,	if value != self . empty_value :
7478	call the method validate with an argument value from the base class of the class TypedMultipleChoiceField .	super ( TypedMultipleChoiceField , self ) . validate ( value )
7479	otherwise if self.required is true ,	elif self . required :
7480	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7481	derive the class ComboField from the base class Field class .	class ComboField ( Field ) :
7482	define the method __init__ with arguments : self , fields set to an empty tuple , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , fields = ( ) , * args , ** kwargs ) :
7483	call the method __init__ with 2 arguments : unpacked list args and unpacked dictionary kwargs , from the base class of the class ComboField .	super ( ComboField , self ) . __init__ ( * args , ** kwargs )
7484	for every f in fields ,	for f in fields :
7485	f.required is boolean False .	f . required = False
7486	substitute fields for self.fields .	self . fields = fields
7487	define the method clean with arguments self and value .	def clean ( self , value ) :
7488	call the method clean with an argument value from the base class of the class ComboField .	super ( ComboField , self ) . clean ( value )
7489	for every field in self.fields ,	for field in self . fields :
7490	call the method field.clean with an argument value , substitute the result for value .	value = field . clean ( value )
7491	return value .	return value
7492	derive the class MultiValueField from the base class Field class .	class MultiValueField ( Field ) :
7493	default_error_messages is an dictionary with 2 entries : return value of the function _ called with an argument string , STR0 for STR1 and return value of the function _ called with an argument string , STR2 for STR3 .	default_error_messages = { STR0 : _ ( STR1 ) , STR2 : _ ( STR3 ) , }
7494	define the method __init__ with arguments self , fields set to an empty ilst , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , fields = ( ) , * args , ** kwargs ) :
7495	if STR0 key of the kwargs dictionary exists remove it and substitute its value for self.require_all_fields , if not , self.require_all_fields is boolean True .	self . require_all_fields = kwargs . pop ( STR0 , True )
7496	call the method __init__ with 2 arguments : unpacked list args and unpacked dictionary kwargs , from the base class of the class MultiValueField .	super ( MultiValueField , self ) . __init__ ( * args , ** kwargs )
7497	for every f in fields ,	for f in fields :
7498	if STR0 key of the f.error_messages doesnt exists , assign it the value under the STR1 key of the self.error_messages dictionary .	f . error_messages . setdefault ( STR0 , self . error_messages [ STR1 ] )
7499	if self.require_all_fields is true ,	if self . require_all_fields :
7500	f.required is boolean False .	f . required = False
7501	substitute fields for self.fields .	self . fields = fields
7502	define the method __deepcopy__ with arguments self and memo .	def __deepcopy__ ( self , memo ) :
7503	call the method __deepcopy__ with an argument memo , from the base class of the class MultiValueField , substitute the result for result .	result = super ( MultiValueField , self ) . __deepcopy__ ( memo )
7504	for every x in self.fields call the method x.__deepcopy__ with an argument memo , put the result into a tuple , substitute it for result.fields .	result . fields = tuple ( [ x . __deepcopy__ ( memo ) for x in self . fields ] )
7505	return result .	return result
7506	define the method validate with arguments self and value .	def validate ( self , value ) :
7507	do nothing .	pass
7508	define the method clean with arguments self and value .	def clean ( self , value ) :
7509	clean_data is an empty list .	clean_data = [ ]
7510	errors is an empty list .	errors = [ ]
7511	if value is false or value is not an instance of list or tuple types ,	if not value or isinstance ( value , ( list , tuple ) ) :
7512	if value is false or for every v in value every v is contained in self.empty_values ,	if not value or not [ v for v in value if v not in self . empty_values ] :
7513	if self.required is true ,	if self . required :
7514	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7515	if not ,	else :
7516	call the function self.compress with empty list as an argument , return the result .	return self . compress ( [ ] )
7517	if not ,	else :
7518	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7519	for every i and field in enumerated iterable self.fields ,	for i , field in enumerate ( self . fields ) :
7520	try ,	try :
7521	substitute i-th element of value for field_value .	field_value = value [ i ]
7522	if IndexError exception is caught ,	except IndexError :
7523	field_value is None .	field_value = None
7524	if field_value is cotained in self.empty_values ,	if field_value in self . empty_values :
7525	if self.require_all_fields is boolean true ,	if self . require_all_fields :
7526	if self.required is boolean true ,	if self . required :
7527	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7528	otherwise if field.required is true ,	elif field . required :
7529	get the value under the STR0 key of the field.error_messages dictionary , if it is not contained in errors ,	if field . error_messages [ STR0 ] not in errors :
7530	get the value under the STR0 key of the field.error_messages dictionary , append it to errors .	errors . append ( field . error_messages [ STR0 ] )
7531	skip this loop iteration ,	continue
7532	try ,	try :
7533	call the method field.clean with an argument field_value , append the result to clean_data .	clean_data . append ( field . clean ( field_value ) )
7534	if ValidationError , renamed to e , is caught ,	except ValidationError as e :
7535	extend errors list with m for every m in e.error_list , only if m is not in errors .	errors . extend ( m for m in e . error_list if m not in errors )
7536	if errors is true ,	if errors :
7537	raise an ValidationError with an argument errors .	raise ValidationError ( errors )
7538	call the method self.compress with an argument clean_data , substitute the result for out .	out = self . compress ( clean_data )
7539	call the method self.validate with an argument out .	self . validate ( out )
7540	call the method self.run_validators with an argument out .	self . run_validators ( out )
7541	return out .	return out
7542	define the method compress with arguments self and data_list .	def compress ( self , data_list ) :
7543	raise an NotImplementedError with an argument string STR0 .	raise NotImplementedError ( STR0 )
7544	define the method has_changed with arguments self , initial and data .	def _has_changed ( self , initial , data ) :
7545	if initial is None ,	if initial is None :
7546	for every x in sequence of integer from integer 0 to length of data , append an empty string to a list , substitute the resulting list for initial .	initial = [ STR for x in range ( 0 , len ( data ) ) ]
7547	if not ,	else :
7548	if initial is not an instance of the list type ,	if not isinstance ( initial , list ) :
7549	call the method self.widget.decompress with an argument initial , substitute the result for initial .	initial = self . widget . decompress ( initial )
7550	for every field , initial and data in list of tuples tuple containing elements of self.fields , initial and data , respectively ,	for field , initial , data in zip ( self . fields , initial , data ) :
7551	call the method field._has_changed with 2 arguments : return value of the function field.to_python called with an argument initial ,	if field . _has_changed ( field . to_python ( initial ) , data ) :
7552	and data , if it evaluates to true , return boolean True .	return True
7553	return boolean False .	return False
7554	derive the class FilePathField from the base class ChoiceField class .	class FilePathField ( ChoiceField ) :
7555	define the method __init__ with 13 arguments : self , path , match set to None , recursive set to boolean False , allow_files set to boolean True , allow_folders set to boolean False , required set to boolean True , widget set to None , label set to None , initial set to None , help_text set to an empty string , unpacked list args , unpacked dictionary kwargs .	def __init__ ( self , path , match = None , recursive = False , allow_files = True , allow_folders = False , required = True , widget = None , label = None , initial = None , help_text = STR , * args , ** kwargs ) :
7556	substitute path , match and recursive for self.path , self.match and self.recursive .	self . path , self . match , self . recursive = path , match , recursive
7557	substitute allow_files and allow_folders for self.allow_files and self.allow_folders .	self . allow_files , self . allow_folders = allow_files , allow_folders
7558	call the __init__ method of the base class of the class FilePathField , with arguments : choices set to an empty tuple,4 required set to required , widget set to widget , label set to label , initial st to initial , help_text set to help_text , unpacked list args , unpacked dictionary kwargs .	super ( FilePathField , self ) . __init__ ( choices = ( ) , required = required , widget = widget , label = label , initial = initial , help_text = help_text , * args , ** kwargs )
7559	if self.required is true ,	if self . required :
7560	self.choices is an empty list .	self . choices = [ ]
7561	if not ,	else :
7562	self.choices is an list containing an tuple with 2 elements : an empty string and string STR0 .	self . choices = [ ( STR , STR0 ) ]
7563	if self.match is not None ,	if self . match is not None :
7564	compile self.match regular expression , substitute it for self.match_re .	self . match_re = re . compile ( self . match )
7565	if recursive is true ,	if recursive :
7566	for root , dirs and files in sorted list of the directory tree starting from the directory self.path ,	for root , dirs , files in sorted ( os . walk ( self . path ) ) :
7567	if self.allow_files is true ,	if self . allow_files :
7568	for every f in files ,	for f in files :
7569	if self.match is None or call to the method self.match_re.search with an argument f , evaluated to true ,	if self . match is None or self . match_re . search ( f ) :
7570	join root and f into a file , substitute it for f .	f = os . path . join ( root , f )
7571	append a tuple with 2 elements : f and f with first occurrence of the path replaced with an empty string , to self.choices .	self . choices . append ( ( f , f . replace ( path , STR , 1 ) ) )
7572	if self.allow_folders is true ,	if self . allow_folders :
7573	for every f in files ,	for f in dirs :
7574	if f equals to string STR0 ,	if f == STR0 :
7575	skip this loop execution .	continue
7576	if self.match is None or call to the method self.match_re.search with an argument f , evaluated to true ,	if self . match is None or self . match_re . search ( f ) :
7577	join root and f in path , substitute the result for f .	f = os . path . join ( root , f )
7578	append a tuple with 2 elements : f and f with first occurrence of the path replaced with an empty string , to self.choices .	self . choices . append ( ( f , f . replace ( path , STR , 1 ) ) )
7579	if not ,	else :
7580	try ,	try :
7581	for f in sorted list of the files in the self.path directory ,	for f in sorted ( os . listdir ( self . path ) ) :
7582	if f equals to string STR0 ,	if f == STR0 :
7583	skip this loop execution .	continue
7584	join self.path and f in path , substitute the result for full_file .	full_file = os . path . join ( self . path , f )
7585	if self.allow_files is true and full_file is a file , or if self.allow_folders is true and full_file is an directory , and only if self.match is None or return value of the method self.match_re.search called with an argument f is true .	if ( ( ( self . allow_files and os . path . isfile ( full_file ) ) or ( self . allow_folders and os . path . isdir ( full_file ) ) ) and ( self . match is None or self . match_re . search ( f ) ) ) :
7586	append a tuple containing 2 elements : full_file and f to self.choices list .	self . choices . append ( ( full_file , f ) )
7587	if OSError exception is caught ,	except OSError :
7588	do nothing .	pass
7589	substitute self.choices for self.widgetchoices .	self . widget . choices = self . choices
7590	derive the class SplitDateTimeField from the base class MultiValueField class .	class SplitDateTimeField ( MultiValueField ) :
7591	substitute SplitDateTimeWidget for widget .	widget = SplitDateTimeWidget
7592	substitute SplitHiddenDateTimeWidget for hidden_widget .	hidden_widget = SplitHiddenDateTimeWidget
7593	default_error_messages is an dictionary with 2 entries : return value of the function _ called with an string STR0 , for STR1 and return value of the function _ called with an string STR2 , for 'invalid_time .	default_error_messages = { STR0 : _ ( STR1 ) , STR2 : _ ( STR3 ) , }
7594	define the method __init__ with 3 arguments : self , input_date_formats set to None , input_time_formats set to None ,	def __init__ ( self , input_date_formats = None , input_time_formats = None , * args , ** kwargs ) :
7595	and errors set to the result of self.default_error_messages.copy .	errors = self . default_error_messages . copy ( )
7596	if STR0 is contained in kwargs ,	if STR0 in kwargs :
7597	get the value under the STR0 key of the kwargs dictionary , update errors dictionary with it .	errors . update ( kwargs [ STR0 ] )
7598	get the value under the STR0 key of the kwargs dictionary , substitute it for localize , if the key doesnt exists , substitute the result for localize .	localize = kwargs . get ( STR0 , False )
7599	fields is an tuple containing instances of the class DateField , created with 3 arguments : input_formats set to input_date_formats ,	fields = ( DateField ( input_formats = input_date_formats , error_messages = { STR0 : errors [ STR1 ] } , localize = localize ) , TimeField ( input_formats = input_time_formats , error_messages = { STR2 : errors [ STR3 ] } , localize = localize ) , )
7600	error_messages as an dictionary with an entry : value under the STR0 of errors dictionary for STR1 , localize set to localize , and an instance of the class TimeField created with 3 arguments : input_formats set to input_time_formats , error_messages as an dictionary with an entry : value under the STR2 of errors dictionary for STR3 , localize set to localize call the __init__ method with fields , unpacked list args and unpacked dictionary kwargs from the base class of the SplitDateTimeField class .	super ( SplitDateTimeField , self ) . __init__ ( fields , * args , ** kwargs )
7601	define the method compress with arguments self and data_list .	def compress ( self , data_list ) :
7602	if data_list is true ,	if data_list :
7603	if first element of data_list is contained in self.empty_values ,	if data_list [ 0 ] in self . empty_values :
7604	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to string STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7605	if second element of data_list is contained in self.empty_values ,	if data_list [ 1 ] in self . empty_values :
7606	raise an ValidationError with 2 arguments : value under the STR0 key of the self.error_messages dictionary and code set to string STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
7607	call the method datetime.datetime.combine with unpacked list data_list , substitute the result for result .	result = datetime . datetime . combine ( * data_list )
7608	call the method from_current_timezone with an argument result , return the result .	return from_current_timezone ( result )
7609	return None .	return None
7610	derive the class IPAddressField from the base class CharField class .	class IPAddressField ( CharField ) :
7611	default_validators is an list containing validators.validate_ipv4_address .	default_validators = [ validators . validate_ipv4_address ]
7612	define the method __init__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , * args , ** kwargs ) :
7613	call the function warnings.warn with 2 arguments string STR0 , and RemovedInDjango19Warning .	warnings . warn ( STR0 , RemovedInDjango19Warning )
7614	call the __init__ method with unpacked list args and unpacked dictionary kwargs from the base class of the IPAddressField class .	super ( IPAddressField , self ) . __init__ ( * args , ** kwargs )
7615	define the method to_python with arguments self and value .	def to_python ( self , value ) :
7616	if value is contained in self.empty_values ,	if value in self . empty_values :
7617	return an empty string .	return STR
7618	strip whitespaces from both sides of the value , return the result .	return value . strip ( )
7619	derive the class GenericIPAddressField from the base class CharField class .	class GenericIPAddressField ( CharField ) :
7620	define the method __init__ with 5 arguments : self , protocol set to string STR0 , unpack_ipv4 set to boolean False , unpacked list args , unpacked dictionary kwargs .	def __init__ ( self , protocol = STR0 , unpack_ipv4 = False , * args , ** kwargs ) :
7621	substitute unpack_ipv4 for self.unpack_ipv4 .	self . unpack_ipv4 = unpack_ipv4
7622	call the method validators.ip_address_validators with arguments protocol , unpack_ipv4 , substitute first element of the result for self.default_validators .	self . default_validators = validators . ip_address_validators ( protocol , unpack_ipv4 ) [ 0 ]
7623	call the __init__ method with unpacked list args and unpacked dictionary kwargs from the base class of the GenericIPAddressField class .	super ( GenericIPAddressField , self ) . __init__ ( * args , ** kwargs )
7624	define the method to_python with arguments self and value .	def to_python ( self , value ) :
7625	if value is contained in self.empty_values ,	if value in self . empty_values :
7626	return an empty string .	return STR
7627	strip whitespaces from both sides of the value , substitute it for value .	value = value . strip ( )
7628	if value is true and character STR0 is contained in value ,	if value and STR0 in value :
7629	call the function clean_ipv6_address with arguments value and self.unpack_ipv4 , return the result .	return clean_ipv6_address ( value , self . unpack_ipv4 )
7630	return value .	return value
7631	derive the class SlugField from the base class CharField class .	class SlugField ( CharField ) :
7632	default_validators is an list containing validators.validate_slug .	default_validators = [ validators . validate_slug ]
7633	define the method clean with arguments self and value .	def clean ( self , value ) :
7634	call the self.to_python method with an argument value , strip the result of the whitespaces from the sides , substitute the result for value .	value = self . to_python ( value ) . strip ( )
7635	call the clean method wiht value argument from the base class of the SlugField class , return the result .	return super ( SlugField , self ) . clean ( value )
7636	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
7637	from collections import OrderedDict into default name space .	from collections import OrderedDict
7638	import module copy .	import copy
7639	import module datetime .	import datetime
7640	import module warnings .	import warnings
7641	from django.core.exceptions import ValidationError and NON_FIELD_ERRORS into default name space .	from django . core . exceptions import ValidationError , NON_FIELD_ERRORS
7642	from django.forms.fields import Field and FileField into default name space .	from django . forms . fields import Field , FileField
7643	from django.forms.utils import flatatt , ErrorDict and ErrorList into default name space .	from django . forms . utils import flatatt , ErrorDict , ErrorList
7644	from django.forms.widgets import Media , MediaDefiningClass , TextInput and Textarea into default name space .	from django . forms . widgets import Media , MediaDefiningClass , TextInput , Textarea
7645	from django.utils.deprecation import RemovedInDjango19Warning into default name space .	from django . utils . deprecation import RemovedInDjango19Warning
7646	from django.utils.encoding import smart_text , force_text and python_2_unicode_compatible into default name space .	from django . utils . encoding import smart_text , force_text , python_2_unicode_compatible
7647	from django.utils.html import conditional_escape and format_html into default name space .	from django . utils . html import conditional_escape , format_html
7648	from django.utils.safestring import mark_safe into default name space .	from django . utils . safestring import mark_safe
7649	from django.utils.translation import ugettext as _ into default name space .	from django . utils . translation import ugettext as _
7650	from django.utils import six into default name space .	from django . utils import six
7651	__all__is an tuple with 2 elements : strings STR0 and STR1 .	__all__ = ( STR0 , STR1 )
7652	define the function pretty_name with an argument name .	def pretty_name ( name ) :
7653	if name is false ,	if not name :
7654	return an empty string .	return STR
7655	replace all the occurrences of character STR0 in name with a whitespace , capitalize the first letter and return the result .	return name . replace ( STR0 , STR ) . capitalize ( )
7656	define the function get_declared_fields with 3 arguments : bases , attrs and with_base_fields set to boolean True .	def get_declared_fields ( bases , attrs , with_base_fields = True ) :
7657	call the function warnings.warn with 3 arguments : string STR0 , RemovedInDjango19Warning , stacklevel set to integer 2 .	warnings . warn ( STR0 , RemovedInDjango19Warning , stacklevel = 2 , )
7658	for field_name every obj in list created from the elements of the return value of the function six.iteritems with an argument attrs . if obj is an instance of Field , append to a list a tuple with 2 elements : field_name , and poped value under the field_name key of the attrs dictionary , substitute the resulting list for fields .	fields = [ ( field_name , attrs . pop ( field_name ) ) for field_name , obj in list ( six . iteritems ( attrs ) ) if isinstance ( obj , Field ) ]
7659	sort fields elements with key being a lambda function with argument x and return value creation_counter filed of first element of x .	fields . sort ( key = lambda x : x [ 1 ] . creation_counter )
7660	if with_base_fields is true ,	if with_base_fields :
7661	for every base in reversed order of bases ,	for base in bases [ : : - 1 ] :
7662	if base has an attribute STR0 .	if hasattr ( base , STR0 ) :
7663	call the method six.iteritems with an argument base.base_fields , convert it to a list and append fields to it , substitute the result for fields .	fields = list ( six . iteritems ( base . base_fields ) ) + fields
7664	if not ,	else :
7665	for every base in reversed order of bases ,	for base in bases [ : : - 1 ] :
7666	if base has an STR0 attribute ,	if hasattr ( base , STR0 ) :
7667	call the method six.iteritems with an argument base.declared_fields , convert it to a list and append fields to it , substitute the result for fields .	fields = list ( six . iteritems ( base . declared_fields ) ) + fields
7668	return an instance of OrderedDict class , created with an argument fields .	return OrderedDict ( fields )
7669	derive the class DeclarativeFieldsMetaclass from the base class MediaDefiningClass .	class DeclarativeFieldsMetaclass ( MediaDefiningClass ) :
7670	define the method __new__ with 4 arguments : mcs , name , bases and attrs .	def __new__ ( mcs , name , bases , attrs ) :
7671	current_fields is an empty list .	current_fields = [ ]
7672	for every key and value in list created out of the elements of the result of the call to the method attrs.items ,	for key , value in list ( attrs . items ( ) ) :
7673	if value is an instance of Field class ,	if isinstance ( value , Field ) :
7674	append a tuple with elements key and value to current_fields .	current_fields . append ( ( key , value ) )
7675	remove entry at the key key of the attrs dictionary .	attrs . pop ( key )
7676	sort current_fields elements with key being a lambda function with argument x and return value creation_counter filed of first element of x .	current_fields . sort ( key = lambda x : x [ 1 ] . creation_counter )
7677	value under the STR0 key of the attrs dictionary is an instance of OrderedDict class , created with an argument current_fields .	attrs [ STR0 ] = OrderedDict ( current_fields )
7678	call the method __new__ from the base class of the class DeclarativeFieldsMetaclass , with 4 arguments : mcs , name , bases and attrs .	new_class = ( super ( DeclarativeFieldsMetaclass , mcs ) . __new__ ( mcs , name , bases , attrs ) )
7679	declared_fields is an instance of OrderedDict class .	declared_fields = OrderedDict ( )
7680	for every base in new_class.__mro__ in reversed order ,	for base in reversed ( new_class . __mro__ ) :
7681	if base has an attribute STR0 ,	if hasattr ( base , STR0 ) :
7682	update declared_fields dictionary with entry base.declared_fields .	declared_fields . update ( base . declared_fields )
7683	call the method base.__dict__.items , for every attr and value in the result ,	for attr , value in base . __dict__ . items ( ) :
7684	if value is None and attr is contained in declared_fields ,	if value is None and attr in declared_fields :
7685	remove entry at the attr key of the declared_fields dictionary .	declared_fields . pop ( attr )
7686	substitute declared_fields for new_class.base_fields .	new_class . base_fields = declared_fields
7687	substitute declared_fields for new_class.declared_fields .	new_class . declared_fields = declared_fields
7688	return new_class .	return new_class
7689	python_2_unicode_compatible decorator ,	@ python_2_unicode_compatible
7690	derive the class BaseForm from the base class object .	class BaseForm ( object ) :
7691	define the method __init__ with 4 arguments : self , data set to None , files set to None , auto_id is an string STR0 , prefix is None , initial set to None , error_class set to ErrorList , label_suffix set to None , empty_permitted set to boolean False .	def __init__ ( self , data = None , files = None , auto_id = STR0 , prefix = None , initial = None , error_class = ErrorList , label_suffix = None , empty_permitted = False ) :
7692	if data is not None or files is not None , self.is_bound is boolean True , otherwise it is boolean False .	self . is_bound = data is not None or files is not None
7693	if data is true , substitute it for self.data , if not self.data is an empty dictionary .	self . data = data or { }
7694	if files is true , substitute it for self.files , if not self.files is an empty dictionary .	self . files = files or { }
7695	substitute auto_id for self.auto_id .	self . auto_id = auto_id
7696	substitute prefix for self.prefix .	self . prefix = prefix
7697	if initial is true , substitute it for self.initial , if not self.files is an empty dictionary .	self . initial = initial or { }
7698	substitute .error_class for self.error_class .	self . error_class = error_class
7699	if label_suffix is not None substitute label_suffix for self.label_suffix , otherwise substitute return value of the function _ called with an argument STR0 for self.label_suffix .	self . label_suffix = label_suffix if label_suffix is not None else _ ( STR0 )
7700	substitute empty_permitted for self.empty_permitted .	self . empty_permitted = empty_permitted
7701	self._errors is None .	self . _errors = None
7702	self._changed_data is None .	self . _changed_data = None
7703	call the function copy.deepcopy with an argument self.base_fields , substitute the result for self.fields .	self . fields = copy . deepcopy ( self . base_fields )
7704	define the method __str__ with an argument self .	def __str__ ( self ) :
7705	call the method self.as_table , return the result .	return self . as_table ( )
7706	define the method __iter__ with an argument self .	def __iter__ ( self ) :
7707	for every name in self.fields ,	for name in self . fields :
7708	get the value under the name key of the self dictionary , yield it as the return value of the generator .	yield self [ name ]
7709	define the method __getitem__ with 2 arguments : self and name .	def __getitem__ ( self , name ) :
7710	try ,	try :
7711	get the value under the name key of the self.fields dictionary , substitute it for field .	field = self . fields [ name ]
7712	if KeyError exception is caught ,	except KeyError :
7713	raise an KeyError with an argument string STR0 , substitute STR1 with name and self.__class__.__name__ .	raise KeyError ( STR0 % ( name , self . __class__ . __name__ ) )
7714	return an instance of BoundField class , created with arguments self , field and name .	return BoundField ( self , field , name )
7715	property decorator ,	@ property
7716	define the method errors with an argument self .	def errors ( self ) :
7717	if self._errors is None ,	if self . _errors is None :
7718	call the method self.full_clean .	self . full_clean ( )
7719	return self._errors .	return self . _errors
7720	define the method is_valid with an argument self .	def is_valid ( self ) :
7721	if self.is_bound is true and self.errors is false , return boolean True , otherwise return boolean False .	return self . is_bound and not self . errors
7722	define the method add_prefix with 2 arguments : self and field_name .	def add_prefix ( self , field_name ) :
7723	substitute STR0 in string STR1 with self.prefix and field_name and return it , if self.prefix is true , if not return field_name .	return STR0 % ( self . prefix , field_name ) if self . prefix else field_name
7724	define the method add_initial_prefix with 2 arguments : self and field_name .	def add_initial_prefix ( self , field_name ) :
7725	return string STR0 where STR1 is replaced with return value of the self.add_prefix method called with an argument field_name .	return STR0 % self . add_prefix ( field_name )
7726	define the method _html_output with 6 arguments : self , normal_row , error_row , row_ender , help_text_html and errors_on_separate_row .	def _html_output ( self , normal_row , error_row , row_ender , help_text_html , errors_on_separate_row ) :
7727	call the method self.non_field_errors , substitute the result for top_errors .	top_errors = self . non_field_errors ( )
7728	output and hidden_fields are both empty lists .	output , hidden_fields = [ ] , [ ]
7729	call the method self.fields.items , for every name and field in return value ,	for name , field in self . fields . items ( ) :
7730	html_class_attr is an empty string .	html_class_attr = STR
7731	substitute value under the name key for bf .	bf = self [ name ]
7732	call the method self.error_class with an argument list containing results of the function conditional_escape , called with an argument error , for every error in bf.errors , substitute the result for bf_errors .	bf_errors = self . error_class ( [ conditional_escape ( error ) for error in bf . errors ] )
7733	if bf.is_hidden is true ,	if bf . is_hidden :
7734	if bf_errors is true ,	if bf_errors :
7735	call the function _ with an argument string STR0 , where STR1 is replaced with name , and STR2 is replaced with return value of the force_text function called with an argument e , extend the top_errors with the result .	top_errors . extend ( [ _ ( STR0 ) % { STR1 : name , STR2 : force_text ( e ) } for e in bf_errors ] )
7736	call the function six.text_type with an argument bf , append the result to hidden_fields .	hidden_fields . append ( six . text_type ( bf ) )
7737	if not ,	else :
7738	call the method bf.css_classes , substitute the result for css_classes .	css_classes = bf . css_classes ( )
7739	if css_classes is true ,	if css_classes :
7740	replace STR0 from the string STR2 with css_classes , substitute it for html_class_attr .	html_class_attr = STR1 % css_classes
7741	if errors_on_separate_row and bf_errors are both true ,	if errors_on_separate_row and bf_errors :
7742	call the function force_text with an argument bf_errors , format the error_row string with the result , append it to the output .	output . append ( error_row % force_text ( bf_errors ) )
7743	if bf.label is true ,	if bf . label :
7744	call the function force_text with an argument bf.label , use the result as an argument for the call to the function conditional_escape , substitute the result label .	label = conditional_escape ( force_text ( bf . label ) )
7745	call the function bf.label_tag with an argument label , if the result is true substitute it for label , otherwise label is an empty string .	label = bf . label_tag ( label ) or STR
7746	if not ,	else :
7747	label is an empty string .	label = STR
7748	if field.help_text is true ,	if field . help_text :
7749	call the function force_text with an argument field.help_text , format help_text_html with it , substitute the result for help_text .	help_text = help_text_html % force_text ( field . help_text )
7750	if not ,	else :
7751	label is an empty string .	help_text = STR
7752	format string normal_row with an dictionary containing 6 entries : return value of the function force_text with an argument bf_errors , for STR0 , return value of the function force_text with an argument label for STR1 , return value of the function six.text_type , with an argument bf , for STR2 , help_text for help_text , html_class_attr for STR3 and bf.html_name for STR4 .	output . append ( normal_row % { STR0 : force_text ( bf_errors ) , STR1 : force_text ( label ) , STR2 : six . text_type ( bf ) , STR3 : help_text , STR4 : html_class_attr , STR5 : bf . html_name , } )
7753	if top_errors is true ,	if top_errors :
7754	call the function force_text with an argument top_errors , format error_row with it , insert it at the beginning of output .	output . insert ( 0 , error_row % force_text ( top_errors ) )
7755	if hidden_fields is true ,	if hidden_fields :
7756	join hidden_fields elements into a string , without separation , substitute the result for str_hidden .	str_hidden = STR . join ( hidden_fields )
7757	if output is true ,	if output :
7758	substitute last element of output for last_row .	last_row = output [ - 1 ]
7759	if last_row doesnt ends with row_ender ,	if not last_row . endswith ( row_ender ) :
7760	format string normal_row with an dictionary containing 5 entries : an empty string for STR0 , empty string for STR1 , empty string for STR2 , empty string for STR3 and html_class_attr for html_class_attr .	last_row = ( normal_row % { STR0 : STR , STR1 : STR , STR2 : STR , STR3 : STR , STR4 : html_class_attr } )
7761	append last_row to output .	output . append ( last_row )
7762	create list out of last_row elements from the start to the last length of row_ender element , append str_hidden and row_ender to it , substitute the result for last element of output .	output [ - 1 ] = last_row [ : - len ( row_ender ) ] + str_hidden + row_ender
7763	if not ,	else :
7764	append str_hidden to output .	output . append ( str_hidden )
7765	join elements of output into a string with newline as separator , use it as an argument for the call to the function mark_safe , return it .	return mark_safe ( STR0 . join ( output ) )
7766	define the method as_table with an argument self .	def as_table ( self ) :
7767	return the result of the method self._html_output , called with 5 arguments : normal_row to a string , STR2 , error_row set to a a string , STR3 , row_ender set to a string STR4 , help_text_html set to a string , STR5 and errors_on_separate_row set to boolean False .	return self . _html_output ( normal_row = STR2 , error_row = STR3 , row_ender = STR4 , help_text_html = STR5 , errors_on_separate_row = False )
7768	define the method as_ul with an argument self .	def as_ul ( self ) :
7769	return the result of the method self._html_output , called with 5 arguments : normal_row to a string , STR1 , error_row set to a a string STR2 , row_ender set to a string STR3 , help_text_html set to a string , STR4 , and errors_on_separate_row set to boolean False .	return self . _html_output ( normal_row = STR1 , error_row = STR2 , row_ender = STR3 , help_text_html = STR4 , errors_on_separate_row = False )
7770	define the method as_p with an argument self .	def as_p ( self ) :
7771	return the result of the method self._html_output , called with 5 arguments : normal_row to a string , STR1 , error_row set to a a string STR2 , row_ender set to a string STR3 , help_text_html set to a string , < span class= STR0 > % s < /span > ' and errors_on_separate_row set to boolean True .	return self . _html_output ( normal_row = STR1 , error_row = STR2 , row_ender = STR3 , help_text_html = STR4 , errors_on_separate_row = True )
7772	define the method non_field_errors with an argument self .	def non_field_errors ( self ) :
7773	return the result of the method self.errors.get called with 2 arguments : NON_FIELD_ERRORS and return value of the method , self.error_class called with an argument error_class set to string STR0 .	return self . errors . get ( NON_FIELD_ERRORS , self . error_class ( error_class = STR0 ) )
7774	define the method _raw_value with 2 arguments : self and fieldname .	def _raw_value ( self , fieldname ) :
7775	substitute the value under the fieldname key of the self.fields dictionary for field .	field = self . fields [ fieldname ]
7776	call the method self.add_prefix with an argument fieldname , substitute it for prefix .	prefix = self . add_prefix ( fieldname )
7777	return the result of the method field.widget.value_from_datadict called with 3 arguments : self.data , self.files and prefix .	return field . widget . value_from_datadict ( self . data , self . files , prefix )
7778	define the method add_error with 3 arguments : self , field and errors .	def add_error ( self , field , error ) :
7779	if error is not an instance of ValidationError ,	if not isinstance ( error , ValidationError ) :
7780	error is an instance of ValidationError created with an argument error .	error = ValidationError ( error )
7781	if error has an attribute STR0 ,	if hasattr ( error , STR0 ) :
7782	if field is not None ,	if field is not None :
7783	raise an TypeError with an argument string STR0 .	raise TypeError ( STR0 )
7784	if not ,	else :
7785	substitute error.error_dict for error .	error = error . error_dict
7786	if not ,	else :
7787	error is an dictionary with an initial entry error.error_list for filed if true , or NON_FIELD_ERRORS if not .	error = { field or NON_FIELD_ERRORS : error . error_list }
7788	call the method error.items , for every field and error_list in the result ,	for field , error_list in error . items ( ) :
7789	if field is not contained in self.errors ,	if field not in self . errors :
7790	if field is not equal to NON_FIELD_ERRORS and field is not contained in self.fields ,	if field != NON_FIELD_ERRORS and field not in self . fields :
7791	raise an ValueError with an argument string STR0 , with STR1 replaced with self.__class__.__name__ and field , respectively .	raise ValueError ( STR0 % ( self . __class__ . __name__ , field ) )
7792	if field equals NON_FIELD_ERRORS ,	if field == NON_FIELD_ERRORS :
7793	call the method self.error_class with an argument error_class as an string STR0 , substitute the result for value under the field key of the self._errors dictionary .	self . _errors [ field ] = self . error_class ( error_class = STR0 )
7794	if not ,	else :
7795	call the method self.error_class , substitute the result for value under the field key of the self._errors dictionary .	self . _errors [ field ] = self . error_class ( )
7796	extend the value under the field key of the self._errors dictionary with error_list .	self . _errors [ field ] . extend ( error_list )
7797	if field is contained in self.cleaned_data ,	if field in self . cleaned_data :
7798	delete the entry of self.cleaned_data dictionary under the key field .	del self . cleaned_data [ field ]
7799	define the method has_error with 3 arguments : self , field and code set to None .	def has_error ( self , field , code = None ) :
7800	if code is None ,	if code is None :
7801	if field is contained in self.errors return boolean True , if not , return boolean False .	return field in self . errors
7802	if field is contained in self.errors ,	if field in self . errors :
7803	call the method self.errors.as_data , for every error for value under the filed key of the returned dictionary ,	for error in self . errors . as_data ( ) [ field ] :
7804	if error.code equals code ,	if error . code == code :
7805	return boolean True .	return True
7806	return boolean False .	return False
7807	define the method full_clean with an argument self .	def full_clean ( self ) :
7808	self._errors is an instance of ErrorDict .	self . _errors = ErrorDict ( )
7809	if self.is_bound is false ,	if not self . is_bound :
7810	return nothing .	return
7811	self.cleaned_data is an empty dictionary .	self . cleaned_data = { }
7812	if self.empty_permitted is true and call to the method self.has_changed evaluates to false ,	if self . empty_permitted and not self . has_changed ( ) :
7813	return nothing .	return
7814	call the method self._clean_fields .	self . _clean_fields ( )
7815	call the method self._clean_form .	self . _clean_form ( )
7816	call the method self._post_clean .	self . _post_clean ( )
7817	define the method _clean_fields with an argument self .	def _clean_fields ( self ) :
7818	call the method self.fields.items , for every name and field in result ,	for name , field in self . fields . items ( ) :
7819	call the method field.widget.value_from_datadict with 3 arguments : self.data , self.files and return value of the method , self.add_prefix called with an argument name , substitute the result for value .	value = field . widget . value_from_datadict ( self . data , self . files , self . add_prefix ( name ) )
7820	try ,	try :
7821	if field is an instance of FileField ,	if isinstance ( field , FileField ) :
7822	get the value under the name key of the self.initial dictionary , if it exists substitute it for initial , if not substitute field.initial for initial .	initial = self . initial . get ( name , field . initial )
7823	call the method filed.clean with arguments value and initial , substitute the result for value .	value = field . clean ( value , initial )
7824	if not ,	else :
7825	call the method field.clean with an argument value , substitute the result for value .	value = field . clean ( value )
7826	substitute value for the value under the name key of the self.cleaned_data dictionary .	self . cleaned_data [ name ] = value
7827	if self has an attribute STR0 , where STR1 is replaced with name ,	if hasattr ( self , STR0 % name ) :
7828	get STR0 , where STR1 is replaced with name ' attribute of the self object , call the result as an function , substitute the result for value .	value = getattr ( self , STR0 % name ) ( )
7829	substitute value for the value under the name key of the self.cleaned_data dictionary .	self . cleaned_data [ name ] = value
7830	if ValidationError renamed to e , exception is caught ,	except ValidationError as e :
7831	call the method self.add_error with 2 arguments name and e .	self . add_error ( name , e )
7832	define the method _clean_form with an argument self .	def _clean_form ( self ) :
7833	try ,	try :
7834	call the method self.clean , substitute the result for cleaned_data .	cleaned_data = self . clean ( )
7835	if ValidationError renamed to e , exception is caught ,	except ValidationError as e :
7836	call the method self.add_error with 2 arguments None and e .	self . add_error ( None , e )
7837	if not ,	else :
7838	if cleaned_data is not None ,	if cleaned_data is not None :
7839	substitute cleaned_data for self.cleaned_data .	self . cleaned_data = cleaned_data
7840	define the method _post_clean with an argument self .	def _post_clean ( self ) :
7841	do nothing .	pass
7842	define the method clean with an argument self .	def clean ( self ) :
7843	return self.cleaned_data .	return self . cleaned_data
7844	define the method has_changed with an argument self .	def has_changed ( self ) :
7845	convert self.changed_data into boolean , return it .	return bool ( self . changed_data )
7846	property decorator ,	@ property
7847	define the method changed_data with an argument self .	def changed_data ( self ) :
7848	if self._changed_data is None ,	if self . _changed_data is None :
7849	self._changed_data is an empty list .	self . _changed_data = [ ]
7850	call the method self.fields.items , for every name and field in the result ,	for name , field in self . fields . items ( ) :
7851	call the method self.add_prefix with an argument name , substitute the result for prefixed_name .	prefixed_name = self . add_prefix ( name )
7852	call the method field.widget.value_from_datadict with 3 arguments : self.data , self.files , prefixed_name , substitute the result for data_value .	data_value = field . widget . value_from_datadict ( self . data , self . files , prefixed_name )
7853	if field.show_hidden_initial is false ,	if not field . show_hidden_initial :
7854	get the value under the name key of the self.initial dictionary , if it exists substitute it for initial_value , if not substitute field.initial for initial_value .	initial_value = self . initial . get ( name , field . initial )
7855	if initial_value is an callable object ,	if callable ( initial_value ) :
7856	call the function initial_value , substitute the result for initial_value .	initial_value = initial_value ( )
7857	if not ,	else :
7858	call the method self.add_initial_prefix with an argument name , substitute the result for initial_prefixed_name .	initial_prefixed_name = self . add_initial_prefix ( name )
7859	call the method field.hidden_widget , substitute the result for field.hidden_widget .	hidden_widget = field . hidden_widget ( )
7860	try ,	try :
7861	call the method ( hidden_widget.value_from_datadict with 3 arguments : self.data , self.files and initial_prefixed_name , use the result as an argument for the call to the field.to_python method , substitute the result for initial_value .	initial_value = field . to_python ( hidden_widget . value_from_datadict ( self . data , self . files , initial_prefixed_name ) )
7862	if ValidationError exception is caught ,	except ValidationError :
7863	append name to self._changed_data .	self . _changed_data . append ( name )
7864	skip this loop iteration .	continue
7865	call the method field._has_changed with 2 arguments : initial_value and data_value , if it evaluates to true ,	if field . _has_changed ( initial_value , data_value ) :
7866	append name to self._changed_data list .	self . _changed_data . append ( name )
7867	return self._changed_data .	return self . _changed_data
7868	property decorator ,	@ property
7869	define the method media with an argument self .	def media ( self ) :
7870	media is an instance of Media class .	media = Media ( )
7871	call the method self.fields.values , for every field in result ,	for field in self . fields . values ( ) :
7872	append field.widget.media to media , substitute the result for media .	media = media + field . widget . media
7873	return media .	return media
7874	define the method is_multipart with an argument self .	def is_multipart ( self ) :
7875	call the method self.fields.values , for every field in result ,	for field in self . fields . values ( ) :
7876	if field.widget.needs_multipart_form is true ,	if field . widget . needs_multipart_form :
7877	return boolean True .	return True
7878	return boolean False .	return False
7879	define the method hidden_fields with an argument self .	def hidden_fields ( self ) :
7880	for field in self if field.is_hidden is true , append field to a list , return the resulting list .	return [ field for field in self if field . is_hidden ]
7881	define the method visible_fields with an argument self .	def visible_fields ( self ) :
7882	for field in self if field.is_hidden is false , append field to a list , return the resulting list .	return [ field for field in self if not field . is_hidden ]
7883	derive the class Form from the base classes DeclarativeFieldsMetaclass and BaseForm .	class Form ( six . with_metaclass ( DeclarativeFieldsMetaclass , BaseForm ) ) :
7884	decorator python_2_unicode_compatible ,	@ python_2_unicode_compatible
7885	derive the class BoundField from the base class object .	class BoundField ( object ) :
7886	define the method __init__ with 4 arguments : self , form , field and name .	def __init__ ( self , form , field , name ) :
7887	substitute form for self.form .	self . form = form
7888	substitute field for self.field .	self . field = field
7889	substitute name for self.name .	self . name = name
7890	call the method form.add_prefix with an argument self , substitute the result for self.html_name .	self . html_name = form . add_prefix ( name )
7891	call the method form.add_initial_prefix with an argument name , substitute the result for self.html_initial_name .	self . html_initial_name = form . add_initial_prefix ( name )
7892	call the method form.add_initial_prefix with an argument self.auto_id , substitute the result for self.html_initial_id .	self . html_initial_id = form . add_initial_prefix ( self . auto_id )
7893	if self.field.label is None ,	if self . field . label is None :
7894	call the method pretty_name with an argument name , substitute the result for self.label .	self . label = pretty_name ( name )
7895	if not ,	else :
7896	substitute self.field.label for self.label .	self . label = self . field . label
7897	if field.help_text is true , substitute field.help_text for self.help_text , if not self.help_text is an empty string .	self . help_text = field . help_text or STR
7898	define the method __str__ with an argument self .	def __str__ ( self ) :
7899	if self.field.show_hidden_initial is true ,	if self . field . show_hidden_initial :
7900	call the method self.as_hidden with an argument only_initial set to boolean True , append the result to the result of the method , self.as_widget , return the resulting string .	return self . as_widget ( ) + self . as_hidden ( only_initial = True )
7901	call the method self.as_widget , return the result .	return self . as_widget ( )
7902	define the method __iter__ with an argument self .	def __iter__ ( self ) :
7903	get the value under the STR0 key of the self.field.widget.attrs dictionary , if the key exists substitute it for id_ , if not , substitute self.auto_id for id_ .	id_ = self . field . widget . attrs . get ( STR0 ) or self . auto_id
7904	if if_is true attrs is an dictionary with initial entry : id_ for STR0 , if not , attrs is an empty dictionary .	attrs = { STR0 : id_ } if id_ else { }
7905	call the method self.field.widget.subwidgets with 3 arguments : self.html_name , return value of the method self.value and attrs , for every subwidget in the result ,	for subwidget in self . field . widget . subwidgets ( self . html_name , self . value ( ) , attrs ) :
7906	yield subwidget , as the result of the generator .	yield subwidget
7907	define the method __len__ with an argument self .	def __len__ ( self ) :
7908	convert result of the method self.__iter__ into a list , return its length .	return len ( list ( self . __iter__ ( ) ) )
7909	define the method __getitem__ with 2 arguments : self and idx .	def __getitem__ ( self , idx ) :
7910	convert result of the method self.__iter__ into a list , return element at the idx index .	return list ( self . __iter__ ( ) ) [ idx ]
7911	property decorator ,	@ property
7912	define the method errors with an argument self .	def errors ( self ) :
7913	get the value under the self.name key of the self.form.errors dictionary , if the key exists , return it , if not evaluate the method self.form.error_class and return the result .	return self . form . errors . get ( self . name , self . form . error_class ( ) )
7914	define the method as_widget with 4 arguments : self , widget set to None , attrs set to None , only_initial set to boolean False .	def as_widget ( self , widget = None , attrs = None , only_initial = False ) :
7915	if widget is false ,	if not widget :
7916	substitute self.field.widget for widget .	widget = self . field . widget
7917	if self.field.localize is true ,	if self . field . localize :
7918	widget.is_localized is boolean True .	widget . is_localized = True
7919	if attrs is false , make it an empty dictionary .	attrs = attrs or { }
7920	substitute self.auto_id for auto_id .	auto_id = self . auto_id
7921	if auto_id is true and STR0 is not contained in attrs and STR1 is not contained in widget.attrs ,	if auto_id and STR0 not in attrs and STR1 not in widget . attrs :
7922	if only_initial is false ,	if not only_initial :
7923	substitute auto_id for value under the STR0 key of the attrs dictionary .	attrs [ STR0 ] = auto_id
7924	if not ,	else :
7925	substitute self.html_initial_id for value under the STR0 key of the attrs dictionary .	attrs [ STR0 ] = self . html_initial_id
7926	if only_initial is false ,	if not only_initial :
7927	substitute self.html_name for name .	name = self . html_name
7928	if not ,	else :
7929	substitute self.html_initial_name for name .	name = self . html_initial_name
7930	call the method widget.render with 3 arguments : name , return value of the method self.value , attrs set to attrs , use it as an argument for the call to the function force_text , return the result .	return force_text ( widget . render ( name , self . value ( ) , attrs = attrs ) )
7931	define the method as_text with 3 arguments : self , attrs set to None and unpacked dictionary kwargs .	def as_text ( self , attrs = None , ** kwargs ) :
7932	call the method self.as_widget with 3 arguments : instance of a class TextInput , attrs and unpacked dictionary kwargs , return the result .	return self . as_widget ( TextInput ( ) , attrs , ** kwargs )
7933	define the method as_textarea with 3 arguments : self , attrs set to None and unpacked dictionary kwargs .	def as_textarea ( self , attrs = None , ** kwargs ) :
7934	call the method self.as_widget with 3 arguments : instance of a class Textarea , attrs and unpacked dictionary kwargs , return the result .	return self . as_widget ( Textarea ( ) , attrs , ** kwargs )
7935	define the method as_hidden with 3 arguments : self , attrs set to None and unpacked dictionary kwargs .	def as_hidden ( self , attrs = None , ** kwargs ) :
7936	call the method self.as_widget with 3 arguments : return value of the method self.field.hidden_widget , attrs , and unpacked dictionary kwargs , return the result .	return self . as_widget ( self . field . hidden_widget ( ) , attrs , ** kwargs )
7937	property decorator ,	@ property
7938	define the method data with an argument self .	def data ( self ) :
7939	call the method self.field.widget.value_from_datadict with 3 arguments : self.form.data , self.form.files , self.html_name , return the result .	return self . field . widget . value_from_datadict ( self . form . data , self . form . files , self . html_name )
7940	define the method value with an argument self .	def value ( self ) :
7941	if self.form.is_bound is false ,	if not self . form . is_bound :
7942	get the value under the self.name key of the self.form.initial dictionary , if it exists , substitute it for data , if not , substitute self.field.initial for data .	data = self . form . initial . get ( self . name , self . field . initial )
7943	if data is an callable object ,	if callable ( data ) :
7944	call the method data , substitute the result for data .	data = data ( )
7945	if data is an instance of datetime.datetime or datetime.time classes , and supports_microseconds field of self.field.widget is false ,	if ( isinstance ( data , ( datetime . datetime , datetime . time ) ) and not getattr ( self . field . widget , STR0 , True ) ) :
7946	call the method data.replace with an argument microsecond set to integer 0 , substitute the result for data .	data = data . replace ( microsecond = 0 )
7947	if not ,	else :
7948	call the method self.field.bound_data with 2 arguments : self.data and value under the self.name key of the dictionary , self.form.initial , if it exists , or self.field.initial if not , substitute the result for data .	data = self . field . bound_data ( self . data , self . form . initial . get ( self . name , self . field . initial ) )
7949	call the method self.field.prepare_value with an argument data , return the result .	return self . field . prepare_value ( data )
7950	define the method label_tag with 4 arguments : self , contents set to None , attrs set to None and label_suffix set to None .	def label_tag ( self , contents = None , attrs = None , label_suffix = None ) :
7951	if contents is false , substitute self.label for contents .	contents = contents or self . label
7952	if label_suffix is None ,	if label_suffix is None :
7953	if self.field.label_suffix is not None , substitute self.field.label_suffix for label_suffix , otherwise substitute self.form.label_suffix for label_suffix .	label_suffix = ( self . field . label_suffix if self . field . label_suffix is not None else self . form . label_suffix )
7954	if label_suffix and contents are both true and last element of contents is not contained in the result of the function _ , called with an argument string STR0 .	if label_suffix and contents and contents [ - 1 ] not in _ ( STR0 ) :
7955	call the method format_html with 3 arguments : string STR0 , contents and label_suffix , substitute the result for contents .	contents = format_html ( STR0 , contents , label_suffix )
7956	substitute self.field.widget for widget .	widget = self . field . widget
7957	get the value under the STR0 key of the widget.attrs dictionary , if the key exists substitute it for id_ , if not , substitute self.auto_id for id_ .	id_ = widget . attrs . get ( STR0 ) or self . auto_id
7958	if id_ is true ,	if id_ :
7959	call the method widget.id_for_label with an argument id_ , substitute the result for id_for_label .	id_for_label = widget . id_for_label ( id_ )
7960	if id_for_label is true ,	if id_for_label :
7961	unpack a dictionary with an entry id_for_label for STR0 , map it through attrs mapping if attrs is true , and convert it again to the dictionary , if attrs is false , leave it alone , substitute the result for attrs .	attrs = dict ( attrs or { } , ** { STR0 : id_for_label } )
7962	if self.field.required is true and self.form has an attribute STR0 ,	if self . field . required and hasattr ( self . form , STR0 ) :
7963	if attrs is false , make attrs an empty dictionary .	attrs = attrs or { }
7964	if STR0 is contained in attrs ,	if STR0 in attrs :
7965	append self.form.required_css_class to a whitespace character , append it to the value under the STR0 key of the attrs dictionary .	attrs [ STR0 ] += STR + self . form . required_css_class
7966	if not ,	else :
7967	substitute self.form.required_css_class for the value under the STR0 key of the attrs dictionary .	attrs [ STR0 ] = self . form . required_css_class
7968	if attrs is true , call the function flatatt with an argument attrs , substitute the result for attrs , if not attrs is an empty string .	attrs = flatatt ( attrs ) if attrs else STR
7969	call the function format_html with 3 arguments string STR0 , attrs and contents , substitute the result for contents .	contents = format_html ( STR0 , attrs , contents )
7970	if not ,	else :
7971	call the function conditional_escape with an argument contents , substitute the result for contents .	contents = conditional_escape ( contents )
7972	call the function mark_safe with an argument contents , return the result .	return mark_safe ( contents )
7973	define the method css_classes with 2 arguments : self and extra_classes set to None .	def css_classes ( self , extra_classes = None ) :
7974	if extra_classes has an attribute STR0 ,	if hasattr ( extra_classes , STR0 ) :
7975	split extra_classes into words , by whitespaces , substitute the result for extra_classes .	extra_classes = extra_classes . split ( )
7976	if extra_classes is not empty put its elements into a set , substitute it for extra_classes , if not extra_classes is an empty set .	extra_classes = set ( extra_classes or [ ] )
7977	if self.errors is true and self.form has an attribute STR0 ,	if self . errors and hasattr ( self . form , STR0 ) :
7978	add self.form.error_css_class to extra_classes set .	extra_classes . add ( self . form . error_css_class )
7979	if self.field.required is true and self.form has an attribute STR0 ,	if self . field . required and hasattr ( self . form , STR0 ) :
7980	add self.form.required_css_class to extra_classes set .	extra_classes . add ( self . form . required_css_class )
7981	join elements of extra_classes into a string separated by whitespaces , return it .	return STR . join ( extra_classes )
7982	property decorator ,	@ property
7983	define the method is_hidden with an argument self .	def is_hidden ( self ) :
7984	return self.field.widget.is_hidden ,	return self . field . widget . is_hidden
7985	property decorator ,	@ property
7986	define the method auto_id with an argument self .	def auto_id ( self ) :
7987	substitute self.form.auto_id for auto_id .	auto_id = self . form . auto_id
7988	if auto_id is true and STR0 is contained in result of the call to the function smart_text with an argument auto_id ,	if auto_id and STR0 in smart_text ( auto_id ) :
7989	call the function smart_text with an argument auto_id , format the result with self.html_name , return it .	return smart_text ( auto_id ) % self . html_name
7990	otherwise if auto_id is true ,	elif auto_id :
7991	return self.html_name .	return self . html_name
7992	return an empty string .	return STR
7993	property decorator ,	@ property
7994	define the method id_for_label with an argument self .	def id_for_label ( self ) :
7995	substitute self.field.widget for widget .	widget = self . field . widget
7996	get the value under the STR0 key of the widget.attrs dictionary , if the key exists substitute it for id_ , if not , substitute self.auto_id for id_ .	id_ = widget . attrs . get ( STR0 ) or self . auto_id
7997	call the method widget.id_for_label with an argument id_ , return the result .	return widget . id_for_label ( id_ )
7998	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
7999	from django.core.exceptions import ValidationError into default name space .	from django . core . exceptions import ValidationError
8000	from django.forms import Form into default name space .	from django . forms import Form
8001	from django.forms.fields import IntegerField and BooleanField into default name space .	from django . forms . fields import IntegerField , BooleanField
8002	from django.forms.utils import ErrorList into default name space .	from django . forms . utils import ErrorList
8003	from django.forms.widgets import HiddenInput into default name space .	from django . forms . widgets import HiddenInput
8004	from django.utils.encoding import python_2_unicode_compatible into default name space .	from django . utils . encoding import python_2_unicode_compatible
8005	from django.utils.functional import cached_property into default name space .	from django . utils . functional import cached_property
8006	from django.utils.safestring import mark_safe into default name space .	from django . utils . safestring import mark_safe
8007	from django.utils import six into default name space .	from django . utils import six
8008	from django.utils.six.moves import xrange into default name space .	from django . utils . six . moves import xrange
8009	from django.utils.translation import ungettext and ugettext as _ into default name space .	from django . utils . translation import ungettext , ugettext as _
8010	__all__ is a tuple containing strings STR0 , STR1 and STR2 .	__all__ = ( STR0 , STR1 , STR2 )
8011	TOTAL_FORM_COUNT is a string STR0 .	TOTAL_FORM_COUNT = STR0
8012	INITIAL_FORM_COUNT is a string STR0 .	INITIAL_FORM_COUNT = STR0
8013	MIN_NUM_FORM_COUNT is a string STR0 .	MIN_NUM_FORM_COUNT = STR0
8014	MAX_NUM_FORM_COUNT is a string STR0 .	MAX_NUM_FORM_COUNT = STR0
8015	ORDERING_FIELD_NAME is a string STR0 .	ORDERING_FIELD_NAME = STR0
8016	DELETION_FIELD_NAME is a string STR0 .	DELETION_FIELD_NAME = STR0
8017	DEFAULT_MIN_NUM is an integer 0 .	DEFAULT_MIN_NUM = 0
8018	DEFAULT_MAX_NUM is an integer 1000 .	DEFAULT_MAX_NUM = 1000
8019	derive the class ManagementForm from the Form base class .	class ManagementForm ( Form ) :
8020	define the method __init__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , * args , ** kwargs ) :
8021	value under the TOTAL_FORM_COUNT of the self.base_fields dictionary is an instance of IntegerField class , created with an argument widget set to HiddenInput .	self . base_fields [ TOTAL_FORM_COUNT ] = IntegerField ( widget = HiddenInput )
8022	value under the INITIAL_FORM_COUNT of the self.base_fields dictionary is an instance of IntegerField class , created with an argument widget set to HiddenInput .	self . base_fields [ INITIAL_FORM_COUNT ] = IntegerField ( widget = HiddenInput )
8023	value under the MIN_NUM_FORM_COUNT of the self.base_fields dictionary is an instance of IntegerField class , created with 2 arguments : required as boolean False and widget set to HiddenInput .	self . base_fields [ MIN_NUM_FORM_COUNT ] = IntegerField ( required = False , widget = HiddenInput )
8024	value under the MAX_NUM_FORM_COUNT of the self.base_fields dictionary is an instance of IntegerField class , created with 2 arguments : required as boolean False and widget set to HiddenInput .	self . base_fields [ MAX_NUM_FORM_COUNT ] = IntegerField ( required = False , widget = HiddenInput )
8025	call the method __init__ from the base class of the class ManagementForm , called with 2 arguments : unpacked list args , and unpacked dictionary kwargs .	super ( ManagementForm , self ) . __init__ ( * args , ** kwargs )
8026	python_2_unicode_compatible decorator ,	@ python_2_unicode_compatible
8027	derive the class BaseFormSet from the object base class .	class BaseFormSet ( object ) :
8028	define the method __init__ with 7 arguments : self , data set to None , files set to None , auto_id set to an string STR0 ,	def __init__ ( self , data = None , files = None , auto_id = STR0 , prefix = None , initial = None , error_class = ErrorList ) :
8029	if data is not None or files is not None , self.is_bound is boolean True , otherwise it is boolean False .	self . is_bound = data is not None or files is not None
8030	if prefix is true , substitute it for self.prefix , otherwise call the method self.get_default_prefix , and substitute the result for self.prefix .	self . prefix = prefix or self . get_default_prefix ( )
8031	substitute auto_id for self.auto_id .	self . auto_id = auto_id
8032	if data is true , substitute it for self.data , otherwise self.data is an empty dictionary .	self . data = data or { }
8033	if data is true , substitute it for self.files , otherwise self.files is an empty dictionary .	self . files = files or { }
8034	substitute initial_id for self.auto_id .	self . initial = initial
8035	substitute error_class for self.error_class .	self . error_class = error_class
8036	self._errors is None .	self . _errors = None
8037	self._non_form_errors is None .	self . _non_form_errors = None
8038	define the method __str__ with an argument self .	def __str__ ( self ) :
8039	call the method self.as_table , return the result .	return self . as_table ( )
8040	define the method __iter__ with an argument self .	def __iter__ ( self ) :
8041	convert self.forms into an iterable , return it .	return iter ( self . forms )
8042	define the method __getitem__ with an argument self .	def __getitem__ ( self , index ) :
8043	return self.forms element at the index index .	return self . forms [ index ]
8044	define the method __len__ with an argument self .	def __len__ ( self ) :
8045	return the length of self.forms .	return len ( self . forms )
8046	define the method __bool__ with an argument self .	def __bool__ ( self ) :
8047	return boolean True .	return True
8048	define the method __nonzero__ with an argument self .	def __nonzero__ ( self ) :
8049	get the type of self object , call the __bool__ method on the result with an argument self , return the result .	return type ( self ) . __bool__ ( self )
8050	property decorator ,	@ property
8051	define the method management_form with an argument self .	def management_form ( self ) :
8052	if self.is_bound is true ,	if self . is_bound :
8053	form is an instance of ManagementForm class , created with 3 arguments : self.data , auto_id as self.auto_id and prefix as self.prefix .	form = ManagementForm ( self . data , auto_id = self . auto_id , prefix = self . prefix )
8054	call the form.is_valid method , if it evaluates to false ,	if not form . is_valid ( ) :
8055	raise ValidationError with 2 arguments : return value of the function _ called with an argument string , STR0 and code as a string STR1 .	raise ValidationError ( _ ( STR0 ) , code = STR1 , )
8056	if not ,	else :
8057	form is an instance of ManagementForm class , created with 3 arguments : auto_id as self.auto_id , prefix as self.prefix , and initial as a dictionary with 4 entries : result of self.total_form_count method for TOTAL_FORM_COUNT , result of self.initial_form_count method for INITIAL_FORM_COUNT , self.min_num for MIN_NUM_FORM_COUNT and self.max_num for MAX_NUM_FORM_COUNT .	form = ManagementForm ( auto_id = self . auto_id , prefix = self . prefix , initial = { TOTAL_FORM_COUNT : self . total_form_count ( ) , INITIAL_FORM_COUNT : self . initial_form_count ( ) , MIN_NUM_FORM_COUNT : self . min_num , MAX_NUM_FORM_COUNT : self . max_num } )
8058	return form .	return form
8059	define the method total_form_count with an argument self .	def total_form_count ( self ) :
8060	if self.is_bound is true ,	if self . is_bound :
8061	get the element with minimal value between the value under the TOTAL_FORM_COUNT key of self.management_form.cleaned_data dictionary , and self.absolute_max , return the result .	return min ( self . management_form . cleaned_data [ TOTAL_FORM_COUNT ] , self . absolute_max )
8062	if not ,	else :
8063	call the method self.initial_form_count , return the result initial_forms .	initial_forms = self . initial_form_count ( )
8064	get the element with maximal value between initial_forms and self.min_num , add self.extra to it , substitute the result for total_forms .	total_forms = max ( initial_forms , self . min_num ) + self . extra
8065	if initial_forms is grater than self.max_num is grater or equal to integer 0 ,	if initial_forms > self . max_num >= 0 :
8066	substitute initial_forms for total_forms .	total_forms = initial_forms
8067	otherwise if total_forms is grater than self.max_num is grater or equal to integer 0 ,	elif total_forms > self . max_num >= 0 :
8068	substitute self.max_num for total_forms .	total_forms = self . max_num
8069	return total_forms .	return total_forms
8070	define the method initial_form_count with an argument self .	def initial_form_count ( self ) :
8071	if self.is_bound is true ,	if self . is_bound :
8072	return the value under the INITIAL_FORM_COUNT key of the self.management_form.cleaned_data dictionary .	return self . management_form . cleaned_data [ INITIAL_FORM_COUNT ]
8073	if not ,	else :
8074	if self.initial is true , substitute the length of self.initial for initial_forms , if not , initial_forms is integer 0 .	initial_forms = len ( self . initial ) if self . initial else 0
8075	return initial_forms .	return initial_forms
8076	cached_property decorator ,	@ cached_property
8077	define the method forms with an argument self .	def forms ( self ) :
8078	for every i in sequence of integers from 0 to result of the method self.total_form_count , call the method self._construct_form , with an argument i , append the result to a list , substitute the resulting list for forms .	forms = [ self . _construct_form ( i ) for i in xrange ( self . total_form_count ( ) ) ]
8079	return forms .	return forms
8080	define the method _construct_form with 3 arguments : self , i and unpacked dictionary kwargs .	def _construct_form ( self , i , ** kwargs ) :
8081	defaults is an dictionary with 3 initial entries : self.auto_id for STR0 , result of the call to the method self.add_prefix , with an argument i , for STR1 and self.error_class for STR2 .	defaults = { STR0 : self . auto_id , STR1 : self . add_prefix ( i ) , STR2 : self . error_class , }
8082	if self.is_bound is true ,	if self . is_bound :
8083	substitute self.data for value under the STR0 key of the defaults dictionary .	defaults [ STR0 ] = self . data
8084	substitute self.files for value under the STR0 key of the defaults dictionary .	defaults [ STR0 ] = self . files
8085	if self.initial is true and STR0 key is not contained in kwargs ,	if self . initial and STR0 not in kwargs :
8086	try ,	try :
8087	substitute i-th element of self.initial for value under the STR0 key of the defaults dictionary .	defaults [ STR0 ] = self . initial [ i ]
8088	if IndexError exception is caught ,	except IndexError :
8089	do nothing .	pass
8090	if i is greater than , or equal to the result of the call to the method self.initial_form_count ,	if i >= self . initial_form_count ( ) and i >= self . min_num :
8091	and i is greater than or equal to self.min_num , value under the STR0 key of the defaults dictionary is boolean True .	defaults [ STR0 ] = True
8092	update defaults dictionary with kwargs .	defaults . update ( kwargs )
8093	call the method self.form with unpacked dictionary defaults as an argument , substitute it for form .	form = self . form ( ** defaults )
8094	call the method self.add_fields with arguments form and i ) .	self . add_fields ( form , i )
8095	return form .	return form
8096	property decorator ,	@ property
8097	define the method initial_forms with an argument self .	def initial_forms ( self ) :
8098	call the self.initial_form_count method , return the sublist of self.forms from the beginning to the previous result as the end index .	return self . forms [ : self . initial_form_count ( ) ]
8099	property decorator ,	@ property
8100	define the method extra_forms with an argument self .	def extra_forms ( self ) :
8101	call the self.initial_form_count method , return the sublist of self.forms , using previous result as start index to the end .	return self . forms [ self . initial_form_count ( ) : ]
8102	property decorator ,	@ property
8103	define the method empty_form with an argument self .	def empty_form ( self ) :
8104	call the function empty_form with 3 arguments : auto_id as self.auto_id , prefix set to the return value of the self.add_prefix method , called with string STR0 as an argument and empty_permitted as boolean True , substitute the result for form .	form = self . form ( auto_id = self . auto_id , prefix = self . add_prefix ( STR0 ) , empty_permitted = True , )
8105	call the method self.add_fields with arguments form and None .	self . add_fields ( form , None )
8106	return form .	return form
8107	property decorator ,	@ property
8108	define the method cleaned_data with an argument self .	def cleaned_data ( self ) :
8109	call the method self.is_valid , if it evaluates to false ,	if not self . is_valid ( ) :
8110	raise an AttributeError exception with an argument string : STR0 , where STR1 is replaced with self.__class__.__name__ .	raise AttributeError ( STR0 % self . __class__ . __name__ )
8111	for form in self.forms append form.cleaned_data to a list , return the resulting list .	return [ form . cleaned_data for form in self . forms ]
8112	property decorator ,	@ property
8113	define the method deleted_forms with an argument self .	def deleted_forms ( self ) :
8114	if call to the method self.is_valid , evaluates to false or self.can_delete is boolean false ,	if not self . is_valid ( ) or not self . can_delete :
8115	return an empty list .	return [ ]
8116	if self doesnt have an STR0 attribute ,	if not hasattr ( self , STR0 ) :
8117	self._deleted_form_indexes is an empty list .	self . _deleted_form_indexes = [ ]
8118	call the method self.total_form_count , for every i in sequence of integers , from 0 to the previous result ,	for i in range ( 0 , self . total_form_count ( ) ) :
8119	substitute i-th element of self.forms for form .	form = self . forms [ i ]
8120	if i is greater than or equal to the result of the method self.initial_form_count ,	if i >= self . initial_form_count ( ) and not form . has_changed ( ) :
8121	and call to the method form.has_changed evaluates to false , skip this loop iteration ,	continue
8122	call the method self._should_delete_form with an argument form , if it evaluates to true ,	if self . _should_delete_form ( form ) :
8123	call the method self._deleted_form_indexes.append with an argument i .	self . _deleted_form_indexes . append ( i )
8124	for i in self._deleted_form_indexes append i-th element of self.forms into a list , return the resulting list .	return [ self . forms [ i ] for i in self . _deleted_form_indexes ]
8125	property decorator ,	@ property
8126	define the method ordered_forms with an argument self .	def ordered_forms ( self ) :
8127	if call to the self.is_valid method evaluates to false or self.can_order is false ,	if not self . is_valid ( ) or not self . can_order :
8128	raise an AttributeError exception with an argument string : STR0 , where STR1 is replaced with self.__class__.__name__ .	raise AttributeError ( STR0 % self . __class__ . __name__ )
8129	if self doesnt have an STR0 attribute ,	if not hasattr ( self , STR0 ) :
8130	self._ordering is an empty list .	self . _ordering = [ ]
8131	for every i in sequence of integers , from 0 to the result of the method self.total_form_count ,	for i in range ( 0 , self . total_form_count ( ) ) :
8132	substitute i-th element of self.forms for form .	form = self . forms [ i ]
8133	if i is greater than or equal to the result of the method self.initial_form_count ,	if i >= self . initial_form_count ( ) and not form . has_changed ( ) :
8134	and call to the method form.has_changed evaluates to false , skip this loop iteration ,	continue
8135	if self.can_delete is true and call to the method self._should_delete_form with an argument form , evaluates to true ,	if self . can_delete and self . _should_delete_form ( form ) :
8136	skip this loop iteration ,	continue
8137	append tuple with 2 elements : i and value under the ORDERING_FIELD_NAME key of form.cleaned_data dictionary to self._ordering .	self . _ordering . append ( ( i , form . cleaned_data [ ORDERING_FIELD_NAME ] ) )
8138	define the function compare_ordering_key with an argument k .	def compare_ordering_key ( k ) :
8139	if second element of k is None ,	if k [ 1 ] is None :
8140	return a tuple with 2 elements : integers 1 and 0 .	return ( 1 , 0 )
8141	return a tuple with 2 elements : integer 0 and second element of k .	return ( 0 , k [ 1 ] )
8142	call the method self._ordering.sort with an argument key as compare_ordering_key .	self . _ordering . sort ( key = compare_ordering_key )
8143	for i in self._ordering append to a list value under the first element of i key of the self.forms dictionary , return resulting list .	return [ self . forms [ i [ 0 ] ] for i in self . _ordering ]
8144	classmethod decorator ,	@ classmethod
8145	define the method get_default_prefix with an argument cls .	def get_default_prefix ( cls ) :
8146	return string STR0 .	return STR0
8147	define the method non_form_errors with an argument self .	def non_form_errors ( self ) :
8148	if self._non_form_errors is None ,	if self . _non_form_errors is None :
8149	call the method self.full_clean .	self . full_clean ( )
8150	return self._non_form_errors .	return self . _non_form_errors
8151	property decorator ,	@ property
8152	define the method errors with an argument self .	def errors ( self ) :
8153	if self._errors is None ,	if self . _errors is None :
8154	call the method self.full_clean .	self . full_clean ( )
8155	return self._errors .	return self . _errors
8156	define the method total_error_count with an argument self .	def total_error_count ( self ) :
8157	for every form_errors in self.errors sum length of return value of the method self.non_form_errors and length of form_errors , return the result .	return len ( self . non_form_errors ( ) ) + sum ( len ( form_errors ) for form_errors in self . errors )
8158	define the method _should_delete_form with an argument self .	def _should_delete_form ( self , form ) :
8159	get the value under the DELETION_FIELD_NAME key of the form.cleaned_data dictionary , if it exists return it , if not , return boolean False .	return form . cleaned_data . get ( DELETION_FIELD_NAME , False )
8160	define the method is_valid with an argument self .	def is_valid ( self ) :
8161	if self.is_bound is false ,	if not self . is_bound :
8162	return boolean False .	return False
8163	forms_valid is True .	forms_valid = True
8164	call self.errors .	self . errors
8165	for every i in sequence of integers , from 0 to the result of the method self.total_form_count ,	for i in range ( 0 , self . total_form_count ( ) ) :
8166	substitute i-th element of self.forms for form .	form = self . forms [ i ]
8167	if self.can_delete is true ,	if self . can_delete :
8168	call the method self._should_delete_form with an argument , if it evaluates to true ,	if self . _should_delete_form ( form ) :
8169	skip this loop iteration ,	continue
8170	call the method form.is_valid , perform bitwise and with the result and forms_valid as operands , substitute the result for forms_valid .	forms_valid &= form . is_valid ( )
8171	if forms_valid is true and call to the method self.non_form_errors , evaluates to false , return boolean True , otherwise return False .	return forms_valid and not self . non_form_errors ( )
8172	define the method full_clean with an argument self .	def full_clean ( self ) :
8173	self._errors is an empty list .	self . _errors = [ ]
8174	call the method self.error_class , substitute the result for self._non_form_errors .	self . _non_form_errors = self . error_class ( )
8175	if self.is_bound is false ,	if not self . is_bound :
8176	return nothing .	return
8177	for every i in sequence of integers , from 0 to the result of the method self.total_form_count ,	for i in range ( 0 , self . total_form_count ( ) ) :
8178	substitute i-th element of self.forms for form .	form = self . forms [ i ]
8179	append form.errors to self._errors .	self . _errors . append ( form . errors )
8180	try ,	try :
8181	if self.validate_max is true , and length of self.deleted_forms subtracted from the return value of the method self.total_form_count , is greater than self.max_num , or if value under the TOTAL_FORM_COUNT key of the self.management_form.cleaned_data dictionary , is grater than self.absolute_max ,	if ( self . validate_max and self . total_form_count ( ) - len ( self . deleted_forms ) > self . max_num ) or self . management_form . cleaned_data [ TOTAL_FORM_COUNT ] > self . absolute_max :
8182	raise an ValidationError with 2 arguments : return value of the function ungettext with 3 arguments : strings STR0 , STR1 and self.max_num , where STR2 is replaced with self.max_num , and code as a string STR3 .	raise ValidationError ( ungettext ( STR0 , STR1 , self . max_num ) % self . max_num , code = STR2 , )
8183	if self.validate_min is true , and length of self.deleted_forms subtracted from the return value of the method self.total_form_count , is smaller than self.min_num ,	if ( self . validate_min and self . total_form_count ( ) - len ( self . deleted_forms ) < self . min_num ) :
8184	raise an ValidationError with 2 arguments : return value of the function ungettext with 3 arguments : strings STR0 , STR1 and self.min_num , where STR2 is replaced with self.min_num , and code as a string STR3 .	raise ValidationError ( ungettext ( STR0 , STR1 , self . min_num ) % self . min_num , code = STR2 )
8185	call the method self.clean .	self . clean ( )
8186	if ValidationError , renamed to e , exception is caught ,	except ValidationError as e :
8187	call the method self.error_class with an argument e.error_list , substitute the result for self._non_form_errors .	self . _non_form_errors = self . error_class ( e . error_list )
8188	define the method clean with an argument self .	def clean ( self ) :
8189	do nothing .	pass
8190	define the method has_changed with an argument self .	def has_changed ( self ) :
8191	for every form in self call the method form.has_changed if any of the results evaluates to true , return boolean True , if not return boolean False .	return any ( form . has_changed ( ) for form in self )
8192	define the method add_fields with 3 arguments : self , form and index .	def add_fields ( self , form , index ) :
8193	if self.can_order is true ,	if self . can_order :
8194	if index is not None and index is smaller than return value of the method self.initial_form_count ,	if index is not None and index < self . initial_form_count ( ) :
8195	value under the ORDERING_FIELD_NAME key of the form.fields is an instance of IntegerField class , created with 3 arguments : label set to return value of the function _ called with an string STR0 , initial set to index incremented by 1 , and required as boolean False .	form . fields [ ORDERING_FIELD_NAME ] = IntegerField ( label = _ ( STR0 ) , initial = index + 1 , required = False )
8196	if not ,	else :
8197	value under the ORDERING_FIELD_NAME key of the form.fields is an instance of IntegerField class , created with 2 arguments : label set to return value of the function _ called with an string STR0 and required as boolean False .	form . fields [ ORDERING_FIELD_NAME ] = IntegerField ( label = _ ( STR0 ) , required = False )
8198	if self.can_delete is true ,	if self . can_delete :
8199	value under the DELETION_FIELD_NAME key of the form.fields is an instance of BooleanField class , created with 2 arguments : label set to return value of the function _ called with an string STR0 and required as boolean False .	form . fields [ DELETION_FIELD_NAME ] = BooleanField ( label = _ ( STR0 ) , required = False )
8200	define the method add_prefix with an argument self .	def add_prefix ( self , index ) :
8201	replace STR0 in sting STR1 with self.prefix and index , return the result .	return STR0 % ( self . prefix , index )
8202	define the method is_multipart with an argument self .	def is_multipart ( self ) :
8203	if self.forms is true ,	if self . forms :
8204	call the method is_multipart on the first element of self.forms , return it .	return self . forms [ 0 ] . is_multipart ( )
8205	if not ,	else :
8206	call the method self.empty_form.is_multipart , return the result	return self . empty_form . is_multipart ( )
8207	property decorator ,	@ property
8208	define the method media with an argument self .	def media ( self ) :
8209	if self.forms is true ,	if self . forms :
8210	return the media field of the first element of self.forms .	return self . forms [ 0 ] . media
8211	if not ,	else :
8212	return self.empty_form.media .	return self . empty_form . media
8213	define the method as_table with an argument self .	def as_table ( self ) :
8214	for every form in self call the form.as_table method , join the results in a string , separated by an empty string .	forms = STR . join ( form . as_table ( ) for form in self )
8215	join return value of the function six.text_type called with an argument self.management_form and forms into a string , separated by newline , use it as an argument for the call to the function mark_safe , return the result .	return mark_safe ( STR0 . join ( [ six . text_type ( self . management_form ) , forms ] ) )
8216	define the method as_p with an argument self .	def as_p ( self ) :
8217	for every form in self call the form.as_p method , join the results in a string , separated by an empty string .	forms = STR . join ( form . as_p ( ) for form in self )
8218	join return value of the function six.text_type called with an argument self.management_form and forms into a string , separated by newline , use it as an argument for the call to the function mark_safe , return the result .	return mark_safe ( STR0 . join ( [ six . text_type ( self . management_form ) , forms ] ) )
8219	define the method as_ul with an argument self .	def as_ul ( self ) :
8220	for every form in self call the form.as_ul method , join the results in a string , separated by an empty string .	forms = STR . join ( form . as_ul ( ) for form in self )
8221	join return value of the function six.text_type called with an argument self.management_form and forms into a string , separated by newline , use it as an argument for the call to the function mark_safe , return the result .	return mark_safe ( STR0 . join ( [ six . text_type ( self . management_form ) , forms ] ) )
8222	define the function formset_factory with 9 arguments : form , formset set to BaseFormSet , extra set to integer 1 ,	def formset_factory ( form , formset = BaseFormSet , extra = 1 , can_order = False , can_delete = False , max_num = None , validate_max = False , min_num = None , validate_min = False ) :
8223	if min_num is None ,	if min_num is None :
8224	substitute DEFAULT_MIN_NUM for min_num ,	min_num = DEFAULT_MIN_NUM
8225	if max_num is None ,	if max_num is None :
8226	substitute DEFAULT_MAX_NUM for max_num ,	max_num = DEFAULT_MAX_NUM
8227	sum max_num and DEFAULT_MAX_NUM , substitute the result for absolute_max .	absolute_max = max_num + DEFAULT_MAX_NUM
8228	attrs is an dictionary with 9 initial entries : form for STR0 , extra for STR1 , can_order for STR2 , can_delete for STR3 , min_num for STR4 , max_num for STR5 , absolute_max for STR6 , validate_min for STR7 for validate_max for STR8 .	attrs = { STR0 : form , STR1 : extra , STR2 : can_order , STR3 : can_delete , STR4 : min_num , STR5 : max_num , STR6 : absolute_max , STR7 : validate_min , STR8 : validate_max }
8229	create a class class which name is generated by converting STR0 into a string and appending it to form.__name__ , is derived from the formset base class and with fields contained in attrs , return an instance of the obtained class .	return type ( form . __name__ + str ( STR0 ) , ( formset , ) , attrs )
8230	define the function all_valid with an argument formsets .	def all_valid ( formsets ) :
8231	valid is boolean True .	valid = True
8232	for every formset in formsets ,	for formset in formsets :
8233	call the function formset.is_valid , if it evaluates to false ,	if not formset . is_valid ( ) :
8234	valid is boolean False .	valid = False
8235	return valid .	return valid
8236	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
8237	from collections import OrderedDict into default name space .	from collections import OrderedDict
8238	import module warnings .	import warnings
8239	django.core.exceptions import ImproperlyConfigured , ValidationError , NON_FIELD_ERRORS and FieldError into default namespace .	from django . core . exceptions import ( ImproperlyConfigured , ValidationError , NON_FIELD_ERRORS , FieldError )
8240	from django.forms.fields import Field and ChoiceField into default name space .	from django . forms . fields import Field , ChoiceField
8241	from django.forms.forms import DeclarativeFieldsMetaclass and BaseForm into default name space .	from django . forms . forms import DeclarativeFieldsMetaclass , BaseForm
8242	from django.forms.formsets import BaseFormSet and formset_factory into default name space .	from django . forms . formsets import BaseFormSet , formset_factory
8243	from django.forms.utils import ErrorList into default name space .	from django . forms . utils import ErrorList
8244	from django.forms.widgets import SelectMultiple , HiddenInput , MultipleHiddenInput into default namespace .	from django . forms . widgets import ( SelectMultiple , HiddenInput , MultipleHiddenInput )
8245	from django.utils import six into default name space .	from django . utils import six
8246	from django.utils.deprecation import RemovedInDjango19Warning into default name space .	from django . utils . deprecation import RemovedInDjango19Warning
8247	from django.utils.encoding import smart_text and force_text into default name space .	from django . utils . encoding import smart_text , force_text
8248	from django.utils.text import get_text_list and capfirst into default name space .	from django . utils . text import get_text_list , capfirst
8249	from django.utils.translation import ugettext_lazy as _ and ugettext into default name space .	from django . utils . translation import ugettext_lazy as _ , ugettext
8250	__all__ is a tuple containing strings : STR0 , STR1 , STR2 , STR3 , STR4 ,	__all__ = ( STR0 , STR1 , STR2 , STR3 , STR4 , STR5 , STR6 , STR7 , STR8 , STR9 , STR10 , STR11 , )
8251	STR0 , STR1 , STR2 , STR3 , STR4 , STR5 , and STR6 . ALL_FIELDS is a string STR7 .	ALL_FIELDS = STR0
8252	define the function construct_instance with 4 arguments : form , instance , fields set to None and exclude set to None .	def construct_instance ( form , instance , fields = None , exclude = None ) :
8253	from django.db import models into default namespace .	from django . db import models
8254	substitute instance._meta for opts .	opts = instance . _meta
8255	substitute form.cleaned_data for cleaned_data .	cleaned_data = form . cleaned_data
8256	file_field_list is an empty list .	file_field_list = [ ]
8257	for every f in opts.fields ,	for f in opts . fields :
8258	if f.editable is true and f is an instance of models.AutoField , or f.name is not contained in cleaned_data ,	if not f . editable or isinstance ( f , models . AutoField ) or f . name not in cleaned_data :
8259	skip this loop iteration .	continue
8260	if fields is not None and f.name is not contained in fields ,	if fields is not None and f . name not in fields :
8261	skip this loop iteration .	continue
8262	if exclude is true and f.name is contained in exclude ,	if exclude and f . name in exclude :
8263	skip this loop iteration .	continue
8264	if f is an instance of models.FileField ,	if isinstance ( f , models . FileField ) :
8265	append f to file_field_list .	file_field_list . append ( f )
8266	if not ,	else :
8267	call the method f.save_form_data with 2 arguments : instance and value under the f.name key of cleaned_data dictionary .	f . save_form_data ( instance , cleaned_data [ f . name ] )
8268	for every f in file_field_list ,	for f in file_field_list :
8269	call the method f.save_form_data with 2 arguments : instance and value under the f.name key of cleaned_data dictionary .	f . save_form_data ( instance , cleaned_data [ f . name ] )
8270	return instance .	return instance
8271	define the function save_instance with 7 arguments : form , instance , fields set to None , fail_message as string STR0 ,	def save_instance ( form , instance , fields = None , fail_message = STR0 , commit = True , exclude = None , construct = True ) :
8272	if construct is true ,	if construct :
8273	call the function construct_instance with 4 arguments form , instance , fields , exclude and substitute the result for instance .	instance = construct_instance ( form , instance , fields , exclude )
8274	substitute instance._meta for opts .	opts = instance . _meta
8275	if form.errors is true ,	if form . errors :
8276	raise an ValueError with an argument string STR0 , where STR1 is replaced with opts.object_name and fail_message , respectively .	raise ValueError ( STR0 % ( opts . object_name , fail_message ) )
8277	define the function save_m2m .	def save_m2m ( ) :
8278	substitute form.cleaned_data for cleaned_data .	cleaned_data = form . cleaned_data
8279	append opts.virtual_fields to opts.many_to_many , for every f in the result ,	for f in opts . many_to_many + opts . virtual_fields :
8280	if f doesnt has an STR0 attribute ,	if not hasattr ( f , STR0 ) :
8281	skip this loop iteration .	continue
8282	if fields is true and f.name is not contained in fields ,	if fields and f . name not in fields :
8283	skip this loop iteration .	continue
8284	if exclude is true and f.name is contained in exclude ,	if exclude and f . name in exclude :
8285	skip this loop iteration .	continue
8286	if f.name is contained in cleaned_data ,	if f . name in cleaned_data :
8287	call the method f.save_form_data with 2 arguments : instance and value under the f.name key of cleaned_data dictionary .	f . save_form_data ( instance , cleaned_data [ f . name ] )
8288	if commit is true ,	if commit :
8289	call the method instance.save .	instance . save ( )
8290	call the function save_m2m .	save_m2m ( )
8291	if not ,	else :
8292	substitute save_m2m for form.save_m2m .	form . save_m2m = save_m2m
8293	return instance .	return instance
8294	define the function model_to_dict with 3 arguments : instance , fields set to None and exclude set None .	def model_to_dict ( instance , fields = None , exclude = None ) :
8295	from django.db.models.fields.related import ManyToManyField .	from django . db . models . fields . related import ManyToManyField
8296	substitute instance._meta for opts .	opts = instance . _meta
8297	data is an empty dictionary .	data = { }
8298	concatenate opts.concrete_fields , opts.virtual_fields and opts.many_to_many , for every f in the result ,	for f in opts . concrete_fields + opts . virtual_fields + opts . many_to_many :
8299	get STR0 attribute from object f , if it doesnt exists or its true ,	if not getattr ( f , STR0 , False ) :
8300	skip this loop iteration .	continue
8301	if fields is true and f.name is not contained in fields ,	if fields and f . name not in fields :
8302	skip this loop iteration .	continue
8303	if exclude is true and f.name is contained in exclude ,	if exclude and f . name in exclude :
8304	skip this loop iteration .	continue
8305	if f is an instance of ManyToManyField ,	if isinstance ( f , ManyToManyField ) :
8306	if instance.pk is None ,	if instance . pk is None :
8307	value under f.name key of the dta dictionary is an empty list .	data [ f . name ] = [ ]
8308	if not ,	else :
8309	call the method f.value_from_object with an argument instance , substitute the result for qs .	qs = f . value_from_object ( instance )
8310	if qs._result_cache is not None ,	if qs . _result_cache is not None :
8311	for every item in qu append item.pk to a list , substitute resulting list for value under f.name key of the data dictionary .	data [ f . name ] = [ item . pk for item in qs ]
8312	if not ,	else :
8313	call the method qs.values_list with 2 arguments : string STR0 and flat set to boolean True , put the results in a list , substitute the result for value under the f.name key of data dictionary .	data [ f . name ] = list ( qs . values_list ( STR0 , flat = True ) )
8314	if not ,	else :
8315	call the method f.value_from_object with an argument instance , substitute the result for value under the f.name key of the data dictionary .	data [ f . name ] = f . value_from_object ( instance )
8316	return data .	return data
8317	define the function fields_for_model with 9 arguments : model , fields set to None , exclude set to None , widgets set to None ,	def fields_for_model ( model , fields = None , exclude = None , widgets = None , formfield_callback = None , localized_fields = None , labels = None , help_texts = None , error_messages = None ) :
8318	field_list is an empty list .	field_list = [ ]
8319	ignored is an empty list .	ignored = [ ]
8320	substitute model._meta for opts .	opts = model . _meta
8321	from django.db.models.fields import Field as ModelField .	from django . db . models . fields import Field as ModelField
8322	if f is an instance of ModelFiled , for every f in opts.virtual_fields , append f to a list , substitute the resulting list for sortable_virtual_fields .	sortable_virtual_fields = [ f for f in opts . virtual_fields if isinstance ( f , ModelField ) ]
8323	concatenate opts.concrete_fields , sortable_virtual_fields and opts.many_to_many , for every f in sorted result ,	for f in sorted ( opts . concrete_fields + sortable_virtual_fields + opts . many_to_many ) :
8324	get STR0 attribute from object f , if it doesnt exists or its true ,	if not getattr ( f , STR0 , False ) :
8325	skip this loop iteration .	continue
8326	if fields is not None and f.name is not contained in fields ,	if fields is not None and f . name not in fields :
8327	skip this loop iteration .	continue
8328	if exclude is true and f.name is contained in exclude ,	if exclude and f . name in exclude :
8329	skip this loop iteration .	continue
8330	kwargs is an empty dictionary ,	kwargs = { }
8331	if widgets is true and f.name is contained in widgets ,	if widgets and f . name in widgets :
8332	substitute value under the f.name key of the widgets dictionary for value under the STR0 key of kwargs dictionary .	kwargs [ STR0 ] = widgets [ f . name ]
8333	if localized_fields equals ALL_FIELDS , or if localized_fields is true and f.name is contained in localized_fields ,	if localized_fields == ALL_FIELDS or ( localized_fields and f . name in localized_fields ) :
8334	value under STR0 key of kwargs dictionary is boolean True .	kwargs [ STR0 ] = True
8335	if labels is true and f.name is contained in labels ,	if labels and f . name in labels :
8336	substitute value under the f.name key of the labels dictionary for value under the STR0 key of kwargs dictionary .	kwargs [ STR0 ] = labels [ f . name ]
8337	if help_texts is true and f.name is contained in help_texts ,	if help_texts and f . name in help_texts :
8338	substitute value under the f.name key of the help_texts dictionary for value under the STR0 key of kwargs dictionary .	kwargs [ STR0 ] = help_texts [ f . name ]
8339	if error_messages is true and f.name is contained in error_messages ,	if error_messages and f . name in error_messages :
8340	substitute value under the f.name key of the error_messages dictionary for value under the STR0 key of kwargs dictionary .	kwargs [ STR0 ] = error_messages [ f . name ]
8341	if formfield_callback is None ,	if formfield_callback is None :
8342	call the method f.formfield with an argument , unpacked dictionary kwargs , substitute the result for formfield .	formfield = f . formfield ( ** kwargs )
8343	otherwise if formfield_callback is not callable object ,	elif not callable ( formfield_callback ) :
8344	raise an TypeError with an string STR0 .	raise TypeError ( STR0 )
8345	if not ,	else :
8346	call the method formfield_callback with 2 arguments : f and unpacked dictionary kwargs , substitute the result for formfield .	formfield = formfield_callback ( f , ** kwargs )
8347	if formfield is true ,	if formfield :
8348	append a tuple with 2 elements : f.name and formfield to field_list .	field_list . append ( ( f . name , formfield ) )
8349	if not ,	else :
8350	append f.name to ignored list .	ignored . append ( f . name )
8351	field_dict is an instance of OrderedDict class , created with an argument field_list .	field_dict = OrderedDict ( field_list )
8352	if fields is true ,	if fields :
8353	for every f in fields , if exclude is false , or if exclude is true and f is not contained in exclude , and only if f is not in ignored , append to list , a tuple with 2 elements : f and value under the f key of field_dict dictionary , use the resulting list as an argument , for the creation of the instance of OrderedDict class , substitute it for field_dict .	field_dict = OrderedDict ( [ ( f , field_dict . get ( f ) ) for f in fields if ( ( not exclude ) or ( exclude and f not in exclude ) ) and ( f not in ignored ) ] )
8354	return field_dict .	return field_dict
8355	derive the class ModelFormOptions from object base class .	class ModelFormOptions ( object ) :
8356	define the method __init__ with arguments : self and options set to None .	def __init__ ( self , options = None ) :
8357	get STR0 attribute from the options object , if it exists substitute it for self.model , if not self.model is None .	self . model = getattr ( options , STR0 , None )
8358	get STR0 attribute from the options object , if it exists substitute it for self.fields , if not self.fields is None .	self . fields = getattr ( options , STR0 , None )
8359	get STR0 attribute from the options object , if it exists substitute it for self.exclude , if not self.exclude is None .	self . exclude = getattr ( options , STR0 , None )
8360	get STR0 attribute from the options object , if it exists substitute it for self.widgets , if not self.widgets is None .	self . widgets = getattr ( options , STR0 , None )
8361	get STR0 attribute from the options object , if it exists substitute it for self.localized_fields , if not self.localized_fields is None .	self . localized_fields = getattr ( options , STR0 , None )
8362	get STR0 attribute from the options object , if it exists substitute it for self.labels , if not self.labels is None .	self . labels = getattr ( options , STR0 , None )
8363	get STR0 attribute from the options object , if it exists substitute it for self.help_texts , if not self.help_texts is None .	self . help_texts = getattr ( options , STR0 , None )
8364	get STR0 attribute from the options object , if it exists substitute it for self.error_messages , if not self.error_messages is None .	self . error_messages = getattr ( options , STR0 , None )
8365	derive the class ModelFormMetaclass from the DeclarativeFieldsMetaclass base class .	class ModelFormMetaclass ( DeclarativeFieldsMetaclass ) :
8366	define the method __new__ with 4 arguments : mcs , name , bases and attrs .	def __new__ ( mcs , name , bases , attrs ) :
8367	remove entry under the STR0 key of the attrs dictionary , if it exists substitute if for formfield_callback , if not formfield_callback is None .	formfield_callback = attrs . pop ( STR0 , None )
8368	call the method __new__ from the base class of the class ModelFormMetaclass , with 4 arguments : mcs , name , bases and attrs , substitute the result for new_class .	new_class = super ( ModelFormMetaclass , mcs ) . __new__ ( mcs , name , bases , attrs )
8369	if bases equals a tuple with an element : class BaseModelForm .	if bases == ( BaseModelForm , ) :
8370	return new_class .	return new_class
8371	instantiate class ModelFormOptions with argument : attribute STR0 of the new_class object . if it exists or None , if not , assign the result to opts and new_class._meta .	opts = new_class . _meta = ModelFormOptions ( getattr ( new_class , STR0 , None ) )
8372	for every opt in list containing 3 elements : strings STR0 , STR1 and STR2 ,	for opt in [ STR0 , STR1 , STR2 ] :
8373	get opt attribute of the opts object , substitute it for value .	value = getattr ( opts , opt )
8374	if value is an instance of six.string_types and value is not equal to ALL_FIELDS ,	if isinstance ( value , six . string_types ) and value != ALL_FIELDS :
8375	msg is a string STR0 , where STR1 is replaced , with new_class.__name__ , STR2 is replaced with opt and STR3 is replaced with value .	msg = ( STR0 % { STR1 : new_class . __name__ , STR2 : opt , STR3 : value , } )
8376	raise an TypeError exception with an argument msg .	raise TypeError ( msg )
8377	if opts.model is true ,	if opts . model :
8378	if opts.fields is None and opts.exclude is None ,	if opts . fields is None and opts . exclude is None :
8379	raise an ImproperlyConfigured exception with an argument string STR0or the STR1 attribute is prohibited ; form % s needs updating . `` , where STR2 is replaced with name .	raise ImproperlyConfigured ( STR0 % name )
8380	if opts.fields equals ALL_FIELDS ,	if opts . fields == ALL_FIELDS :
8381	opts.fields is None .	opts . fields = None
8382	call the function fields_for_model with 9 arguments : opts.model , opts.fields , opts.exclude , opts.widgets , formfield_callback , opts.localized_fields , opts.labels , opts.help_texts and opts.error_messages , substitute the result for fields .	fields = fields_for_model ( opts . model , opts . fields , opts . exclude , opts . widgets , formfield_callback , opts . localized_fields , opts . labels , opts . help_texts , opts . error_messages )
8383	for every k and v in return value of the function six.iteritems called with an argument fields , if n is false , append it to a list , substitute the resulting list for none_model_fields .	none_model_fields = [ k for k , v in six . iteritems ( fields ) if not v ]
8384	missing_fields is difference between set containing none_model_fields and set containing result of the method , new_class.declared_fields.keys .	missing_fields = ( set ( none_model_fields ) - set ( new_class . declared_fields . keys ( ) ) )
8385	if missing_fields is true ,	if missing_fields :
8386	message is an string STR0 .	message = STR0
8387	join missing_fields into a string separated by string STR0 , use it and opts.model.__name__ to format message , substitute the result for message .	message = message % ( STR0 . join ( missing_fields ) , opts . model . __name__ )
8388	raise an FieldError exception with an argument message .	raise FieldError ( message )
8389	update fields dictionary with new_class.declared_fields .	fields . update ( new_class . declared_fields )
8390	if not ,	else :
8391	substitute new_class.declared_fields for fields .	fields = new_class . declared_fields
8392	substitute fields for new_class.base_fields .	new_class . base_fields = fields
8393	return new_class .	return new_class
8394	derive the class BaseModelForm from the BaseForm base class .	class BaseModelForm ( BaseForm ) :
8395	define the method __init__ with 10 arguments : self , data set to None , files set to None , auto_id set to string STR0 , prefix set to None , initial set to None , error_class set to ErrorList , label_suffix set to None , empty_permitted set to boolean False , instance set to None .	def __init__ ( self , data = None , files = None , auto_id = STR0 , prefix = None , initial = None , error_class = ErrorList , label_suffix = None , empty_permitted = False , instance = None ) :
8396	substitute self._meta for opts .	opts = self . _meta
8397	if opts.model is None .	if opts . model is None :
8398	raise an ValueError with an argument string STR0 .	raise ValueError ( STR0 )
8399	if instance is None ,	if instance is None :
8400	call the method opts.model , substitute the result for self.instance .	self . instance = opts . model ( )
8401	object_data is an empty dictionary .	object_data = { }
8402	if not ,	else :
8403	substitute instance for self.instance .	self . instance = instance
8404	call the method model_to_dict with 3 arguments : instance , opts.fields , opts.exclude and substitute the result for object_data .	object_data = model_to_dict ( instance , opts . fields , opts . exclude )
8405	if initial is not None ,	if initial is not None :
8406	update object_data dictionary with initial .	object_data . update ( initial )
8407	self._validate_unique is boolean False .	self . _validate_unique = False
8408	call the method __init__ from the base class of the class BaseModelForm , with 8 arguments : data , files , auto_id , prefix , object_data , error_class , label_suffix and empty_permitted .	super ( BaseModelForm , self ) . __init__ ( data , files , auto_id , prefix , object_data , error_class , label_suffix , empty_permitted )
8409	for every field_name in self.fields ,	for field_name in self . fields :
8410	substitute value under the field_name key of the self.fields dictionary for formfield .	formfield = self . fields [ field_name ]
8411	if formfield has an attribute STR0 ,	if hasattr ( formfield , STR0 ) :
8412	substitute formfield.limit_choices_to for limit_choices_to .	limit_choices_to = formfield . limit_choices_to
8413	if limit_choices_to is not None ,	if limit_choices_to is not None :
8414	if limit_choices_to is callable object ,	if callable ( limit_choices_to ) :
8415	call the function limit_choices_to , substitute the result for limit_choices_to .	limit_choices_to = limit_choices_to ( )
8416	call the method formfield.queryset.complex_filter with an argument limit_choices_to , substitute the result for formfield.queryset .	formfield . queryset = formfield . queryset . complex_filter ( limit_choices_to )
8417	define the method _get_validation_exclusions with an argument self .	def _get_validation_exclusions ( self ) :
8418	exclude is an empty list .	exclude = [ ]
8419	for every f in self.instance._meta.fields ,	for f in self . instance . _meta . fields :
8420	substitute f.name for field .	field = f . name
8421	if field is not contained in self.fields ,	if field not in self . fields :
8422	append f.name to exclude .	exclude . append ( f . name )
8423	otherwise if self._meta.fields is true and field is not contained in self._meta.fields ,	elif self . _meta . fields and field not in self . _meta . fields :
8424	append f.name to exclude .	exclude . append ( f . name )
8425	otherwise if self._meta.exclude is true and field is not contained in self._meta.exclude ,	elif self . _meta . exclude and field in self . _meta . exclude :
8426	append f.name to exclude .	exclude . append ( f . name )
8427	otherwise if field is contained in the result of the call to the method self._errors.keys ,	elif field in self . _errors . keys ( ) :
8428	append f.name to exclude .	exclude . append ( f . name )
8429	if not ,	else :
8430	substitute value under the field key of the self.fields dictionary for form_field .	form_field = self . fields [ field ]
8431	get the value under the field key of the self.cleaned_data dictionary , if it exists substitute it for field_value , if not field_value is None .	field_value = self . cleaned_data . get ( field , None )
8432	if f.blank is false and form_field.required is false and field_value is contained in form_field.empty_values ,	if not f . blank and not form_field . required and field_value in form_field . empty_values :
8433	append f.name to exclude .	exclude . append ( f . name )
8434	return exclude .	return exclude
8435	define the method clean with an argument self .	def clean ( self ) :
8436	self._validate_unique is boolean True .	self . _validate_unique = True
8437	return self.cleaned_data .	return self . cleaned_data
8438	define the method _update_errors with 2 arguments : self and errors .	def _update_errors ( self , errors ) :
8439	substitute self._meta for opts .	opts = self . _meta
8440	call the function errors.error_dict.items , for every field and messages in the result ,	for field , messages in errors . error_dict . items ( ) :
8441	if field equals NON_FIELD_ERRORS and opts.error_messages is true and NON_FIELD_ERRORS is contained in opts.error_messages ,	if ( field == NON_FIELD_ERRORS and opts . error_messages and NON_FIELD_ERRORS in opts . error_messages ) :
8442	substitute value under the NON_FIELD_ERRORS key of opts.error_messages dictionary for error_messages .	error_messages = opts . error_messages [ NON_FIELD_ERRORS ]
8443	otherwise if field is contained in self.fields ,	elif field in self . fields :
8444	get the value under the field key of self.fields dictionary , substitute error_messages field of the result for error_messages .	error_messages = self . fields [ field ] . error_messages
8445	if not ,	else :
8446	skip this loop iteration .	continue
8447	for every message in messages ,	for message in messages :
8448	if message is an instance of ValidationError class and message.code is contained in error_messages ,	if ( isinstance ( message , ValidationError ) and message . code in error_messages ) :
8449	substitute error_messages under the message.code key of error_messages dictionary for message.message .	message . message = error_messages [ message . code ]
8450	call the method self.add_error with 2 arguments : None and errors .	self . add_error ( None , errors )
8451	define the method _post_clean with an argument self .	def _post_clean ( self ) :
8452	substitute self._meta for opts .	opts = self . _meta
8453	call the method self._get_validation_exclusions , substitute the result for exclude .	exclude = self . _get_validation_exclusions ( )
8454	convert exclude elements to list , substitute it for construct_instance_exclude .	construct_instance_exclude = list ( exclude )
8455	call the method self.fields.items , for every name and field in result ,	for name , field in self . fields . items ( ) :
8456	if field is an instance of InlineForeignKeyField class ,	if isinstance ( field , InlineForeignKeyField ) :
8457	if value under the name key of self.cleaned_data dictionary is not None ,	if self . cleaned_data . get ( name ) is not None and self . cleaned_data [ name ] . _state . adding :
8458	and field _state.adding of value under the name key of self.cleaned_data dictionary is true , append name to construct_instance_exclude list .	construct_instance_exclude . append ( name )
8459	append name to exclude .	exclude . append ( name )
8460	call the function construct_instance with 4 arguments : self , self.instance , opts.fields and construct_instance_exclude , substitute the result for self.instance .	self . instance = construct_instance ( self , self . instance , opts . fields , construct_instance_exclude )
8461	try ,	try :
8462	call the method self.instance.full_clean with 2 arguments : exclude set to exclude and validate_unique set to boolean False .	self . instance . full_clean ( exclude = exclude , validate_unique = False )
8463	if ValidationError , renamed to e , exception is caught ,	except ValidationError as e :
8464	call the method self._update_errors with an argument e .	self . _update_errors ( e )
8465	if self._validate_unique is true ,	if self . _validate_unique :
8466	call the method self.validate_unique .	self . validate_unique ( )
8467	define the method validate_unique with an argument self .	def validate_unique ( self ) :
8468	call the method self._get_validation_exclusions , substitute the result for exclude .	exclude = self . _get_validation_exclusions ( )
8469	try ,	try :
8470	call the method self.instance.validate_unique with an argument exclude set to exclude .	self . instance . validate_unique ( exclude = exclude )
8471	if ValidationError , renamed to e , exception is caught ,	except ValidationError as e :
8472	call the method self._update_errors with an argument e .	self . _update_errors ( e )
8473	define the method save with 2 arguments : self and commit set to boolean True .	def save ( self , commit = True ) :
8474	if self.instance.pk is None ,	if self . instance . pk is None :
8475	fail_message is a string STR0 .	fail_message = STR0
8476	if not ,	else :
8477	fail_message is a string changed ' .	fail_message = STR0
8478	call the function with 7 arguments : self , self.instance , self._meta.fields , fail_message , commit , self._meta.exclude , and construct as boolean False , return the result .	return save_instance ( self , self . instance , self . _meta . fields , fail_message , commit , self . _meta . exclude , construct = False )
8479	save.alters_data is boolean True .	save . alters_data = True
8480	derive the class ModelForm from the base class in the return value of the method six.with_metaclass , called with 2 arguments : ModelFormMetaclass and BaseModelForm .	class ModelForm ( six . with_metaclass ( ModelFormMetaclass , BaseModelForm ) ) :
8481	do nothing .	pass
8482	define the function modelform_factory with 10 arguments : model , form set to ModelForm , fields set to None , exclude set to None ,	def modelform_factory ( model , form = ModelForm , fields = None , exclude = None , formfield_callback = None , widgets = None , localized_fields = None , labels = None , help_texts = None , error_messages = None ) :
8483	attrs is a dictionary with model for STR0 .	attrs = { STR0 : model }
8484	if fields is not None ,	if fields is not None :
8485	substitute fields for value under the STR0 key of attrs dictionary .	attrs [ STR0 ] = fields
8486	if exclude is not None ,	if exclude is not None :
8487	substitute exclude for value under the STR0 key of attrs dictionary .	attrs [ STR0 ] = exclude
8488	if widgets is not None ,	if widgets is not None :
8489	substitute widgets for value under the STR0 key of attrs dictionary .	attrs [ STR0 ] = widgets
8490	if localized_fields is not None ,	if localized_fields is not None :
8491	substitute localized_fields for value under the STR0 key of attrs dictionary .	attrs [ STR0 ] = localized_fields
8492	if labels is not None ,	if labels is not None :
8493	substitute labels for value under the STR0 key of attrs dictionary .	attrs [ STR0 ] = labels
8494	if help_texts is not None ,	if help_texts is not None :
8495	substitute help_texts for value under the STR0 key of attrs dictionary .	attrs [ STR0 ] = help_texts
8496	if error_messages is not None ,	if error_messages is not None :
8497	substitute error_messages for value under the STR0 key of attrs dictionary .	attrs [ STR0 ] = error_messages
8498	parent is a tuple with 1 element , object .	parent = ( object , )
8499	if form has an attribute STR0 ,	if hasattr ( form , STR0 ) :
8500	parent is a tuple with 2 arguments : form.Meta and object .	parent = ( form . Meta , object )
8501	Meta is an instance of class with name STR0 , parent base class and fields attrs .	Meta = type ( str ( STR0 ) , parent , attrs )
8502	append string STR0 to model.__name__ , substitute the result for class_name .	class_name = model . __name__ + str ( STR0 )
8503	form_class_attrs is a dictionary with 2 entries : Meta for STR0 and formfield_callback for STR1 .	form_class_attrs = { STR0 : Meta , STR1 : formfield_callback }
8504	if STR0 attribute of Meta object is None and STR1 attribute of Meta object is None ,	if ( getattr ( Meta , STR0 , None ) is None and getattr ( Meta , STR1 , None ) is None ) :
8505	raise an ImproperlyConfigured with an argument string STR0	raise ImproperlyConfigured ( STR0 )
8506	get the type of form object , return an instance of resulting class created with 3 arguments : class_name , tuple with an element form , and form_class_attrs .	return type ( form ) ( class_name , ( form , ) , form_class_attrs )
8507	derive the class BaseModelFormSet from the BaseFormSet base class .	class BaseModelFormSet ( BaseFormSet ) :
8508	model is None .	model = None
8509	define the method __init__ with 7 arguments : self , data set to None , files set to None , auto_id set to string STR0 , prefix set to None , queryset set to None and unpacked dictionary kwargs .	def __init__ ( self , data = None , files = None , auto_id = STR0 , prefix = None , queryset = None , ** kwargs ) :
8510	substitute queryset for self.queryset .	self . queryset = queryset
8511	remove entry under STR0 key of the kwargs dictionary , substitute it for self.initial_extra if it exists , if not self.initial_extra is None .	self . initial_extra = kwargs . pop ( STR0 , None )
8512	defaults is a dictionary with 4 entries : data for STR0 , files for STR1 , auto_id for STR2 and prefix for STR3 .	defaults = { STR0 : data , STR1 : files , STR2 : auto_id , STR3 : prefix }
8513	update defaults dictionary with kwargs .	defaults . update ( kwargs )
8514	call the method __init__ from the base class of the class BaseModelFormSet , with an argument unpacked dictionary defaults .	super ( BaseModelFormSet , self ) . __init__ ( ** defaults )
8515	define the method initial_form_count with an argument self .	def initial_form_count ( self ) :
8516	if self.data and self.files are both False ,	if not ( self . data or self . files ) :
8517	call the method self.get_queryset , return the length of the result .	return len ( self . get_queryset ( ) )
8518	call the method initial_form_count from the base class of the class BaseModelFormSet , return the result .	return super ( BaseModelFormSet , self ) . initial_form_count ( )
8519	define the method _existing_object with 2 arguments : self and pk .	def _existing_object ( self , pk ) :
8520	if self has an attribute STR0 ,	if not hasattr ( self , STR0 ) :
8521	call the function dict with an argument tuple with 2 elements : o.pk and o , for every o in result of the method self.get_queryset , substitute the result for self._object_dict .	self . _object_dict = dict ( ( o . pk , o ) for o in self . get_queryset ( ) )
8522	return the value under the pk key of self._object_dict dictionary .	return self . _object_dict . get ( pk )
8523	define the method _get_to_python with 2 arguments : self and field .	def _get_to_python ( self , field ) :
8524	while field.rel is not None ,	while field . rel is not None :
8525	call the method field.rel.get_related_field , substitute the result for field .	field = field . rel . get_related_field ( )
8526	return field.to_python .	return field . to_python
8527	define the method _construct_form with 3 arguments : self , i and unpacked dictionary kwargs .	def _construct_form ( self , i , ** kwargs ) :
8528	if self.is_bound is true and i is smaller than self.initial_form_count ,	if self . is_bound and i < self . initial_form_count ( ) :
8529	pk_key is a string STR0 , where STR1 is replaced with : result of the method self.add_prefix called with an argument i , and self.model._meta.pk.name .	pk_key = STR0 % ( self . add_prefix ( i ) , self . model . _meta . pk . name )
8530	substitute the value under the pk_key key of the self.data dictionary for pk .	pk = self . data [ pk_key ]
8531	substitute self.model._meta.pk for pk_field .	pk_field = self . model . _meta . pk
8532	call the method self._get_to_python with an argument pk_field , substitute the result for to_python .	to_python = self . _get_to_python ( pk_field )
8533	call the function to_python with an argument pk , substitute the result for pk .	pk = to_python ( pk )
8534	call the method self._existing_object with an argument pk , substitute the result for value under the STR0 key of kwargs .	kwargs [ STR0 ] = self . _existing_object ( pk )
8535	if i is smaller than result of the method self.initial_form_count and key STR0 is not contained in kwargs ,	if i < self . initial_form_count ( ) and STR0 not in kwargs :
8536	call the method self.get_queryset , substitute i-th element of the result for value under the STR0 key of kwargs dictionary .	kwargs [ STR0 ] = self . get_queryset ( ) [ i ]
8537	if i is greater or equal to the result of the method self.initial_form_count and self.initial_extra is true ,	if i >= self . initial_form_count ( ) and self . initial_extra :
8538	try ,	try :
8539	subtract result of the method self.initial_form_count from i , use the result as an index to get the element from self.initial_extra , substitute it for value under the STR0 key of kwargs dictionary .	kwargs [ STR0 ] = self . initial_extra [ i - self . initial_form_count ( ) ]
8540	if IndexError exception is caught ,	except IndexError :
8541	do nothing .	pass
8542	call the method _construct_form from the base class of the class BaseModelFormSet , with 2 arguments : i and unpacked dictionary kwargs .	return super ( BaseModelFormSet , self ) . _construct_form ( i , ** kwargs )
8543	define the method get_queryset with an argument self .	def get_queryset ( self ) :
8544	if self doesnt have STR0 attribute ,	if not hasattr ( self , STR0 ) :
8545	if self.queryset is not None ,	if self . queryset is not None :
8546	substitute self.queryset for qs .	qs = self . queryset
8547	if not ,	else :
8548	call the method self.model._default_manager.get_queryset with an argument qs .	qs = self . model . _default_manager . get_queryset ( )
8549	if qs.ordered is false ,	if not qs . ordered :
8550	call the method qs.order_by with argument self.model._meta.pk.name , substitute the result for qs .	qs = qs . order_by ( self . model . _meta . pk . name )
8551	substitute qs for self._queryset .	self . _queryset = qs
8552	return self._queryset .	return self . _queryset
8553	define the method save_new with 3 arguments : self , form and commit set to boolean True .	def save_new ( self , form , commit = True ) :
8554	call the method form.save with an argument commit as commit , return the result .	return form . save ( commit = commit )
8555	define the method save_existing with 4 arguments : self , form , instance and commit set to boolean True .	def save_existing ( self , form , instance , commit = True ) :
8556	call the method form.save with an argument commit as commit , return the result .	return form . save ( commit = commit )
8557	define the method save with 2 arguments : self and commit set to boolean True .	def save ( self , commit = True ) :
8558	if commit is true ,	if not commit :
8559	self.saved_forms is an empty list .	self . saved_forms = [ ]
8560	define the function save_m2m .	def save_m2m ( ) :
8561	for every form in self.saved_forms ,	for form in self . saved_forms :
8562	call the function form.save_m2m .	form . save_m2m ( )
8563	substitute save_m2m for self.save_m2m .	self . save_m2m = save_m2m
8564	sum results of method self.save_existing_objects called with an argument commit and of method self.save_new_objects , called with an argument commit , return the result .	return self . save_existing_objects ( commit ) + self . save_new_objects ( commit )
8565	save.alters_data is boolean True .	save . alters_data = True
8566	define the method clean with an argument self .	def clean ( self ) :
8567	call the method self.validate_unique .	self . validate_unique ( )
8568	define the method validate_unique with an argument self .	def validate_unique ( self ) :
8569	all_unique_checks is an empty set .	all_unique_checks = set ( )
8570	all_date_checks is an empty set .	all_date_checks = set ( )
8571	substitute self.deleted_forms for forms_to_delete .	forms_to_delete = self . deleted_forms
8572	for every form in self.forms append form to a list , if function form.is_valid evaluates to true , and form is not contained in forms_to_delete , substitute the resulting list for valid_forms .	valid_forms = [ form for form in self . forms if form . is_valid ( ) and form not in forms_to_delete ]
8573	for every form in valid_forms ,	for form in valid_forms :
8574	call the method form._get_validation_exclusions , substitute the result for exclude .	exclude = form . _get_validation_exclusions ( )
8575	call the method form.instance._get_unique_checks with an argument exclude as exclude , substitute the result for unique_checks , and date_checks , respectively .	unique_checks , date_checks = form . instance . _get_unique_checks ( exclude = exclude )
8576	all_unique_checks is union of all_unique_checks set and unique_checks set .	all_unique_checks = all_unique_checks . union ( set ( unique_checks ) )
8577	all_date_checks is union of all_date_checks set and date_checks set .	all_date_checks = all_date_checks . union ( set ( date_checks ) )
8578	errors is an empty list .	errors = [ ]
8579	for every uclass , unique_check in all_unique_checks ,	for uclass , unique_check in all_unique_checks :
8580	seen_data is an empty set .	seen_data = set ( )
8581	for every form in valid_forms ,	for form in valid_forms :
8582	row_data is an generator object that returns value under the field key of form.cleaned_data dictionary , for every field in unique_check , if field is contained in form.cleaned_data .	row_data = ( form . cleaned_data [ field ] for field in unique_check if field in form . cleaned_data )
8583	create a generator that for every d in row_data , if d has an STR0 attribute , returns the result of the call the method d._get_pk_val , if not return d , put all the generator items into a tuple row_data .	row_data = tuple ( d . _get_pk_val ( ) if hasattr ( d , STR0 ) else d for d in row_data )
8584	if row_data is true and None is not contained in row_data ,	if row_data and None not in row_data :
8585	if row_data is contained in seen_data ,	if row_data in seen_data :
8586	call the method self.get_unique_error_message with an argument unique_check , append the result to errors .	errors . append ( self . get_unique_error_message ( unique_check ) )
8587	call the method self.error_class with an argument list with a element : result of the method self.get_form_error , substitute the result for value under the NON_FIELD_ERRORS key of the form._errors dictionary .	form . _errors [ NON_FIELD_ERRORS ] = self . error_class ( [ self . get_form_error ( ) ] )
8588	for every field in unique_check ,	for field in unique_check :
8589	if field is contained in form.cleaned_data ,	if field in form . cleaned_data :
8590	delete the form.cleaned_data dictionary entry under the field key .	del form . cleaned_data [ field ]
8591	add row_data to seen_data set .	seen_data . add ( row_data )
8592	for every date_check in all_date_checks ,	for date_check in all_date_checks :
8593	seen_data is an empty set .	seen_data = set ( )
8594	substitute date_check elements to uclass , lookup , field and unique_for , respectively .	uclass , lookup , field , unique_for = date_check
8595	for every form in valid_forms ,	for form in valid_forms :
8596	if form.cleaned_data is true and value under the field key of form.cleaned_data dictionary is not None ,	if ( form . cleaned_data and form . cleaned_data [ field ] is not None and form . cleaned_data [ unique_for ] is not None ) :
8597	and value under the unique_for key of form.cleaned_data dictionary is not None , if lookup equals a string STR0 ,	if lookup == STR0 :
8598	substitute value under the unique_for key of form.cleaned_data dictionary for date .	date = form . cleaned_data [ unique_for ]
8599	date_data is a tuple with 3 elements : date.year , date.month and date.day .	date_data = ( date . year , date . month , date . day )
8600	if not ,	else :
8601	date_data is a tuple with an entry : attribute lookup from the value under the unique_for key of the form.cleaned_data dictionary .	date_data = ( getattr ( form . cleaned_data [ unique_for ] , lookup ) , )
8602	create a tuple out of elements under the key field of the form.cleaned_data dictionary , add elements of date_data to it , substitute it for data .	data = ( form . cleaned_data [ field ] , ) + date_data
8603	if data is contained in seen_data ,	if data in seen_data :
8604	call the method self.get_date_error_message with an argument date_check , append the result to errors .	errors . append ( self . get_date_error_message ( date_check ) )
8605	call the method self.error_class with an argument list with one element , return value of the method self.get_form_error , substitute the result for the value under the NON_FIELD_ERRORS key of form._errors dictionary .	form . _errors [ NON_FIELD_ERRORS ] = self . error_class ( [ self . get_form_error ( ) ] )
8606	delete entry from form.cleaned_data dictionary under the field key .	del form . cleaned_data [ field ]
8607	add data to seen_data set .	seen_data . add ( data )
8608	if errors is true ,	if errors :
8609	raise an ValidationError exception with an argument errors .	raise ValidationError ( errors )
8610	define the method get_unique_error_message with 2 arguments : self and unique_check .	def get_unique_error_message ( self , unique_check ) :
8611	if length of unique_check equals integer 1 ,	if len ( unique_check ) == 1 :
8612	call the function ugettext with an argument string STR0 , where STR1 is replaced with first element of unique_check , return the result .	return ugettext ( STR0 ) % { STR1 : unique_check [ 0 ] , }
8613	if not ,	else :
8614	call the function ugettext with an argument string STR0 , where STR1 is replaced with return value of the get_text_list function called with 2 arguments : unique_check and return value of the function six.text_type called with return value of the function _ with an argument string STR2 , return the result .	return ugettext ( STR0 ) % { STR1 : get_text_list ( unique_check , six . text_type ( _ ( STR2 ) ) ) , }
8615	define the method get_date_error_message with 2 arguments : self and date_check .	def get_date_error_message ( self , date_check ) :
8616	call the function ugettext with an argument string STR0 , where STR1 is replaced with third element of data_check , STR2 is replaced with fourth element of date_check and STR3 is replaced with result of the function , six.text_type called with second element of date_check as an argument , return the result .	return ugettext ( STR0 ) % { STR1 : date_check [ 2 ] , STR2 : date_check [ 3 ] , STR3 : six . text_type ( date_check [ 1 ] ) , }
8617	define the method get_form_error with an argument self .	def get_form_error ( self ) :
8618	call the function ugettext with an argument string STR0 , return the result .	return ugettext ( STR0 )
8619	define the method save_existing_objects with 2 arguments : self and commit set to boolean True .	def save_existing_objects ( self , commit = True ) :
8620	self.changed_objects is an empty list .	self . changed_objects = [ ]
8621	self.deleted_objects is an empty list .	self . deleted_objects = [ ]
8622	if self.initial_forms is false ,	if not self . initial_forms :
8623	return an empty list .	return [ ]
8624	saved_instances is an empty list .	saved_instances = [ ]
8625	substitute self.deleted_forms for forms_to_delete .	forms_to_delete = self . deleted_forms
8626	for every form in self.initial_forms ,	for form in self . initial_forms :
8627	substitute form.instance for obj .	obj = form . instance
8628	if form is contained in forms_to_delete ,	if form in forms_to_delete :
8629	if obj.pk is None ,	if obj . pk is None :
8630	skip this loop iteration .	continue
8631	append obj to self.deleted_objects list .	self . deleted_objects . append ( obj )
8632	if commit is true ,	if commit :
8633	call the method obj.delete .	obj . delete ( )
8634	otherwise if form.has_changed method evaluates to true ,	elif form . has_changed ( ) :
8635	append a tuple with 2 elements : obj and form.changed_data to self.changed_objects .	self . changed_objects . append ( ( obj , form . changed_data ) )
8636	call the method self.save_existing with 3 arguments : form , obj and commit as commit , append the result to saved_instances .	saved_instances . append ( self . save_existing ( form , obj , commit = commit ) )
8637	if commit is false ,	if not commit :
8638	append form to self.saved_forms .	self . saved_forms . append ( form )
8639	return saved_instances .	return saved_instances
8640	define the method save_new_objects with 2 arguments : self and commit set to boolean True .	def save_new_objects ( self , commit = True ) :
8641	self.new_objects is an empty list .	self . new_objects = [ ]
8642	for every form in self.extra_forms ,	for form in self . extra_forms :
8643	if function form.has_changed evaluates to false ,	if not form . has_changed ( ) :
8644	skip this loop iteration .	continue
8645	if self.can_delete is true and call to the function self._should_delete_form with an argument form evaluates to true ,	if self . can_delete and self . _should_delete_form ( form ) :
8646	skip this loop iteration .	continue
8647	call the method self.save_new with 2 arguments : form and commit as commit , append the result to self.new_objects .	self . new_objects . append ( self . save_new ( form , commit = commit ) )
8648	if commit is false ,	if not commit :
8649	append form to self.saved_forms .	self . saved_forms . append ( form )
8650	return self.new_objects .	return self . new_objects
8651	define the method add_fields with 2 arguments : self , form and index .	def add_fields ( self , form , index ) :
8652	from django.db.models import AutoField , OneToOneField and ForeignKey .	from django . db . models import AutoField , OneToOneField , ForeignKey
8653	assign self.model._meta.pk to self._pk_field and pk .	self . _pk_field = pk = self . model . _meta . pk
8654	define the method pk_is_not_editable with an argument pk .	def pk_is_not_editable ( pk ) :
8655	if pk.editable is true , or pk.auto_created is true or pk is an instance of AutoField class , or if pk.rel is true ,	return ( ( not pk . editable ) or ( pk . auto_created or isinstance ( pk , AutoField ) ) or ( pk . rel and pk . rel . parent_link and pk_is_not_editable ( pk . rel . to . _meta . pk ) ) )
8656	and pk.rel.parent_link is true and function pk_is_not_editable called with an argument pk.rel.to._meta.pk evaluates to true , if function pk_is_not_editable called with an argument pk evaluates to true , or pk.name is not contained in form.fields ,	if pk_is_not_editable ( pk ) or pk . name not in form . fields :
8657	if form.is_bound is true ,	if form . is_bound :
8658	substitute form.instance.pk for pk_value .	pk_value = form . instance . pk
8659	if not ,	else :
8660	try ,	try :
8661	if index is not None ,	if index is not None :
8662	call the method self.get_queryset , substitute field pk under the result at the index index for pk_value .	pk_value = self . get_queryset ( ) [ index ] . pk
8663	if not ,	else :
8664	pk_value is None .	pk_value = None
8665	if IndexError exception is caught ,	except IndexError :
8666	pk_value is None .	pk_value = None
8667	if pk is an instance of OneToOneField or ForeignKey classes ,	if isinstance ( pk , OneToOneField ) or isinstance ( pk , ForeignKey ) :
8668	call the method pk.rel.to._default_manager.get_queryset , substitute the result for qs .	qs = pk . rel . to . _default_manager . get_queryset ( )
8669	if not ,	else :
8670	call the method self.model._default_manager.get_queryset with an argument qs .	qs = self . model . _default_manager . get_queryset ( )
8671	call the method qs.using with an argument form.instance._state.db , substitute the result for qs .	qs = qs . using ( form . instance . _state . db )
8672	if form._meta.widgets is true ,	if form . _meta . widgets :
8673	get the value under self._pk_field.name key of form._meta.widgets dictionary , if it exists substitute it for widget , if not , widget is an instance of HiddenInput class .	widget = form . _meta . widgets . get ( self . _pk_field . name , HiddenInput )
8674	if not ,	else :
8675	widget is an instance of HiddenInput class	widget = HiddenInput
8676	value under the self._pk_field.name key of form.fields dictionary is an instance of ModelChoiceField class , created with 4 arguments : qs , initial as pk_value , required as boolean False and widget as widget .	form . fields [ self . _pk_field . name ] = ModelChoiceField ( qs , initial = pk_value , required = False , widget = widget )
8677	call the method add_fields from the base class of the class BaseModelFormSet , with 2 arguments : form and index .	super ( BaseModelFormSet , self ) . add_fields ( form , index )
8678	define the function modelformset_factory with 18 arguments : model , form set to ModelForm , formfield_callback set to None ,	def modelformset_factory ( model , form = ModelForm , formfield_callback = None , formset = BaseModelFormSet , extra = 1 , can_delete = False , can_order = False , max_num = None , fields = None , exclude = None , widgets = None , validate_max = False , localized_fields = None , labels = None , help_texts = None , error_messages = None , min_num = None , validate_min = False ) :
8679	get STR0 attribute from form object , if it exists substitute it for meta , if not meta is None .	meta = getattr ( form , STR0 , None )
8680	if meta is None ,	if meta is None :
8681	meta is an instance of a class named STR0 , derived from the object base class , without any fields .	meta = type ( str ( STR0 ) , ( object , ) , { } )
8682	if STR0 attribute of meta is None , or if it doesnt exists if fields is None and if STR1 attribute of meta is None , or if it doesnt exists if exclude is None .	if ( getattr ( meta , STR0 , fields ) is None and getattr ( meta , STR1 , exclude ) is None ) :
8683	raise an ImproperlyConfigured with an argument string STR0	raise ImproperlyConfigured ( STR0 )
8684	call the function modelform_factory with 10 arguments : model , form as form , fields as fields , exclude as exclude , formfield_callback as formfield_callback , widgets as widgets , localized_fields as localized_fields , labels as labels , help_texts as help_texts and error_messages as error_messages , substitute the result for form .	form = modelform_factory ( model , form = form , fields = fields , exclude = exclude , formfield_callback = formfield_callback , widgets = widgets , localized_fields = localized_fields , labels = labels , help_texts = help_texts , error_messages = error_messages )
8685	call the function formset_factory with 10 arguments : form , formset , extra as extra , min_num as min_num , max_num as max_num , can_order as can_order , can_delete as can_delete , validate_min as validate_min , validate_max as validate_max , substitute the result for form .	FormSet = formset_factory ( form , formset , extra = extra , min_num = min_num , max_num = max_num , can_order = can_order , can_delete = can_delete , validate_min = validate_min , validate_max = validate_max )
8686	substitute model for FormSet.model .	FormSet . model = model
8687	return FormSet .	return FormSet
8688	derive the class BaseInlineFormSet from the BaseModelFormSet base class .	class BaseInlineFormSet ( BaseModelFormSet ) :
8689	define the method __init__ with 8 arguments : self , data set to None , files set to None , instance set to None , save_as_new set to boolean False , prefix set to None , queryset set to None and unpacked dictionary kwargs .	def __init__ ( self , data = None , files = None , instance = None , save_as_new = False , prefix = None , queryset = None , ** kwargs ) :
8690	if instance is None ,	if instance is None :
8691	call the method self.fk.rel.to , substitute the result for self.instance .	self . instance = self . fk . rel . to ( )
8692	if not ,	else :
8693	substitute instance for self.instance .	self . instance = instance
8694	substitute save_as_new for self.save_as_new .	self . save_as_new = save_as_new
8695	if queryset is None ,	if queryset is None :
8696	substitute self.model._default_manager for queryset .	queryset = self . model . _default_manager
8697	if self.instance.pk is not None ,	if self . instance . pk is not None :
8698	call the method queryset.filter with an argument unpacked dictionary containing self.instance for self.fk.name , substitute the result for qs .	qs = queryset . filter ( ** { self . fk . name : self . instance } )
8699	if not ,	else :
8700	call the method queryset.none , substitute it for qs .	qs = queryset . none ( )
8701	call the method __init__ from the base class of the class BaseInlineFormSet , with 5 arguments : data , files , prefix set to prefix , queryset set to qs and unpacked dictionary kwargs .	super ( BaseInlineFormSet , self ) . __init__ ( data , files , prefix = prefix , queryset = qs , ** kwargs )
8702	define the method initial_form_count with an argument self .	def initial_form_count ( self ) :
8703	if self.save_as_new is true ,	if self . save_as_new :
8704	return integer 0 .	return 0
8705	call the method initial_form_count from the base class of the class BaseInlineFormSet , return the result .	return super ( BaseInlineFormSet , self ) . initial_form_count ( )
8706	define the method _construct_form with 3 arguments : self , i and unpacked dictionary kwargs .	def _construct_form ( self , i , ** kwargs ) :
8707	call the method _construct_form from the base class of the class BaseInlineFormSet , with 2 arguments : i , and unpacked dictionary kwargs , substitute the result for form .	form = super ( BaseInlineFormSet , self ) . _construct_form ( i , ** kwargs )
8708	if self.save_as_new is true ,	if self . save_as_new :
8709	call the method form.add_prefix with an argument self._pk_field.name , use the result as an key to get the value of the form.data dictionary , assign it value None .	form . data [ form . add_prefix ( self . _pk_field . name ) ] = None
8710	call the method form.add_prefix with an argument self.fk.name , use the result as an key to get the value of the form.data dictionary , assign it value None .	form . data [ form . add_prefix ( self . fk . name ) ] = None
8711	use return value of the self.fk.get_attname as the name of the attribute of form.instance object to set , set it to self.instance.pk .	setattr ( form . instance , self . fk . get_attname ( ) , self . instance . pk )
8712	return form .	return form
8713	classmethod decorator ,	@ classmethod
8714	define the method get_default_prefix with an argument cls .	def get_default_prefix ( cls ) :
8715	from django.db.models.fields.related import RelatedObject into default namespace .	from django . db . models . fields . related import RelatedObject
8716	instantiate RelatedObject class with 3 arguments : cls.fk.rel.to , cls.model and cls.fk , call the method get_accessor_name on the result , substitute all occurrences of STR0 in the result with an empty string , return it .	return RelatedObject ( cls . fk . rel . to , cls . model , cls . fk ) . get_accessor_name ( ) . replace ( STR0 , STR )
8717	define the method save_new with 3 arguments : self , form and commit set to boolean True .	def save_new ( self , form , commit = True ) :
8718	call the method form.save , with an argument commit set to boolean False , substitute the result for obj .	obj = form . save ( commit = False )
8719	get self.instance	pk_value = getattr ( self . instance , self . fk . rel . field_name )
8720	get attribute STR0 of the pk_value object , if it doesnt exists use pk_value , set to it self.fk.get_attname return value attribute , of the obj object .	setattr ( obj , self . fk . get_attname ( ) , getattr ( pk_value , STR0 , pk_value ) )
8721	if commit is true ,	if commit :
8722	call the method obj.save .	obj . save ( )
8723	if commit is true and form has an attribute STR0 ,	if commit and hasattr ( form , STR0 ) :
8724	call the method form.save_m2m .	form . save_m2m ( )
8725	return obj .	return obj
8726	define the method add_fields with 3 arguments : self , form and index .	def add_fields ( self , form , index ) :
8727	call the method add_fields from the base class of the class BaseInlineFormSet , with 2 arguments : form and index .	super ( BaseInlineFormSet , self ) . add_fields ( form , index )
8728	if self._pk_field equals self.fk ,	if self . _pk_field == self . fk :
8729	substitute self._pk_field.name for name .	name = self . _pk_field . name
8730	kwargs is a dictionary with boolean True for STR0 .	kwargs = { STR0 : True }
8731	if not ,	else :
8732	substitute self.fk.name for name .	name = self . fk . name
8733	kwargs is a dictionary with an entry : attribute STR0 of the object under the name key of the form.fields dictionary for STR1 , if it doesnt exists return value of the function capfirst with an argument self.fk.verbose_name for STR2 .	kwargs = { STR0 : getattr ( form . fields . get ( name ) , STR1 , capfirst ( self . fk . verbose_name ) ) }
8734	if self.fk.rel.field_name is not equal to self.fk.rel.to._meta.pk.name ,	if self . fk . rel . field_name != self . fk . rel . to . _meta . pk . name :
8735	substitute self.fk.rel.field_name for value under the STR0 key of the kwargs dictionary .	kwargs [ STR0 ] = self . fk . rel . field_name
8736	value under the name key of the form.fields dictionary is an instance of InlineForeignKeyField created with 2 arguments : self.instance and unpacked dictionary kwargs .	form . fields [ name ] = InlineForeignKeyField ( self . instance , ** kwargs )
8737	if form._meta.fields is true ,	if form . _meta . fields :
8738	if form._meta.fields is an instance of tuple type ,	if isinstance ( form . _meta . fields , tuple ) :
8739	form._meta.fields is a list created out of form._meta.fields elements .	form . _meta . fields = list ( form . _meta . fields )
8740	append self.fk.name to form._meta.fields .	form . _meta . fields . append ( self . fk . name )
8741	define the method get_unique_error_message with 2 arguments : self and unique_check .	def get_unique_error_message ( self , unique_check ) :
8742	unique_check is a list with elements field , for every field in unique_check if field is not equal to self.fk.name .	unique_check = [ field for field in unique_check if field != self . fk . name ]
8743	call the method get_unique_error_message from the base class of the class BaseInlineFormSet , with an argument unique_check , return the result .	return super ( BaseInlineFormSet , self ) . get_unique_error_message ( unique_check )
8744	define the function _get_foreign_key with 4 arguments : parent_model , model , fk_name set to None and can_fail set to boolean False .	def _get_foreign_key ( parent_model , model , fk_name = None , can_fail = False ) :
8745	from django.db.models import ForeignKey .	from django . db . models import ForeignKey
8746	substitute model._meta for opts .	opts = model . _meta
8747	if fk_name is true ,	if fk_name :
8748	fks_to_parent is a list containing f , for every f in opts.fields if f.name equals fk_name .	fks_to_parent = [ f for f in opts . fields if f . name == fk_name ]
8749	if length of fks_to_parent equals integer 1 .	if len ( fks_to_parent ) == 1 :
8750	substitute first element of fks_to_parent for fk .	fk = fks_to_parent [ 0 ]
8751	if fk is not an instance of ForeignKey class , or fk.rel.to is not equal to parent_model , and fk.rel.to is not contained in result of the call to the method parent_model._meta.get_parent_list .	if not isinstance ( fk , ForeignKey ) or ( fk . rel . to != parent_model and fk . rel . to not in parent_model . _meta . get_parent_list ( ) ) :
8752	raise an ValueError with an argument string STR0 , where STR1 is replaced with , fk_name , parent_model._meta.app_label and parent_model._meta.object_name , respectively .	raise ValueError ( STR0 % ( fk_name , parent_model . _meta . app_label , parent_model . _meta . object_name ) )
8753	otherwise if length of fks_to_parent is zero ,	elif len ( fks_to_parent ) == 0 :
8754	raise an ValueError with an argument string STR0 , where STR1 is replaced with , model._meta.app_label , model._meta.object_name , fk_name , respectively .	raise ValueError ( STR0 % ( model . _meta . app_label , model . _meta . object_name , fk_name ) )
8755	if not ,	else :
8756	fks_to_parent is a list containing f for every f in opts.fields , only if f is an instance of ForeignKey , and , if f.rel.toequals parent_model or f.rel.to is contained in result of the call to the method parent_model._meta.get_parent_list .	fks_to_parent = [ f for f in opts . fields if isinstance ( f , ForeignKey ) and ( f . rel . to == parent_model or f . rel . to in parent_model . _meta . get_parent_list ( ) ) ]
8757	if length of fks_to_parent is integer 1 ,	if len ( fks_to_parent ) == 1 :
8758	substitute first element of fks_to_parent for fk .	fk = fks_to_parent [ 0 ]
8759	otherwise if length of fks_to_parent is zero ,	elif len ( fks_to_parent ) == 0 :
8760	if can_fail is true ,	if can_fail :
8761	return nothing .	return
8762	raise an ValueError with an argument string STR0 , where STR1 is replaced with , model._meta.app_label , model._meta.object_name , parent_model._meta.app_label , parent_model._meta.object_name , respectively .	raise ValueError ( STR0 % ( model . _meta . app_label , model . _meta . object_name , parent_model . _meta . app_label , parent_model . _meta . object_name ) )
8763	if not ,	else :
8764	raise an ValueError with an argument string STR0 , where STR1 is replaced with , model._meta.app_label , model._meta.object_name , parent_model._meta.app_label , parent_model._meta.object_name , respectively .	raise ValueError ( STR0 % ( model . _meta . app_label , model . _meta . object_name , parent_model . _meta . app_label , parent_model . _meta . object_name ) )
8765	return fk .	return fk
8766	define the function inlineformset_factory with 20 arguments : parent_model , model , form set to ModelForm ,	def inlineformset_factory ( parent_model , model , form = ModelForm , formset = BaseInlineFormSet , fk_name = None , fields = None , exclude = None , extra = 3 , can_order = False , can_delete = True , max_num = None , formfield_callback = None , widgets = None , validate_max = False , localized_fields = None , labels = None , help_texts = None , error_messages = None , min_num = None , validate_min = False ) :
8767	call the function _get_foreign_key with 3 arguments : parent_model , model and fk_name=fk_name , substitute the result for fk .	fk = _get_foreign_key ( parent_model , model , fk_name = fk_name )
8768	if fk.unique is boolean true ,	if fk . unique :
8769	max_num is integer 1 .	max_num = 1
8770	kwargs is a dictionary with 17 entries : form for STR0 , formfield_callback for STR1 , formset for STR2 , extra for STR3 , can_delete for STR4 , can_order for STR5 , fields for STR6 , exclude for STR7 , min_num for STR8 , max_num for STR9 , widgets for STR10 , validate_min for STR11 , validate_max for STR12 , localized_fields for STR13 , labels for STR14 , help_texts for STR15 , and error_messages for STR16 .	kwargs = { STR0 : form , STR1 : formfield_callback , STR2 : formset , STR3 : extra , STR4 : can_delete , STR5 : can_order , STR6 : fields , STR7 : exclude , STR8 : min_num , STR9 : max_num , STR10 : widgets , STR11 : validate_min , STR12 : validate_max , STR13 : localized_fields , STR14 : labels , STR15 : help_texts , STR16 : error_messages , }
8771	call the function modelformset_factory with 2 arguments : model and unpacked dictionary kwargs , substitute the result for FormSet .	FormSet = modelformset_factory ( model , ** kwargs )
8772	substitute fk for FormSet.fk .	FormSet . fk = fk
8773	return FormSet .	return FormSet
8774	derive the class InlineForeignKeyField from the Field base class .	class InlineForeignKeyField ( Field ) :
8775	substitute HiddenInput for widget .	widget = HiddenInput
8776	default_error_messages is an dictionary with an entry : return value of the function _ called with an argument , string STR0 for STR1 .	default_error_messages = { STR0 : _ ( STR1 ) , }
8777	define the method __init__ with 4 arguments : self , parent_instance , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , parent_instance , * args , ** kwargs ) :
8778	substitute parent_instance for self.parent_instance .	self . parent_instance = parent_instance
8779	remove element from kwargs dictionary under the key STR0 , substitute it for self.pk_field if it exists , if not self.pk_field is boolean False .	self . pk_field = kwargs . pop ( STR0 , False )
8780	remove element from kwargs dictionary under the key STR0 , substitute it for self.to_field if it exists , if not self.to_field is None .	self . to_field = kwargs . pop ( STR0 , None )
8781	if self.parent_instance is not None ,	if self . parent_instance is not None :
8782	if self.to_field is true ,	if self . to_field :
8783	get self.to_field attribute of self.parent_instance object , substitute it for value under the STR0 key of the kwargs dictionary .	kwargs [ STR0 ] = getattr ( self . parent_instance , self . to_field )
8784	if not ,	else :
8785	substitute self.parent_instance.pk for value under the STR0 key of the kwargs dictionary .	kwargs [ STR0 ] = self . parent_instance . pk
8786	value under the STR0 key of the kwargs dictionary is boolean False .	kwargs [ STR0 ] = False
8787	call the method __init__ from the base class of the class InlineForeignKeyField , with 2 arguments unpacked list args , and unpacked dictionary kwargs .	super ( InlineForeignKeyField , self ) . __init__ ( * args , ** kwargs )
8788	define the method clean with 2 arguments : self and value .	def clean ( self , value ) :
8789	if value is contained in self.empty_values ,	if value in self . empty_values :
8790	if self.pk_field ,	if self . pk_field :
8791	return None .	return None
8792	return self.parent_instance .	return self . parent_instance
8793	if self.to_field is true ,	if self . to_field :
8794	get self.to_field attribute of self.parent_instance , substitute it for orig .	orig = getattr ( self . parent_instance , self . to_field )
8795	if not ,	else :
8796	substitute self.parent_instance.pk for orig .	orig = self . parent_instance . pk
8797	if return values of the function force_text called two times with 1 argument , with value , and with orig , are equal ,	if force_text ( value ) != force_text ( orig ) :
8798	raise an ValidationError with 2 arguments : self.error_messages dictionary value under the STR0 key , and code set to a string STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
8799	return self.parent_instance .	return self . parent_instance
8800	define the method _has_changed with 3 arguments : self , initial and data .	def _has_changed ( self , initial , data ) :
8801	return boolean False .	return False
8802	derive the class ModelChoiceIterator from object base class .	class ModelChoiceIterator ( object ) :
8803	define the method __init__ with 2 arguments : self and field .	def __init__ ( self , field ) :
8804	substitute field for self.field .	self . field = field
8805	substitute field.queryset for self.queryset .	self . queryset = field . queryset
8806	define the method __iter__ with an argument self .	def __iter__ ( self ) :
8807	if self.field.empty_label is not None ,	if self . field . empty_label is not None :
8808	yield a tuple with 2 elements : an empty string and self.field.empty_label .	yield ( STR , self . field . empty_label )
8809	if self.field.cache_choices is true ,	if self . field . cache_choices :
8810	if self.field.choice_cache is None ,	if self . field . choice_cache is None :
8811	self.field.choice_cache is a list containing results of the method self.choice called with an argument obj , for every obj in result of the method self.queryset.all .	self . field . choice_cache = [ self . choice ( obj ) for obj in self . queryset . all ( ) ]
8812	for every choice in self.field.choice_cache ,	for choice in self . field . choice_cache :
8813	yield choice .	yield choice
8814	if not ,	else :
8815	for every obj in result of the call to the method self.queryset.all ,	for obj in self . queryset . all ( ) :
8816	call the method self.choice with an argument obj , yield the result .	yield self . choice ( obj )
8817	define the method __len__ with an argument self .	def __len__ ( self ) :
8818	sum length of self.quertset and integer 1 if self.field.empty_label is not None , or integer 0 if not , return the result .	return ( len ( self . queryset ) + ( 1 if self . field . empty_label is not None else 0 ) )
8819	define the method choice with 2 arguments : self and obj .	def choice ( self , obj ) :
8820	return a tuple with 2 elements : result of the method self.field.prepare_value called with an argument obj , and result of the method self.field.label_from_instance , called with an argument obj .	return ( self . field . prepare_value ( obj ) , self . field . label_from_instance ( obj ) )
8821	derive the class ModelChoiceField from the ChoiceField base class .	class ModelChoiceField ( ChoiceField ) :
8822	default_error_messages is a dictionary with an entry , result of the call to the function _ with an argument , string STR0 for STR1 .	default_error_messages = { STR0 : _ ( STR1 ) , }
8823	define the method __init__ with 13 arguments : self , queryset , empty_label set to a string STR0 , cache_choices set to None , required set to boolean True , widget set to None , label set to None , initial set to None , help_text set to an empty string , to_field_name set to None , limit_choices_to set to None , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , queryset , empty_label = STR0 , cache_choices = None , required = True , widget = None , label = None , initial = None , help_text = STR , to_field_name = None , limit_choices_to = None , * args , ** kwargs ) :
8824	if required is true and initial is not None ,	if required and ( initial is not None ) :
8825	self.empty_label is None .	self . empty_label = None
8826	if not ,	else :
8827	substitute empty_label for self.empty_label .	self . empty_label = empty_label
8828	if cache_choices is not None ,	if cache_choices is not None :
8829	call the function warnings.warn with 3 arguments : string STR0 , RemovedInDjango19Warning and stacklevel set to integer 2 .	warnings . warn ( STR0 , RemovedInDjango19Warning , stacklevel = 2 )
8830	if not ,	else :
8831	substitute boolean False for cache_choices .	cache_choices = False
8832	substitute cache_choices for self.cache_choices .	self . cache_choices = cache_choices
8833	call the method Field.__init__ with 8 arguments : self , required , widget , label , initial , help_text , unpacked list args , and unpacked dictionary kwargs .	Field . __init__ ( self , required , widget , label , initial , help_text , * args , ** kwargs )
8834	substitute queryset for self.queryset .	self . queryset = queryset
8835	substitute limit_choices_to for self.limit_choices_to .	self . limit_choices_to = limit_choices_to
8836	self.choice_cache is None .	self . choice_cache = None
8837	substitute to_field_name for self.to_field_name	self . to_field_name = to_field_name
8838	define the method __deepcopy__ with 2 arguments : self and memo .	def __deepcopy__ ( self , memo ) :
8839	call the method __deepcopy__ from the base class of the class ChoiceField , with an argument memo , substitute the result for result .	result = super ( ChoiceField , self ) . __deepcopy__ ( memo )
8840	substitute result.queryset for result.queryset .	result . queryset = result . queryset
8841	return result .	return result
8842	define the method _get_queryset with an argument self .	def _get_queryset ( self ) :
8843	return self._queryset .	return self . _queryset
8844	define the method _set_queryset with 2 arguments : self and queryset .	def _set_queryset ( self , queryset ) :
8845	substitute queryset for self._queryset .	self . _queryset = queryset
8846	substitute self.choices for self.widget.choices .	self . widget . choices = self . choices
8847	queryset is an property object of this class , with _get_queryset getter and _set_queryset setter functions .	queryset = property ( _get_queryset , _set_queryset )
8848	define the method label_from_instance with 2 arguments : self and obj .	def label_from_instance ( self , obj ) :
8849	call the function smart_text with an argument obj , return the result .	return smart_text ( obj )
8850	define the method _get_choices with an argument self .	def _get_choices ( self ) :
8851	if self has an attribute STR0 ,	if hasattr ( self , STR0 ) :
8852	return self._choices .	return self . _choices
8853	return an instance of ModelChoiceIterator class , created with an argument self .	return ModelChoiceIterator ( self )
8854	choices is an property property object of this class , with _get_choices getter and ChoiceField._set_choices setter functions .	choices = property ( _get_choices , ChoiceField . _set_choices )
8855	define the method prepare_value with 2 arguments : self and value .	def prepare_value ( self , value ) :
8856	if value has an attribute STR0 ,	if hasattr ( value , STR0 ) :
8857	if self.to_field_name is true ,	if self . to_field_name :
8858	call the method value.serializable_value with an argument self.to_field_name , return the result .	return value . serializable_value ( self . to_field_name )
8859	if not ,	else :
8860	return value.pk .	return value . pk
8861	call the method prepare_value from the base class of the class ModelChoiceField , with an argument value , return the result .	return super ( ModelChoiceField , self ) . prepare_value ( value )
8862	define the method to_python with 2 arguments : self and value .	def to_python ( self , value ) :
8863	if value is contained in self.empty_values ,	if value in self . empty_values :
8864	return None .	return None
8865	try ,	try :
8866	substitute self.to_field_name , if exists , for key , if not substitute string STR0 for key .	key = self . to_field_name or STR0
8867	call the method self.queryset.get with an argument , unpacked dictionary with an element : value for key , substitute the result for value .	value = self . queryset . get ( ** { key : value } )
8868	if ValueError or self.queryset.model.DoesNotExist exception is caught ,	except ( ValueError , self . queryset . model . DoesNotExist ) :
8869	raise an ValidationError exception with 2 arguments : value under the STR0 key of the self.error_messages dictionary , code set to a string STR1 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
8870	return value .	return value
8871	define the method validate with 2 arguments : self and value .	def validate ( self , value ) :
8872	call the method Field.validate with 2 arguments : self and value , return the result .	return Field . validate ( self , value )
8873	define the method _has_changed with 3 arguments : self , initial and data .	def _has_changed ( self , initial , data ) :
8874	if initial is not None , substitute initial for initial_value , otherwise initial_value is an empty string .	initial_value = initial if initial is not None else STR
8875	if data is not None , substitute data for initial_value , otherwise data_value is an empty string .	data_value = data if data is not None else STR
8876	call the method self.prepare_value with an argument initial_value , use it as the argument for the call to the function force_text , if the result is equal to the result of the call to the function force_text with data_value as an argument , return boolean True , otherwise return boolean False .	return force_text ( self . prepare_value ( initial_value ) ) != force_text ( data_value )
8877	derive the class ModelMultipleChoiceField from the ModelChoiceField base class .	class ModelMultipleChoiceField ( ModelChoiceField ) :
8878	substitute SelectMultiple for widget .	widget = SelectMultiple
8879	substitute MultipleHiddenInput for hidden_widget .	hidden_widget = MultipleHiddenInput
8880	default_error_messages is an dictionary with 3 entries : return value of the function _ called with an argument , string STR1 for STR2 , return value of the function _ called with an argument , string STR3 for STR4 , and return value of the function _ called with an argument string STR5 for STR6 .	default_error_messages = { STR1 : _ ( STR2 ) , STR3 : _ ( STR4 ) , STR5 : _ ( STR6 ) }
8881	define the method __init__ with 10 arguments : self , queryset , cache_choices set to None , required set to boolean True , widget set to None , label set to None , initial set to None , help_text set to an empty strign , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , queryset , cache_choices = None , required = True , widget = None , label = None , initial = None , help_text = STR , * args , ** kwargs ) :
8882	call the method __init__ from the base class of the class ModelMultipleChoiceField , with 10 arguments : queryset , None , cache_choices , required , widget , label , initial , help_text , unpacked list args and unpacked dictionary kwargs .	super ( ModelMultipleChoiceField , self ) . __init__ ( queryset , None , cache_choices , required , widget , label , initial , help_text , * args , ** kwargs )
8883	define the method to_python with 2 arguments : self and value .	def to_python ( self , value ) :
8884	if value is false ,	if not value :
8885	return an empty list .	return [ ]
8886	instantiate base class of the class ModelMultipleChoiceField , substitute filed to_python of the result for to_py .	to_py = super ( ModelMultipleChoiceField , self ) . to_python
8887	return a list containing return values of the function to_py called with an argument val , for every val in value .	return [ to_py ( val ) for val in value ]
8888	define the method clean with 2 arguments : self and value .	def clean ( self , value ) :
8889	if self.required is true and value is false ,	if self . required and not value :
8890	raise an ValidationError with 2 arguments : dictionary self.error_messages value under the key STR0 , and code set to string 'required .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
8891	otherwise if self.required is false and value is false ,	elif not self . required and not value :
8892	call the method self.queryset.none , return the result .	return self . queryset . none ( )
8893	if value is not an instance of list or tuple types ,	if not isinstance ( value , ( list , tuple ) ) :
8894	raise an ValidationError with 2 arguments : dictionary self.error_messages value under the key STR0 , and code set to string 'list .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 )
8895	substitute self.to_field_name , if true , for key , or if not , substitute string STR0 for key .	key = self . to_field_name or STR0
8896	for every pk in value ,	for pk in value :
8897	try ,	try :
8898	call the method self.queryset.filter with an argument , unpacked dictionary with an entry : pk for key .	self . queryset . filter ( ** { key : pk } )
8899	if ValueError exception is caught ,	except ValueError :
8900	raise an ValidationError with 3 arguments : dictionary self.error_messages value under the key STR0 , code set to string STR1pk ' .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 , params = { STR2 : pk } , )
8901	call the method self.queryset.filter with an argument , unpacked dictionary with an entry : value for string STR0 appended to key , substitute the result for qs .	qs = self . queryset . filter ( ** { STR0 % key : value } )
8902	pks is a set containing results of the call to the function force_text with an argument , key attribute of the o object , for every o in opts .	pks = set ( force_text ( getattr ( o , key ) ) for o in qs )
8903	for every val in value ,	for val in value :
8904	call the function force_text with an argument val , if the result is not contained in pks ,	if force_text ( val ) not in pks :
8905	raise an ValidationError with 3 arguments : dictionary self.error_messages value under the key STR0 , code set to string STR1 and params as a dictionary with an entry , val for STR2 .	raise ValidationError ( self . error_messages [ STR0 ] , code = STR1 , params = { STR2 : val } , )
8906	call the method self.run_validators with an argument value .	self . run_validators ( value )
8907	return qs .	return qs
8908	define the method prepare_value with 2 arguments : self and value .	def prepare_value ( self , value ) :
8909	if value has an attribute STR0 and value is not an instance of six.text_type and value doesnt have an attribute STR1 ,	if ( hasattr ( value , STR0 ) and not isinstance ( value , six . text_type ) and not hasattr ( value , STR1 ) ) :
8910	call the method prepare_value from the base class of the class ModelMultipleChoiceField , with an argument v , for every v in value , return the list of results .	return [ super ( ModelMultipleChoiceField , self ) . prepare_value ( v ) for v in value ]
8911	call the method prepare_value the base class of the class ModelMultipleChoiceField , with an argument value , return the result .	return super ( ModelMultipleChoiceField , self ) . prepare_value ( value )
8912	define the method _has_changed with 3 arguments : self , initial and data .	def _has_changed ( self , initial , data ) :
8913	if initial is None ,	if initial is None :
8914	initial is an empty list .	initial = [ ]
8915	if data is None ,	if data is None :
8916	data is an empty list .	data = [ ]
8917	if lengths of initial and data are equal ,	if len ( initial ) != len ( data ) :
8918	return boolean True .	return True
8919	initial_set is set created out of return values of the function force_text called with an argument value , for every value in result of the method self.prepare_value called with an argument initial .	initial_set = set ( force_text ( value ) for value in self . prepare_value ( initial ) )
8920	data_set is set created out of return values of the function force_text called with an argument value , for every value in data .	data_set = set ( force_text ( value ) for value in data )
8921	if data_set is not equal to initial_set return boolean True , otherwise return boolean False .	return data_set != initial_set
8922	define the function modelform_defines_fields with an argument form_class .	def modelform_defines_fields ( form_class ) :
8923	only if form_class is not None , and if form_class has an attribute STR0 and form_class._meta.fields is not None ,	return ( form_class is not None and ( hasattr ( form_class , STR0 ) and ( form_class . _meta . fields is not None or form_class . _meta . exclude is not None ) ) )
8924	import module warnings .	import warnings
8925	from django.utils.deprecation import RemovedInDjango19Warning into default name space .	from django . utils . deprecation import RemovedInDjango19Warning
8926	call the function warnings.warn with 3 arguments : string STR0 , RemovedInDjango19Warning and stacklevel set to an integer 2 .	warnings . warn ( STR0 , RemovedInDjango19Warning , stacklevel = 2 )
8927	from django.forms.utils import everything into default name space .	from django . forms . utils import *
8928	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
8929	import module json .	import json
8930	import module sys .	import sys
8931	try ,	try :
8932	from collections import UserList into default namespace .	from collections import UserList
8933	if ImportError exception is caught .	except ImportError :
8934	from UserList import UserList into default namespace .	from UserList import UserList
8935	from django.conf import settings into default name space .	from django . conf import settings
8936	from django.utils.encoding import force_text and python_2_unicode_compatible into default name space .	from django . utils . encoding import force_text , python_2_unicode_compatible
8937	from django.utils.html import format_html , format_html_join and escape into default name space .	from django . utils . html import format_html , format_html_join , escape
8938	from django.utils import timezone into default name space .	from django . utils import timezone
8939	from django.utils.translation import ugettext_lazy as _ into default name space .	from django . utils . translation import ugettext_lazy as _
8940	from django.utils import six into default name space .	from django . utils import six
8941	from django.core.exceptions import ValidationError into default name space .	from django . core . exceptions import ValidationError
8942	define the function flatatt with an argument attrs .	def flatatt ( attrs ) :
8943	boolean_attrs is an empty list .	boolean_attrs = [ ]
8944	convert items of attrs dictionary to list of tuples , for every attr and value in it ,	for attr , value in list ( attrs . items ( ) ) :
8945	if value is boolean True ,	if value is True :
8946	append tuple containing element attr to boolean_attrs .	boolean_attrs . append ( ( attr , ) )
8947	delete entry under the attr key of the attrs dictionary .	del attrs [ attr ]
8948	otherwise if value is boolean False ,	elif value is False :
8949	delete entry under the attr key of the attrs dictionary .	del attrs [ attr ]
8950	call the function format_html_join twice , first time with 3 elements : an empty string , string STR1 and sorted return value of the items of the attrs dictionary , and second time with 3 arguments : an empty string , string STR2 , and sorted list of boolean_attrs elements , concatenate the results and return the resulting list .	return ( format_html_join ( STR , STR1 , sorted ( attrs . items ( ) ) ) + format_html_join ( STR , STR2 , sorted ( boolean_attrs ) ) )
8951	python_2_unicode_compatible decorator ,	@ python_2_unicode_compatible
8952	derive the class ErrorDict from the dict base class .	class ErrorDict ( dict ) :
8953	define the method as_data with an argument self .	def as_data ( self ) :
8954	return a dictionary generated with an expression , return value of the method e.as_data for f , for every f and e in list of tuples of self dictionary key , pair entries .	return { f : e . as_data ( ) for f , e in self . items ( ) }
8955	define the method as_json with 2 argumens self and escape_html set to boolean False .	def as_json ( self , escape_html = False ) :
8956	call the method json.dumps with a dictionary generate with an expression as an argument , return value of the function e.get_json_data , with an argument escape_html for f , for every f and e in list of tuples of self dictionary key , pair entries , return the result .	return json . dumps ( { f : e . get_json_data ( escape_html ) for f , e in self . items ( ) } )
8957	define the method as_ul with an argument self .	def as_ul ( self ) :
8958	if self is false ,	if not self :
8959	return an empty string .	return STR
8960	call the function format_html with 2 arguments : string STR1 , and return value of the function , format_html_join , called with 3 arguments : empty string , string STR2 , tuple containing tuples with 2 elements : k and result of the function force_text with an argument v , for every k and v in items of the dictionary self , return the result .	return format_html ( STR1 , format_html_join ( STR , STR2 , ( ( k , force_text ( v ) ) for k , v in self . items ( ) ) ) )
8961	define the method as_text with an argument self .	def as_text ( self ) :
8962	output is an empty list .	output = [ ]
8963	call the method self.items , for every field and errors in the result .	for field , errors in self . items ( ) :
8964	convert field into a string and concatenate it to a string STR0 , append the result to output .	output . append ( STR0 % field )
8965	for every e in errors convert e into a string and append it to a string STR0 , join all the results into a string separated by newlines , append the result to output .	output . append ( STR0 . join ( STR1 % e for e in errors ) )
8966	join elements of output into a string , separated by newline characters , return the result .	return STR0 . join ( output )
8967	define the method __str__ with an argument self .	def __str__ ( self ) :
8968	call the method self.as_ul , return the result .	return self . as_ul ( )
8969	python_2_unicode_compatible decorator ,	@ python_2_unicode_compatible
8970	derive the class ErrorList from the UserList and list base classes .	class ErrorList ( UserList , list ) :
8971	define the method __init__ with 3 arguments : self , initlist set to None and error_class set to None .	def __init__ ( self , initlist = None , error_class = None ) :
8972	call the method __init__ with an argument initlist from the base class of the class ErrorList .	super ( ErrorList , self ) . __init__ ( initlist )
8973	if error_class is None ,	if error_class is None :
8974	self.error_class is a string STR0 .	self . error_class = STR0
8975	if not ,	else :
8976	append error_class converted into a string to string STR0 , substitute the result for self.error_class .	self . error_class = STR0 . format ( error_class )
8977	define the method as_text with an argument self .	def as_data ( self ) :
8978	instantiate ValidationError class with an argument self.data , return its field error_list .	return ValidationError ( self . data ) . error_list
8979	define the method get_json_data with 2 arguments self and escape_html set to boolean False .	def get_json_data ( self , escape_html = False ) :
8980	errors is an empty list .	errors = [ ]
8981	call the method self.as_data , for every error in the result .	for error in self . as_data ( ) :
8982	convert elements of error into a list , substitute the first element for message .	message = list ( error ) [ 0 ]
8983	append to errors list a dictionary created with 2 etries , if escape_html is true , return value of the function escape	errors . append ( { STR0 : escape ( message ) if escape_html else message , STR1 : error . code or STR , } )
8984	with an argument message for STR0 , or if not message for STR1 and error.code for STR2 in error.code is true , if not , an empty string for STR3 . return errors .	return errors
8985	define the method as_json with 2 arguments self and escape_html set to boolean False .	def as_json ( self , escape_html = False ) :
8986	call the method self.get_json_data with an argument escape_html , use the result as an argument for the call to the json.dumps function , return the result .	return json . dumps ( self . get_json_data ( escape_html ) )
8987	define the method as_text with an argument self .	def as_ul ( self ) :
8988	if self.data is false ,	if not self . data :
8989	return an empty string .	return STR
8990	call the function format_html with 3 arguments : string STR1 , self.error_class and return value of the function , format_html_join , called with 3 arguments : empty string , string STR2 , tuple containing results of the function , force_text with an argument e , for every e in self , return the result .	return format_html ( STR1 , self . error_class , format_html_join ( STR , STR2 , ( ( force_text ( e ) , ) for e in self ) ) )
8991	define the method as_text with an argument self .	def as_text ( self ) :
8992	for every e in self , append convert e to an string and append it to string STR0 , join all of the results into a string separated by newline character , return the result .	return STR0 . join ( STR1 % e for e in self )
8993	define the method __str__ with an argument self .	def __str__ ( self ) :
8994	call the method self.as_ul , return the result .	return self . as_ul ( )
8995	define the method __repr__ with an argument self .	def __repr__ ( self ) :
8996	convert elements of self into a list , return the its printable representation .	return repr ( list ( self ) )
8997	define the method __contains__ with an argument self .	def __contains__ ( self , item ) :
8998	if item is contained in the list of the elements of self , return boolean True , otherwise return boolean False .	return item in list ( self )
8999	define the method __eq__ with an argument self .	def __eq__ ( self , other ) :
9000	if other equals list containing elements of self , return boolean True , otherwise return boolean False .	return list ( self ) == other
9001	define the method __ne__ with an argument self .	def __ne__ ( self , other ) :
9002	if other is not equal to list containing elements of self , return boolean True , otherwise return boolean False .	return list ( self ) != other
9003	define the method __getitem__ with an argument self .	def __getitem__ ( self , i ) :
9004	substitute i-th element of self.data for error .	error = self . data [ i ]
9005	if error is an instance of ValidationError ,	if isinstance ( error , ValidationError ) :
9006	return first element of the list containing elements of error .	return list ( error ) [ 0 ]
9007	call the function force_text with an argument error , return the result .	return force_text ( error )
9008	define the function from_current_timezone with an argument value .	def from_current_timezone ( value ) :
9009	if settings.USE_TZ is true and value is not None and call to the function timezone.is_naive with an argument value , evaluates to true ,	if settings . USE_TZ and value is not None and timezone . is_naive ( value ) :
9010	call the method timezone.get_current_timezone , substitute the result for current_timezone .	current_timezone = timezone . get_current_timezone ( )
9011	try ,	try :
9012	call the function timezone.make_aware with arguments value and current_timezone , return the result .	return timezone . make_aware ( value , current_timezone )
9013	if Exception exception is caught ,	except Exception :
9014	call the function _ with an argument string STR0 , substitute the result for message .	message = _ ( STR0 )
9015	params is an dictionary containing 2 initial entries : value for STR0 and current_timezone for STR1 .	params = { STR0 : value , STR1 : current_timezone }
9016	call the function six.reraise with 3 arguments : class ValidationError , class ValidationError , created with 3 arguments : message , code as a string STR0 and params as params , and third element of the return value of the function sys.exc_info .	six . reraise ( ValidationError , ValidationError ( message , code = STR0 , params = params , ) , sys . exc_info ( ) [ 2 ] )
9017	return value .	return value
9018	define the function to_current_timezone with an argument value .	def to_current_timezone ( value ) :
9019	if settings.USE_TZ is true and value is not None and call to the function timezone.is_aware with an argument value , evaluates to true ,	if settings . USE_TZ and value is not None and timezone . is_aware ( value ) :
9020	call the function timezone.get_current_timezone , substitute the result for current_timezone .	current_timezone = timezone . get_current_timezone ( )
9021	call the function timezone.make_naive with 2 arguments value , current_timezone , return the result .	return timezone . make_naive ( value , current_timezone )
9022	return value .	return value
9023	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
9024	import module copy .	import copy
9025	from itertools import chain into default name space .	from itertools import chain
9026	from django.conf import settings into default name space .	from django . conf import settings
9027	from django.forms.utils import flatatt and to_current_timezone into default name space .	from django . forms . utils import flatatt , to_current_timezone
9028	from django.utils.datastructures import MultiValueDict and MergeDict into default name space .	from django . utils . datastructures import MultiValueDict , MergeDict
9029	from django.utils.encoding import force_text and python_2_unicode_compatible into default name space .	from django . utils . encoding import force_text , python_2_unicode_compatible
9030	from django.utils.html import conditional_escape and format_html into default name space .	from django . utils . html import conditional_escape , format_html
9031	from django.utils.translation import ugettext_lazy into default name space .	from django . utils . translation import ugettext_lazy
9032	from django.utils.safestring import mark_safe into default name space .	from django . utils . safestring import mark_safe
9033	from django.utils import formats and six into default name space .	from django . utils import formats , six
9034	from django.utils.six.moves.urllib.parse import urljoin into default name space .	from django . utils . six . moves . urllib . parse import urljoin
9035	__all__ is a tuple of strings : STR0 , STR1 , STR2 , STR3 , STR4 , STR5 , STR6 , STR7 , STR8 , STR9 , STR10 , STR11 , STR12 , STR13 , STR14 , STR15 , STR16 , STR17 , STR18 , STR19 , STR20 , STR21 , STR22 , STR23 and STR24 .	__all__ = ( STR0 , STR1 , STR2 , STR3 , STR4 , STR5 , STR6 , STR7 , STR8 , STR9 , STR10 , STR11 , STR12 , STR13 , STR14 , STR15 , STR16 , STR17 , STR18 , STR19 , STR20 , STR21 , STR22 , STR23 , STR24 , )
9036	MEDIA_TYPES is a tuple with 2 strings : STR0 and STR1 .	MEDIA_TYPES = ( STR0 , STR1 )
9037	python_2_unicode_compatible decorator ,	@ python_2_unicode_compatible
9038	derive the class Media from the object base class .	class Media ( object ) :
9039	define the method __init__ with 3 arguments : self , media set to None and unpacked dictionary kwargs .	def __init__ ( self , media = None , ** kwargs ) :
9040	if media is true ,	if media :
9041	substitute media.__dict__ for media_attrs .	media_attrs = media . __dict__
9042	if not ,	else :
9043	substitute kwargs for media_attrs .	media_attrs = kwargs
9044	self._css is an empty dictionary .	self . _css = { }
9045	self._js is an empty list .	self . _js = [ ]
9046	for every name in MEDIA_TYPES ,	for name in MEDIA_TYPES :
9047	append name to string STR0 use it as the name of the attribute to get from object self , call the result as an function , with an argument : value under the name key of the media_attrs dictionary , if it exists , if not use None as an argument .	getattr ( self , STR0 + name ) ( media_attrs . get ( name , None ) )
9048	define the method __str__ with an argument self .	def __str__ ( self ) :
9049	call the method self.render , return the result .	return self . render ( )
9050	define the method render with an argument self .	def render ( self ) :
9051	call the function chain with an argument unpacked list , append name to string STR0 , and use it as the name of the attribute to get from the self object , call the result and append it to a list for every name in MEDIA_TYPES , join all the results into a string with newline separator , use the result as an argument for the call to the function mark_safe , return the result .	return mark_safe ( STR0 . join ( chain ( * [ getattr ( self , STR1 + name ) ( ) for name in MEDIA_TYPES ] ) ) )
9052	define the method render_js with an argument self .	def render_js ( self ) :
9053	return a list containing results of the function format_html called with 2 arguments : string STR2 and absolute file path of the path , for every path is self._js .	return [ format_html ( STR2 , self . absolute_path ( path ) ) for path in self . _js ]
9054	define the method render_css with an argument self .	def render_css ( self ) :
9055	call the method self._css.keys , sort the result and substitute it for media .	media = sorted ( self . _css . keys ( ) )
9056	return the result of the call to the function chain , with an argument unpacked list , containing the result of the function , format_html called with 3 arguments : string STR4 , return value of the function self.absolute_path called with an argument path and medium , for every medium in media and for every path in value under the medium key of the self._css dictionary .	return chain ( * [ [ format_html ( STR4 , self . absolute_path ( path ) , medium ) for path in self . _css [ medium ] ] for medium in media ] )
9057	define the method absolute_path with 3 arguments self , path and prefix set to None .	def absolute_path ( self , path , prefix = None ) :
9058	if path starts with string STR0 or string STR1 or with string STR2 ,	if path . startswith ( ( STR0 , STR1 , STR2 ) ) :
9059	return path ,	return path
9060	if prefix is None ,	if prefix is None :
9061	if settings.STATIC_URL is None ,	if settings . STATIC_URL is None :
9062	substitute settings.MEDIA_URL for prefix .	prefix = settings . MEDIA_URL
9063	if not ,	else :
9064	substitute settings.STATIC_URL for prefix .	prefix = settings . STATIC_URL
9065	join prefix and path into an url , return it .	return urljoin ( prefix , path )
9066	define the method __getitem__ with arguments self and name .	def __getitem__ ( self , name ) :
9067	if name is contained in MEDIA_TYPES ,	if name in MEDIA_TYPES :
9068	return an instance of the class Media , called with an unpacked dictionary with an entry : name appended to string STR0 , attribute of the self object for name converted into a string .	return Media ( ** { str ( name ) : getattr ( self , STR0 + name ) } )
9069	raise an KeyError with an argument string STR1 , where STR2 is replaced with name .	raise KeyError ( STR1 % name )
9070	define the method __getitem__ with arguments self and name .	def add_js ( self , data ) :
9071	if data is true ,	if data :
9072	for every path in data ,	for path in data :
9073	if path is not contained in self._js ,	if path not in self . _js :
9074	append path to self._js .	self . _js . append ( path )
9075	define the method add_css with arguments self and data .	def add_css ( self , data ) :
9076	if data is true ,	if data :
9077	call the method data.items , for every medium and paths in the result .	for medium , paths in data . items ( ) :
9078	for every path in paths ,	for path in paths :
9079	if call to the method self._css.get with an argument medium evaluates to false , or path is not contained in the value under the medium key of self._css dictionary .	if not self . _css . get ( medium ) or path not in self . _css [ medium ] :
9080	call the method self._css.setdefault with 2 arguments medium and an empty string , append path to the result .	self . _css . setdefault ( medium , [ ] ) . append ( path )
9081	define the method __add__ with arguments self and other .	def __add__ ( self , other ) :
9082	combined is an instance of Media class .	combined = Media ( )
9083	for every name in MEDIA_TYPES ,	for name in MEDIA_TYPES :
9084	append name to STR0 use it as the name of the attribute to get from combined object , call the result with an argument : name appended to string STR1 , as the name of the attribute to get from self object , or if the previous doesnt exist , None .	getattr ( combined , STR0 + name ) ( getattr ( self , STR1 + name , None ) )
9085	append name to STR0 use it as the name of the attribute to get from combined object , call the result with an argument : name appended to string STR1 , as the name of the attribute to get from other object , or if the previous doesnt exist , None .	getattr ( combined , STR0 + name ) ( getattr ( other , STR1 + name , None ) )
9086	return combined .	return combined
9087	define the function media_property with an argument cls .	def media_property ( cls ) :
9088	define the method _media with an argument self .	def _media ( self ) :
9089	sup_cls is base class of the class cls .	sup_cls = super ( cls , self )
9090	try ,	try :
9091	substitute sup_cls.media for base .	base = sup_cls . media
9092	if AttributeError exception is caught ,	except AttributeError :
9093	base is an instance of Media class .	base = Media ( )
9094	get the attribute STR0 of the cls object , if it exists substitute it for definition , if not definition is None .	definition = getattr ( cls , STR0 , None )
9095	if definition is true ,	if definition :
9096	get the attribute STR0 of the cls object , if it exists substitute it for extend , if not extend is boolean True .	extend = getattr ( definition , STR0 , True )
9097	if extend is true ,	if extend :
9098	if extend is boolean True ,	if extend is True :
9099	substitute base for m .	m = base
9100	if not ,	else :
9101	m is an instance of Media class .	m = Media ( )
9102	for every medium in extend ,	for medium in extend :
9103	sum m and value under the medium key of the base dictionary , substitute it for m .	m = m + base [ medium ]
9104	sum m and class Media created with definition , return the result .	return m + Media ( definition )
9105	if not ,	else :
9106	return an instance of Media class , created with definition as an argument .	return Media ( definition )
9107	if not ,	else :
9108	return base .	return base
9109	return property object with _media as getter function .	return property ( _media )
9110	derive the class MediaDefiningClass from the type base class .	class MediaDefiningClass ( type ) :
9111	define the method __new__ with 4 arguments mcs , name , bases and attrs .	def __new__ ( mcs , name , bases , attrs ) :
9112	call the method __new__ from the base class of the class MediaDefiningClass , called with 4 arguments : mcs , name , bases and attrs .	new_class = ( super ( MediaDefiningClass , mcs ) . __new__ ( mcs , name , bases , attrs ) )
9113	if STR0 is not contained in attrs ,	if STR0 not in attrs :
9114	call the method media_property with an argument new_class , substitute the result for new_class.media .	new_class . media = media_property ( new_class )
9115	return new_class .	return new_class
9116	python_2_unicode_compatible decorator	@ python_2_unicode_compatible
9117	derive the class SubWidget from the object base class .	class SubWidget ( object ) :
9118	define the method __init__ with 6 arguments self , parent_widget , name , value , attrs and choices .	def __init__ ( self , parent_widget , name , value , attrs , choices ) :
9119	substitute parent_widget for self.parent_widget .	self . parent_widget = parent_widget
9120	substitute name and value for self.name and self.value .	self . name , self . value = name , value
9121	substitute attrs and choices for self.attrs and self.choices	self . attrs , self . choices = attrs , choices
9122	define the method __str__ with an argument self .	def __str__ ( self ) :
9123	args is an list with 3 initial elements self.name , self.value and self.attrs .	args = [ self . name , self . value , self . attrs ]
9124	if self.choices is true ,	if self . choices :
9125	append self.choices to args .	args . append ( self . choices )
9126	call the method self.parent_widget.render with unpacked list args as an argument , return the result .	return self . parent_widget . render ( * args )
9127	derive the class Widget from the base class in the return value of the six.with_metaclass called with an argument MediaDefiningClass .	class Widget ( six . with_metaclass ( MediaDefiningClass ) ) :
9128	needs_multipart_form is boolean False .	needs_multipart_form = False
9129	is_localized is boolean False .	is_localized = False
9130	is_required is boolean False .	is_required = False
9131	define the method __init__ with arguments self and attrs set to None .	def __init__ ( self , attrs = None ) :
9132	if attrs is not None ,	if attrs is not None :
9133	call the method attrs.copy , substitute the result for self.attrs .	self . attrs = attrs . copy ( )
9134	if not ,	else :
9135	self.attrs is an empty dictionary .	self . attrs = { }
9136	define the method __deepcopy__ with arguments self and memo .	def __deepcopy__ ( self , memo ) :
9137	call the method copy.copy , substitute the result for obj .	obj = copy . copy ( self )
9138	call the method self.attrs.copy , substitute the result for obj.attrs .	obj . attrs = self . attrs . copy ( )
9139	substitute obj for the value of the memo dictionary at the identity of the self object key .	memo [ id ( self ) ] = obj
9140	return obj .	return obj
9141	property decorator ,	@ property
9142	define the method is_hidden with an argument self .	def is_hidden ( self ) :
9143	if self.input_type equals string STR0 and self has an attribute STR1 , return boolean True , otherwise return boolean False .	return self . input_type == STR0 if hasattr ( self , STR1 ) else False
9144	define the method subwidgets with 5 arguments : self , name , value , attrs set to None and choices set to an empty tuple .	def subwidgets ( self , name , value , attrs = None , choices = ( ) ) :
9145	yield an instance of SubWidget class created with 5 arguments : self , name , value , attrs and choices .	yield SubWidget ( self , name , value , attrs , choices )
9146	define the method render with 4 arguments : self , name , value and attrs set to None .	def render ( self , name , value , attrs = None ) :
9147	raise an NotImplementedError with an argument string STR0 .	raise NotImplementedError ( STR0 )
9148	define the method build_attrs with 3 arguments : self , extra_attrs set to None and unpacked dictionary kwargs .	def build_attrs ( self , extra_attrs = None , ** kwargs ) :
9149	unpack dictionary kwargs , map it through self.attrs and convert to dictionary , substitute the result for attrs .	attrs = dict ( self . attrs , ** kwargs )
9150	if extra_attrs is true ,	if extra_attrs :
9151	update attrs dictionary with extra_attrs entry .	attrs . update ( extra_attrs )
9152	return attrs .	return attrs
9153	define the method render with 4 arguments : self , name , value and attrs set to None .	def value_from_datadict ( self , data , files , name ) :
9154	get the value under the name key of the data dictionary , return it , if the previous doesnt exists , return None .	return data . get ( name , None )
9155	define the method id_for_label with 2 arguments : self and id .	def id_for_label ( self , id_ ) :
9156	return id_ .	return id_
9157	derive the class Input from the Widget base class .	class Input ( Widget ) :
9158	input_type is None .	input_type = None
9159	define the method _format_value with 2 arguments : self and value .	def _format_value ( self , value ) :
9160	if self.is_localized is true ,	if self . is_localized :
9161	call the method formats.localize_input with an argument value , return the result .	return formats . localize_input ( value )
9162	return value .	return value
9163	define the method render with 4 arguments : self , name , value and attrs set to None .	def render ( self , name , value , attrs = None ) :
9164	if value is None ,	if value is None :
9165	value is an empty string .	value = STR
9166	call the method self.build_attrs with 3 arguments : attrs , type as self.input_type , name as name , substitute the result for final_attrs .	final_attrs = self . build_attrs ( attrs , type = self . input_type , name = name )
9167	if value is not equal to an empty string ,	if value != STR :
9168	call the method self._format_value with an argument value , use the result as an argument for the call to the function force_text , substitute the result for final_attrs dictionary value under the STR0 key .	final_attrs [ STR0 ] = force_text ( self . _format_value ( value ) )
9169	call the function format_html with 2 arguments : string STR0 , result of the function flatatt called with an argument final_attrs , return the result .	return format_html ( STR0 , flatatt ( final_attrs ) )
9170	derive the class TextInput from the Input base class .	class TextInput ( Input ) :
9171	input_type is a string STR0 .	input_type = STR0
9172	define the method __init__ with 2 arguments : self and attrs set to None .	def __init__ ( self , attrs = None ) :
9173	if attrs is not None ,	if attrs is not None :
9174	remover the entry under the STR0 key of the attrs dictionary , substitute it for self.input_type , if the key doesnt exists , substitute self.input_type for self.input_type .	self . input_type = attrs . pop ( STR0 , self . input_type )
9175	call the method __init__ from the base class of the class TextInput , called with an argument attrs .	super ( TextInput , self ) . __init__ ( attrs )
9176	derive the class NumberInput from the TextInput base class .	class NumberInput ( TextInput ) :
9177	input_type is a string STR0 .	input_type = STR0
9178	derive the class EmailInput from the TextInput base class .	class EmailInput ( TextInput ) :
9179	input_type is a string STR0 .	input_type = STR0
9180	derive the class URLInput from the TextInput base class .	class URLInput ( TextInput ) :
9181	input_type is a string STR0 .	input_type = STR0
9182	derive the class PasswordInput from the TextInput base class .	class PasswordInput ( TextInput ) :
9183	input_type is a string STR0 .	input_type = STR0
9184	define the method __init__ with 3 arguments : self , attrs set to None and render_value set to boolean False .	def __init__ ( self , attrs = None , render_value = False ) :
9185	call the method __init__ from the base class of the class PasswordInput , called with an argument attrs .	super ( PasswordInput , self ) . __init__ ( attrs )
9186	substitute render_value for self.render_value .	self . render_value = render_value
9187	define the method render with 4 arguments : self , name , value and attrs set to None .	def render ( self , name , value , attrs = None ) :
9188	if self.render_value is false ,	if not self . render_value :
9189	value is None .	value = None
9190	call the method render from the base class of the class PasswordInput , called with 3 arguments : name , value and attrs , return the result .	return super ( PasswordInput , self ) . render ( name , value , attrs )
9191	derive the class HiddenInput from the Input base class .	class HiddenInput ( Input ) :
9192	input_type is a string STR0 .	input_type = STR0
9193	derive the class MultipleHiddenInput from the HiddenInput base class .	class MultipleHiddenInput ( HiddenInput ) :
9194	define the method __init__ with 3 arguments : self , attrs set to None and choices set to an empty tuple .	def __init__ ( self , attrs = None , choices = ( ) ) :
9195	call the method __init__ from the base class of the class MultipleHiddenInput , called with an argument attrs .	super ( MultipleHiddenInput , self ) . __init__ ( attrs )
9196	substitute choices for self.choices .	self . choices = choices
9197	define the method render with 5 arguments : self , name , value , attrs set to None and choices set to an empty tuple .	def render ( self , name , value , attrs = None , choices = ( ) ) :
9198	if value is None ,	if value is None :
9199	value is an empty list .	value = [ ]
9200	call the method self.build_attrs with 3 arguments : attrs , type set to self.input_type , name set to name , substitute the result for final_attrs .	final_attrs = self . build_attrs ( attrs , type = self . input_type , name = name )
9201	get the value under the STR0 key of final_attrs dictionary , substitute if for id_ if the key doesnt exists , id_ is None .	id_ = final_attrs . get ( STR0 , None )
9202	inputs is an empty list .	inputs = [ ]
9203	for every i and v in enumerated iterable value ,	for i , v in enumerate ( value ) :
9204	unpack dictionary final_attrs , map the values through force_text function with an argument v and convert it to a dictionary , again , substitute the result input_attrs .	input_attrs = dict ( value = force_text ( v ) , ** final_attrs )
9205	if id_ ,	if id_ :
9206	replace STR0 in string STR1 with id_ and i , substitute the result for input_attrs dictionary value under the STR2 key .	input_attrs [ STR0 ] = STR1 % ( id_ , i )
9207	call the function format_html with 2 arguments : string STR0 , return value of the function flatatt , called with an argument , input_attrs , append the result to inputs list .	inputs . append ( format_html ( STR0 , flatatt ( input_attrs ) ) )
9208	join inputs elements into a string , separated with newline character , use it as an argument for the call to the function mark_safe , return the result .	return mark_safe ( STR0 . join ( inputs ) )
9209	define the method value_from_datadict with 4 arguments : self , data , files and name .	def value_from_datadict ( self , data , files , name ) :
9210	if data is an instance of MultiValueDict or MergeDict class ,	if isinstance ( data , ( MultiValueDict , MergeDict ) ) :
9211	call the method data.getlist with an argument name , return the result .	return data . getlist ( name )
9212	return value under the name key of the data dictionary , if it doesnt exists , return None .	return data . get ( name , None )
9213	derive the class FileInput from the Input base class .	class FileInput ( Input ) :
9214	input_type is a string STR0 .	input_type = STR0
9215	needs_multipart_form is boolean True .	needs_multipart_form = True
9216	define the method render with 4 arguments : self , name , value and attrs set to None .	def render ( self , name , value , attrs = None ) :
9217	call the method render from the base class of the class FileInput , called with 3 arguments : name , None and attrs as attrs .	return super ( FileInput , self ) . render ( name , None , attrs = attrs )
9218	define the method value_from_datadict with 4 arguments : self , data , files and name .	def value_from_datadict ( self , data , files , name ) :
9219	return value under the name key of the files dictionary , if it doesnt exists , return None .	return files . get ( name , None )
9220	FILE_INPUT_CONTRADICTION is an instance of object class .	FILE_INPUT_CONTRADICTION = object ( )
9221	derive the class ClearableFileInput from the FileInput base class .	class ClearableFileInput ( FileInput ) :
9222	call the function ugettext_lazy with an argument string STR0 , substitute the result for initial_text .	initial_text = ugettext_lazy ( STR0 )
9223	call the function ugettext_lazy with an argument string STR0 , substitute the result for input_text .	input_text = ugettext_lazy ( STR0 )
9224	call the function ugettext_lazy with an argument string STR0 , substitute the result for clear_checkbox_label .	clear_checkbox_label = ugettext_lazy ( STR0 )
9225	template_with_initial is a string STR0 .	template_with_initial = STR0
9226	template_with_clear is a string STR1 .	template_with_clear = STR1
9227	url_markup_template is a string STR1 .	url_markup_template = STR1
9228	define the method clear_checkbox_name with 2 arguments : self and name .	def clear_checkbox_name ( self , name ) :
9229	concatenate name and string STR0 , return it .	return name + STR0
9230	define the method clear_checkbox_id with 2 arguments : self and name .	def clear_checkbox_id ( self , name ) :
9231	concatenate name and string STR0 , return it .	return name + STR0
9232	define the method render with 4 arguments : self , name , value and attrs set to None .	def render ( self , name , value , attrs = None ) :
9233	substitutions is a dictionary with 4 initial entries : self.initial_text for STR0 , self.input_text for STR1 , an empty string for STR2 and self.clear_checkbox_label for STR3 .	substitutions = { STR0 : self . initial_text , STR1 : self . input_text , STR2 : STR , STR3 : self . clear_checkbox_label , }
9234	template is a string STR0 .	template = STR0
9235	call the method render from the base class of the class ClearableFileInput , called with 3 arguments : name , value and attrs , substitute the result for value under the STR0 key of the substitutions dictionary .	substitutions [ STR0 ] = super ( ClearableFileInput , self ) . render ( name , value , attrs )
9236	if value is true and value has an attribute STR0 ,	if value and hasattr ( value , STR0 ) :
9237	substitute self.template_with_initial for template .	template = self . template_with_initial
9238	call the function format_html with 3 arguments : self.url_markup_template , value.url and return value of the function force_text , called with an argument value , substitute the result for value under the STR0 key of the substitutions dictionary .	substitutions [ STR0 ] = format_html ( self . url_markup_template , value . url , force_text ( value ) )
9239	if self.is_required is false ,	if not self . is_required :
9240	call the method self.clear_checkbox_name with an argument name , substitute the result for checkbox_name .	checkbox_name = self . clear_checkbox_name ( name )
9241	call the method self.clear_checkbox_id with an argument checkbox_name , substitute the result for checkbox_id .	checkbox_id = self . clear_checkbox_id ( checkbox_name )
9242	call the function conditional_escape with an argument checkbox_name , substitute the result for value under the STR0 key of the substitutions dictionary .	substitutions [ STR0 ] = conditional_escape ( checkbox_name )
9243	call the function conditional_escape with an argument checkbox_id , substitute the result for value under the STR0 key of the substitutions dictionary .	substitutions [ STR0 ] = conditional_escape ( checkbox_id )
9244	call the method render from the instance of CheckboxInput class , with 3 arguments : checkbox_name , boolean False , attrs as a dictionary with an entry : checkbox_id for STR0 , substitute the result for value under the STR1 key of the substitutions dictionary .	substitutions [ STR0 ] = CheckboxInput ( ) . render ( checkbox_name , False , attrs = { STR1 : checkbox_id } )
9245	format self.template_with_clear with substitutions , substitute the result for value under the STR0 key of , substitutions dictionary .	substitutions [ STR0 ] = self . template_with_clear % substitutions
9246	call the function mark_safe with an argument template , formated with substitutions , return the result .	return mark_safe ( template % substitutions )
9247	define the method value_from_datadict with 4 arguments : self , data , files and name .	def value_from_datadict ( self , data , files , name ) :
9248	call the method value_from_datadict from the base class of the class ClearableFileInput , called with 3 arguments : data , files and name , substitute the result for upload .	upload = super ( ClearableFileInput , self ) . value_from_datadict ( data , files , name )
9249	if self.is_required is boolean false and call to the method value_from_datadict from the instance of CheckboxInput class , with 3 arguments : data , files and return value of the function self.clear_checkbox_name called with an argument name , evaluates to true ,	if not self . is_required and CheckboxInput ( ) . value_from_datadict ( data , files , self . clear_checkbox_name ( name ) ) :
9250	if upload is true ,	if upload :
9251	return FILE_INPUT_CONTRADICTION .	return FILE_INPUT_CONTRADICTION
9252	return boolean False .	return False
9253	return boolean upload .	return upload
9254	derive the class Textarea from the Widget base class .	class Textarea ( Widget ) :
9255	define the method __init__ with 2 arguments : self and attrs set to None .	def __init__ ( self , attrs = None ) :
9256	default_attrs is an dictionary with 2 initial entries : string STR0 for STR1 and string STR2 for STR3 .	default_attrs = { STR0 : STR1 , STR2 : STR3 }
9257	if attrs is true ,	if attrs :
9258	update default_attrs dictionary with attrs entry .	default_attrs . update ( attrs )
9259	call the method __init__ from the base class of the class Textarea , with an argument default_attrs .	super ( Textarea , self ) . __init__ ( default_attrs )
9260	define the method render with 4 arguments : self , name , value and attrs set to None .	def render ( self , name , value , attrs = None ) :
9261	if value is None ,	if value is None :
9262	value is an empty string .	value = STR
9263	call the method self.build_attrs with 2 arguments : attrs and name set to name , substitute the result for final_attrs .	final_attrs = self . build_attrs ( attrs , name = name )
9264	call the function format_html with 3 arguments : string ( STR0 , return value of the function flatatt , called with an argument final_attrs and return value of the function force_text called with an argument value , return the result .	return format_html ( STR0 , flatatt ( final_attrs ) , force_text ( value ) )
9265	derive the class DateTimeBaseInput from the TextInput base class .	class DateTimeBaseInput ( TextInput ) :
9266	format key is an empty string .	format_key = STR
9267	supports_microseconds is boolean False .	supports_microseconds = False
9268	define the method __init__ with 3 arguments : self , attrs set to None and format is None .	def __init__ ( self , attrs = None , format = None ) :
9269	call the method __init__ from the base class of the class DateTimeBaseInput , with an argument attrs .	super ( DateTimeBaseInput , self ) . __init__ ( attrs )
9270	substitute format for self.format if format is true , if not self.format is None .	self . format = format if format else None
9271	define the method _format_value with 2 arguments : self and value .	def _format_value ( self , value ) :
9272	call the function formats.localize_input with 2 arguments : value and self.format if true , if not , then the first element of the result of the function formats.get_format called with an argument self.format_key , return the result .	return formats . localize_input ( value , self . format or formats . get_format ( self . format_key ) [ 0 ] )
9273	derive the class DateInput from the DateTimeBaseInput base class .	class DateInput ( DateTimeBaseInput ) :
9274	format_key is a string STR0 .	format_key = STR0
9275	derive the class DateTimeInput from the DateTimeBaseInput base class .	class DateTimeInput ( DateTimeBaseInput ) :
9276	format_key is a string STR0 .	format_key = STR0
9277	derive the class TimeInput from the DateTimeBaseInput base class .	class TimeInput ( DateTimeBaseInput ) :
9278	format_key is a string STR0 .	format_key = STR0
9279	define the function boolean_check with an argument v .	def boolean_check ( v ) :
9280	if v is boolean False or v is None or v is an empty string , return boolean False , otherwise return boolean True .	return not ( v is False or v is None or v == STR )
9281	derive the class CheckboxInput from the Widget base class .	class CheckboxInput ( Widget ) :
9282	define the method __init__ with 3 arguments : self , attrs set to None and check_test set to None .	def __init__ ( self , attrs = None , check_test = None ) :
9283	call the method __init__ from the base class of the class CheckboxInput , with an argument attrs .	super ( CheckboxInput , self ) . __init__ ( attrs )
9284	substitute boolean_check for self.check_test if check_test is None , otherwise substitute check_test for self.check_test .	self . check_test = boolean_check if check_test is None else check_test
9285	define the method render with 4 arguments : self , name , value and attrs set to None .	def render ( self , name , value , attrs = None ) :
9286	call the method self.build_attrs with 3 arguments : attrs , type as a string STR0 , name as name , substitute the result for final_attrs .	final_attrs = self . build_attrs ( attrs , type = STR0 , name = name )
9287	call the method self.check_test with an argument value , if it evaluates to true ,	if self . check_test ( value ) :
9288	substitute string STR0 for value under the STR1 key of final_attrs dictionary .	final_attrs [ STR0 ] = STR1
9289	if value is boolean False or boolean True or value is None or value is an empty string , do not perform the following ,	if not ( value is True or value is False or value is None or value == STR ) :
9290	call the function force_text with an argument value , substitute the result for value under the STR0 key of the final_attrs .	final_attrs [ STR0 ] = force_text ( value )
9291	return the result of the function format_html called with 2 arguments : string STR0 , and result of the function flatatt , called with an argument final_attrs .	return format_html ( STR0 , flatatt ( final_attrs ) )
9292	define the method value_from_datadict with 4 arguments : self , data , files and name .	def value_from_datadict ( self , data , files , name ) :
9293	if name is not contained in data ,	if name not in data :
9294	return boolean False .	return False
9295	get the name key of the data dictionary , substitute it for value .	value = data . get ( name )
9296	values is an dictionary with 2 arguments : boolean False for STR0 and boolean True for STR1 .	values = { STR0 : True , STR1 : False }
9297	if value is an instance of six.string_types class ,	if isinstance ( value , six . string_types ) :
9298	get the value of the values dictionary under the value converted to lowercase key , substitute it for value , if the key doesnt exists , substitute value for value .	value = values . get ( value . lower ( ) , value )
9299	return value converted into a boolean .	return bool ( value )
9300	derive the class Select from the Widget base class .	class Select ( Widget ) :
9301	allow_multiple_selected is boolean False .	allow_multiple_selected = False
9302	define the method __init__ with 3 arguments : self , attrs set to None and choices set to an empty tuple .	def __init__ ( self , attrs = None , choices = ( ) ) :
9303	call the method __init__ from the base class of the class Select , with an argument attrs .	super ( Select , self ) . __init__ ( attrs )
9304	convert elements of choices into a list , substitute it for self.choices .	self . choices = list ( choices )
9305	define the method render with 5 arguments : self , name , value , attrs set to None and choices set to an empty tuple .	def render ( self , name , value , attrs = None , choices = ( ) ) :
9306	if value is None ,	if value is None :
9307	value is an empty string .	value = STR
9308	call the method self.build_attrs with arguments attrs , name as name , substitute the result for final_attrs .	final_attrs = self . build_attrs ( attrs , name = name )
9309	output is a list containing an element : result of the function format_html called with 2 arguments : string STR0 , and return value of the function flatatt called with an argument final_attrs , substitute the result for output .	output = [ format_html ( STR0 , flatatt ( final_attrs ) ) ]
9310	call the method self.render_options with 2 arguments : choices and list with an entry , value , substitute the result for options .	options = self . render_options ( choices , [ value ] )
9311	if options is true ,	if options :
9312	append options to output .	output . append ( options )
9313	append string STR0 to output .	output . append ( STR0 )
9314	join elements of output into a string , separated by newline characters , use it as the argument for the call the function mark_safe , return the result .	return mark_safe ( STR0 . join ( output ) )
9315	define the method render_option with 4 arguments : self , selected_choices , option_value and option_label .	def render_option ( self , selected_choices , option_value , option_label ) :
9316	if option_value is None ,	if option_value is None :
9317	option_value is an empty string .	option_value = STR
9318	call the function force_text with an argument option_value , substitute the result for option_value .	option_value = force_text ( option_value )
9319	if option_value is contained in selected_choices ,	if option_value in selected_choices :
9320	call the function mark_safe with an argument string STR1 , substitute the result for selected_html .	selected_html = mark_safe ( STR1 )
9321	if self.allow_multiple_selected is false ,	if not self . allow_multiple_selected :
9322	call the method selected_choices.remove with an argument option_value .	selected_choices . remove ( option_value )
9323	if not ,	else :
9324	selected_html is an empty string .	selected_html = STR
9325	call the function format_html with 4 arguments : string STR1 , option_value , selected_html , result of the function force_text with an argument option_label , return the result .	return format_html ( STR1 , option_value , selected_html , force_text ( option_label ) )
9326	define the method render_options with 3 arguments : self , choices and selected_choices .	def render_options ( self , choices , selected_choices ) :
9327	call the function force_text with an argument v , for every v in selected_choices , add results to a set , substitute the resulting set for selected_choices .	selected_choices = set ( force_text ( v ) for v in selected_choices )
9328	output is an empty list .	output = [ ]
9329	call the function chain with arguments self.choices and choices , for every option_value and option_label in the result ,	for option_value , option_label in chain ( self . choices , choices ) :
9330	if option_label is an instance of list or tuple ,	if isinstance ( option_label , ( list , tuple ) ) :
9331	call the function format_html with 2 arguments : string STR1 and return value of the function force_text , called with an argument option_value , append the result to output .	output . append ( format_html ( STR1 , force_text ( option_value ) ) )
9332	for every option in option_label ,	for option in option_label :
9333	call the method self.render_option with 2 arguments : selected_choices and unpacked list option , append the result to output .	output . append ( self . render_option ( selected_choices , * option ) )
9334	append string STR0 to output .	output . append ( STR0 )
9335	if not ,	else :
9336	call the method self.render_option with 3 arguments : selected_choices , option_value and option_label , append the result to output .	output . append ( self . render_option ( selected_choices , option_value , option_label ) )
9337	join elements of output in a string , separated by newlines , return it .	return STR0 . join ( output )
9338	derive the class NullBooleanSelect from the Select base class .	class NullBooleanSelect ( Select ) :
9339	define the method __init__ with 2 arguments : self and attrs set to None .	def __init__ ( self , attrs = None ) :
9340	choices is a tuple with 3 elements : tuple with 2 elements : string STR0 and return value of the function ugettext_lazy , called with an argument string STR1 , tuple with 2 elements : string STR2 and return value of the function ugettext_lazy , called with an argument string STR3 and tuple with 2 elements : string STR4 and return value of the function ugettext_lazy , called with an argument string STR5 .	choices = ( ( STR0 , ugettext_lazy ( STR1 ) ) , ( STR2 , ugettext_lazy ( STR3 ) ) , ( STR4 , ugettext_lazy ( STR5 ) ) )
9341	call the method __init__ from the base class of the class NullBooleanSelect , with arguments attrs and choices .	super ( NullBooleanSelect , self ) . __init__ ( attrs , choices )
9342	define the method render with 5 arguments : self , name , value , attrs set to None and choices set to an empty tuple .	def render ( self , name , value , attrs = None , choices = ( ) ) :
9343	try ,	try :
9344	get the value under value key of a dictionary with 4 entries : STR0 for boolean True , STR1 for boolean False , STR2 for STR3 , and STR4 for STR5 , substitute it for value .	value = { True : STR0 , False : STR1 , STR2 : STR3 , STR4 : STR5 } [ value ]
9345	if KeyError exception is caught ,	except KeyError :
9346	value is an string STR0 .	value = STR0
9347	call the method render from the base class of the class NullBooleanSelect , with 4 arguments : name , value , attrs and choices , return the result .	return super ( NullBooleanSelect , self ) . render ( name , value , attrs , choices )
9348	define the method value_from_datadict with 4 arguments : self , data , files and name .	def value_from_datadict ( self , data , files , name ) :
9349	get the value under the name key of the data dictionary , if it exists substitute it for value , if not , value is None .	value = data . get ( name , None )
9350	get the value under the value key of a dictionary with 6 entries : boolean True for STR0 , boolean True for boolean True , boolean True for STR1 , boolean False for STR2 , boolean False for STR3 and boolean False for boolean False , return it if the key exists , if not return None .	return { STR0 : True , True : True , STR1 : True , STR2 : False , STR3 : False , False : False } . get ( value , None )
9351	derive the class SelectMultiple from the Select base class .	class SelectMultiple ( Select ) :
9352	allow_multiple_selected is boolean True .	allow_multiple_selected = True
9353	define the method render with 5 arguments : self , name , value , attrs set to None and choices set to an empty tuple .	def render ( self , name , value , attrs = None , choices = ( ) ) :
9354	if value is None ,	if value is None :
9355	value is an empty list .	value = [ ]
9356	call the method self.build_attrs with 2 arguments : attrs and name set to name , substitute the result for final_attrs .	final_attrs = self . build_attrs ( attrs , name = name )
9357	output is a list containing an entry : result of the function format_html called with 2 arguments : string STR1 and result of the function flatatt called with an argument final_attrs .	output = [ format_html ( STR1 , flatatt ( final_attrs ) ) ]
9358	call the method self.render_options with 2 arguments : choices and value , substitute the result for options .	options = self . render_options ( choices , value )
9359	if options is true ,	if options :
9360	append options to output .	output . append ( options )
9361	append string STR0 to output .	output . append ( STR0 )
9362	join elements of output into a string , separated with newline character , use it as an argument for the call to the mark_safe function , return the result .	return mark_safe ( STR0 . join ( output ) )
9363	define the method value_from_datadict with 4 arguments : self , data , files and name .	def value_from_datadict ( self , data , files , name ) :
9364	if data is an instance of MultiValueDict or MergeDict ,	if isinstance ( data , ( MultiValueDict , MergeDict ) ) :
9365	call the method data.getlist with an argument name , return the result .	return data . getlist ( name )
9366	get the value under the name key of the data dictionary , if it exists return it , if not return None .	return data . get ( name , None )
9367	python_2_unicode_compatible decorator ,	@ python_2_unicode_compatible
9368	derive the class ChoiceInput from the SubWidget base class .	class ChoiceInput ( SubWidget ) :
9369	input_type is None .	input_type = None
9370	define the method __init__ with 6 arguments : self , name , value , attrs , choice and index .	def __init__ ( self , name , value , attrs , choice , index ) :
9371	substitute name for self.name .	self . name = name
9372	substitute value for self.value .	self . value = value
9373	substitute attrs for self.attrs .	self . attrs = attrs
9374	call the function force_text with first element of choice as an argument , substitute the result for self.choice_value .	self . choice_value = force_text ( choice [ 0 ] )
9375	call the function force_text with second element of choice as an argument , substitute the result for self.choice_label .	self . choice_label = force_text ( choice [ 1 ] )
9376	substitute index for self.index .	self . index = index
9377	if string STR0 is contained in self.attrs ,	if STR0 in self . attrs :
9378	convert self.index into a string and append it to STR0 string , substitute it for value under the STR1 key of self.attrs dictionary .	self . attrs [ STR1 ] += STR0 % self . index
9379	define the method __str__ with an argument self .	def __str__ ( self ) :
9380	call the method self.render , return the result .	return self . render ( )
9381	define the method render with 5 arguments : self , name set to None , value set to None , attrs set to None and choices set to an empty tuple .	def render ( self , name = None , value = None , attrs = None , choices = ( ) ) :
9382	self.id_for_label is true ,	if self . id_for_label :
9383	call the function format_html with 2 arguments : string STR1 and self.id_for_label , substitute the result for label_for .	label_for = format_html ( STR1 , self . id_for_label )
9384	if not ,	else :
9385	label_for is an empty string .	label_for = STR
9386	call the function format_html with 4 arguments : string STR0 , label_for , result of the method self.tag , and self.choice_label , return the result .	return format_html ( STR0 , label_for , self . tag ( ) , self . choice_label )
9387	define the method is_checked with an argument self .	def is_checked ( self ) :
9388	if self.value equals self.choice_value , return boolean True , if not , return boolean False .	return self . value == self . choice_value
9389	define the method tag with an argument self .	def tag ( self ) :
9390	call the method dict with 4 : self.attrs , type as self.input_type , name as self.name , value as self.choice_value , substitute the result for final_attrs .	final_attrs = dict ( self . attrs , type = self . input_type , name = self . name , value = self . choice_value )
9391	call the method self.is_checked , if it evaluates to true ,	if self . is_checked ( ) :
9392	substitute string STR0 for value under the STR1 key of final_attrs dictionary .	final_attrs [ STR0 ] = STR1
9393	call the function format_html with 2 arguments : string STR0 and result of the function flatatt , called with an argument final_attrs , return the result .	return format_html ( STR0 , flatatt ( final_attrs ) )
9394	property decorator ,	@ property
9395	define the method id_for_label with an argument self .	def id_for_label ( self ) :
9396	get the value under the STR0 key of the self.attrs dictionary , return it , if the key doesnt exists return an empty string .	return self . attrs . get ( STR0 , STR )
9397	derive the class RadioChoiceInput from the ChoiceInput base class .	class RadioChoiceInput ( ChoiceInput ) :
9398	input_type is a string STR0 .	input_type = STR0
9399	define the method __init__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , * args , ** kwargs ) :
9400	call the method __init__ from the base class of the class RadioChoiceInput , with 2 arguments : unpacked list args , and unpacked dictionary kwargs .	super ( RadioChoiceInput , self ) . __init__ ( * args , ** kwargs )
9401	call the function force_text with an argument self.value , substitute the result for self.value .	self . value = force_text ( self . value )
9402	derive the class CheckboxChoiceInput from the ChoiceInput base class .	class CheckboxChoiceInput ( ChoiceInput ) :
9403	input_type is a string STR0 .	input_type = STR0
9404	define the method __init__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , * args , ** kwargs ) :
9405	call the method __init__ from the base class of the class CheckboxChoiceInput , with 2 arguments : unpacked list args , and unpacked dictionary kwargs .	super ( CheckboxChoiceInput , self ) . __init__ ( * args , ** kwargs )
9406	for every v in self.value call the function force_text with an argument v , add the result to a set , substitute set of the results for self.value .	self . value = set ( force_text ( v ) for v in self . value )
9407	define the method is_checked with an argument self .	def is_checked ( self ) :
9408	if self.choice_value is contained in self.value return boolean True , otherwise return boolean False .	return self . choice_value in self . value
9409	python_2_unicode_compatible decorator ,	@ python_2_unicode_compatible
9410	derive the class ChoiceFieldRenderer from the object base class .	class ChoiceFieldRenderer ( object ) :
9411	choice_input_class is None .	choice_input_class = None
9412	outer_html is a string STR0 .	outer_html = STR0
9413	inner_html is a string STR0 .	inner_html = STR0
9414	define the method __init__ with 5 arguments : self , name , value , attrs and choices .	def __init__ ( self , name , value , attrs , choices ) :
9415	substitute name for self.name .	self . name = name
9416	substitute value for self.value .	self . value = value
9417	substitute attrs for self.attrs .	self . attrs = attrs
9418	substitute choices for self.choices .	self . choices = choices
9419	define the method __getitem__ with 2 arguments : self and idx .	def __getitem__ ( self , idx ) :
9420	substitute idx-th element of self.choices for choice .	choice = self . choices [ idx ]
9421	call the method self.choice_input_class with 5 arguments : self.name , self.value , result of the method self.attrs.copy , choice and idx , return the result .	return self . choice_input_class ( self . name , self . value , self . attrs . copy ( ) , choice , idx )
9422	define the method __str__ with an argument self .	def __str__ ( self ) :
9423	call the method self.render , return the result .	return self . render ( )
9424	define the method render with an argument self .	def render ( self ) :
9425	get the value under the STR0 key of the self.attrs dictionary , substitute it for id_ if the key exists , if not id_ is None .	id_ = self . attrs . get ( STR0 , None )
9426	output is an empty list .	output = [ ]
9427	for every i and choice in enumerated iterable self.choices ,	for i , choice in enumerate ( self . choices ) :
9428	substitute choice for choice_value and choice_label , respectively .	choice_value , choice_label = choice
9429	if choice_label is an instance of tuple or list ,	if isinstance ( choice_label , ( tuple , list ) ) :
9430	call the method self.attrs.copy , substitute the result for attrs_plus .	attrs_plus = self . attrs . copy ( )
9431	if id_ is true ,	if id_ :
9432	prepend string STR0 to i converted to an string , append the result to the value under the STR1 key of the attrs_plus .	attrs_plus [ STR0 ] += STR1 . format ( i )
9433	sub_ul_renderer is an instance of ChoiceFieldRenderer class , created with 4 arguments : name as self.name , value as self.value , attrs as attrs_plus and choices as choice_label .	sub_ul_renderer = ChoiceFieldRenderer ( name = self . name , value = self . value , attrs = attrs_plus , choices = choice_label )
9434	substitute self.choice_input_class for sub_ul_renderer.choice_input_class .	sub_ul_renderer . choice_input_class = self . choice_input_class
9435	call the function format_html with 3 arguments : self.inner_html , choice_value set to choice_value , and sub_widgets set to return value of the function sub_ul_renderer.render , append the result to output .	output . append ( format_html ( self . inner_html , choice_value = choice_value , sub_widgets = sub_ul_renderer . render ( ) ) )
9436	if not ,	else :
9437	call the method self.choice_input_class with 5 arguments : self.name , self.value , return value of the method self.attrs.copy , choice and i , substitute the result for w .	w = self . choice_input_class ( self . name , self . value , self . attrs . copy ( ) , choice , i )
9438	call the function format_html with 3 arguments : self.inner_html , choice_value set to result of the function force_text , called with an argument w , and sub_widgets as an empty string , append the result to output .	output . append ( format_html ( self . inner_html , choice_value = force_text ( w ) , sub_widgets = STR ) )
9439	call the function format_html with 3 arguments : self.outer_html , if id_ is true id_attr set to return value of the function format_html , if not id_attr set to an empty string , content set to result of the function mark_safe with an argument : string created by joining elements of outputs , with STR0 separator , return the result .	return format_html ( self . outer_html , id_attr = format_html ( STR1 , id_ ) if id_ else STR , content = mark_safe ( STR2 . join ( output ) ) )
9440	derive the class RadioFieldRenderer from the ChoiceFieldRenderer base class .	class RadioFieldRenderer ( ChoiceFieldRenderer ) :
9441	substitute RadioChoiceInput for choice_input_class .	choice_input_class = RadioChoiceInput
9442	derive the class CheckboxFieldRenderer from the ChoiceFieldRenderer base class .	class CheckboxFieldRenderer ( ChoiceFieldRenderer ) :
9443	substitute CheckboxChoiceInput for choice_input_class .	choice_input_class = CheckboxChoiceInput
9444	derive the class RendererMixin from the object base class .	class RendererMixin ( object ) :
9445	renderer is None .	renderer = None
9446	_empty_value is None .	_empty_value = None
9447	define the method __init__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , * args , ** kwargs ) :
9448	remove entry under STR0 key of the kwargs dictionary and substitute it for renderer , if the key doesnt exists , renderer is None .	renderer = kwargs . pop ( STR0 , None )
9449	if renderer is true ,	if renderer :
9450	substitute renderer for self.renderer .	self . renderer = renderer
9451	call the method __init__ from the base class of the class RendererMixin , with 2 arguments : unpacked list args , and unpacked dictionary kwargs .	super ( RendererMixin , self ) . __init__ ( * args , ** kwargs )
9452	define the method subwidgets with 5 arguments : self , name , value , attrs set to None and choices set to an empty tuple .	def subwidgets ( self , name , value , attrs = None , choices = ( ) ) :
9453	call the method self.get_renderer with 4 arguments : name , value , attrs and choices , for every widget in result ,	for widget in self . get_renderer ( name , value , attrs , choices ) :
9454	yield widget .	yield widget
9455	define the method get_renderer with 5 arguments : self , name , value , attrs set to None and choices set to an empty tuple .	def get_renderer ( self , name , value , attrs = None , choices = ( ) ) :
9456	if value is None ,	if value is None :
9457	substitute self._empty_value for value .	value = self . _empty_value
9458	call the method self.build_attrs with an argument attrs , substitute the result for final_attrs .	final_attrs = self . build_attrs ( attrs )
9459	call the function chain with 2 arguments : self.choices and choices , convert the result into a list and substitute it for choices .	choices = list ( chain ( self . choices , choices ) )
9460	call the method self.renderer with 4 arguments : name , value , final_attrs and choices , return the result .	return self . renderer ( name , value , final_attrs , choices )
9461	define the method render with 5 arguments : self , name , value , attrs set to None and choices set to an empty tuple .	def render ( self , name , value , attrs = None , choices = ( ) ) :
9462	call the method self.get_renderer with 4 arguments : name , value , attrs and choices , call the render method on the result , return the result .	return self . get_renderer ( name , value , attrs , choices ) . render ( )
9463	define the method id_for_label with 2 arguments : self and id_ .	def id_for_label ( self , id_ ) :
9464	if id_ is true ,	if id_ :
9465	append string STR0 to id_ .	id_ += STR0
9466	return id_ .	return id_
9467	derive the class RadioSelect from the RendererMixin and Select base classes .	class RadioSelect ( RendererMixin , Select ) :
9468	substitute RadioFieldRenderer for renderer .	renderer = RadioFieldRenderer
9469	_empty_value is an empty string .	_empty_value = STR
9470	derive the class CheckboxSelectMultiple from the RendererMixin and SelectMultiple base classes .	class CheckboxSelectMultiple ( RendererMixin , SelectMultiple ) :
9471	substitute CheckboxFieldRenderer for renderer .	renderer = CheckboxFieldRenderer
9472	_empty_value is an empty list .	_empty_value = [ ]
9473	derive the class MultiWidget from the Widget base class .	class MultiWidget ( Widget ) :
9474	define the method __init__ with 3 arguments : self , widgets and attrs set to None .	def __init__ ( self , widgets , attrs = None ) :
9475	for every w in widgets , call the function w and append the result to a list , if w is an instance of type class , if not append w to the list , substitute the resulting list for self.widgets .	self . widgets = [ w ( ) if isinstance ( w , type ) else w for w in widgets ]
9476	call the method __init__ from the base class of the class MultiWidget , with an argument attrs .	super ( MultiWidget , self ) . __init__ ( attrs )
9477	property decorator ,	@ property
9478	define the method is_hidden with an argument self .	def is_hidden ( self ) :
9479	for every w in self.widgets , if all elements w.is_hidden are true , return boolean True , otherwise return boolean False .	return all ( w . is_hidden for w in self . widgets )
9480	define the method render with 4 arguments : self , name , value and attrs set to None .	def render ( self , name , value , attrs = None ) :
9481	if self.is_localized is true ,	if self . is_localized :
9482	for every bwidget in self.widgets ,	for widget in self . widgets :
9483	substitute self.is_localized for widget.is_localized .	widget . is_localized = self . is_localized
9484	if value is not an instance of list type ,	if not isinstance ( value , list ) :
9485	call the method self.decompress with an argument value , substitute the result for value .	value = self . decompress ( value )
9486	output is an empty list .	output = [ ]
9487	call the method self.build_attrs with an argument attrs , substitute the result for final_attrs .	final_attrs = self . build_attrs ( attrs )
9488	get the value under the STR0 key of the final_attrs dictionary , substitute it for id_ , if it doesnt exists , id_ is None .	id_ = final_attrs . get ( STR0 , None )
9489	for every i and widget in enumerated iterable self.widgets ,	for i , widget in enumerate ( self . widgets ) :
9490	try ,	try :
9491	substitute i-th element of value for widget_value .	widget_value = value [ i ]
9492	if IndexError exception is caught ,	except IndexError :
9493	widget_value is None .	widget_value = None
9494	if id_ is true ,	if id_ :
9495	call the dict function with 2 arguments : final_attrs and id set to string STR0 , where STR1 is replaced with id_ and i , substitute the result for final_attrs .	final_attrs = dict ( final_attrs , id = STR0 % ( id_ , i ) )
9496	call the method widget.render with 3 arguments : string created by concatenation from : name , string STR0 and i , widget_value , and final_attrs , append the result to output .	output . append ( widget . render ( name + STR0 % i , widget_value , final_attrs ) )
9497	call the method self.format_output with an argument output , use the result as an argument for the call to the function mark_safe , return the result .	return mark_safe ( self . format_output ( output ) )
9498	define the method id_for_label with 2 arguments : self and id_ .	def id_for_label ( self , id_ ) :
9499	if id_ is true ,	if id_ :
9500	append string STR0 to id_ .	id_ += STR0
9501	return id_ .	return id_
9502	define the method value_from_datadict with 2 arguments : self , data , files and name .	def value_from_datadict ( self , data , files , name ) :
9503	for every i and widget in enumerated iterable self.widgets , call the function widget.value_from_datadict with 3 arguments : data , files and string created with concatenation of : name , string STR0 and i converted into a string , return the results in a list .	return [ widget . value_from_datadict ( data , files , name + STR0 % i ) for i , widget in enumerate ( self . widgets ) ]
9504	define the method format_output with 2 arguments : self and rendered_widgets .	def format_output ( self , rendered_widgets ) :
9505	join rendered_widgets into a string , return it .	return STR . join ( rendered_widgets )
9506	define the method decompress with 2 arguments : self and value .	def decompress ( self , value ) :
9507	raise NotImplementedError exception with an argument string STR0 .	raise NotImplementedError ( STR0 )
9508	define the method _get_media with an argument self .	def _get_media ( self ) :
9509	media is an instance of Media class .	media = Media ( )
9510	for every w in self.widgets ,	for w in self . widgets :
9511	sum media and w.media , substitute the result for media .	media = media + w . media
9512	return media .	return media
9513	media is a property object of the current class , with _get_media as getter function .	media = property ( _get_media )
9514	define the method __deepcopy__ with 2 arguments : self and memo .	def __deepcopy__ ( self , memo ) :
9515	call the method __deepcopy__ from the base class of the class MultiWidget , with an argument memo , substitute the result for obj .	obj = super ( MultiWidget , self ) . __deepcopy__ ( memo )
9516	call the method copy.deepcopy with an argument self.widgets , substitute the result for obj.widgets .	obj . widgets = copy . deepcopy ( self . widgets )
9517	return obj .	return obj
9518	property decorator ,	@ property
9519	define the method needs_multipart_form with an argument self .	def needs_multipart_form ( self ) :
9520	if any w.needs_multipart_form for every w in self.widgets is true , return boolean True , if not return boolean False .	return any ( w . needs_multipart_form for w in self . widgets )
9521	derive the class SplitDateTimeWidget from the MultiWidget base class .	class SplitDateTimeWidget ( MultiWidget ) :
9522	supports_microseconds is boolean False .	supports_microseconds = False
9523	define the method __init__ with 4 arguments : self , attrs set to None , date_format set to None and time_format set to None .	def __init__ ( self , attrs = None , date_format = None , time_format = None ) :
9524	widgets is a tuple with 2 elements : instance of DateInput class , created with 2 arguments : attrs as attrs and format as date_format , and instance of TimeInput class , created with 2 arguments : attrs set to attrs and format set to date_format .	widgets = ( DateInput ( attrs = attrs , format = date_format ) , TimeInput ( attrs = attrs , format = time_format ) )
9525	call the method __init__ from the base class of the class SplitDateTimeWidget , with 2 arguments : widgets and attrs .	super ( SplitDateTimeWidget , self ) . __init__ ( widgets , attrs )
9526	define the method decompress with 2 arguments : self and value .	def decompress ( self , value ) :
9527	if value is true ,	if value :
9528	call the function to_current_timezone with an argument , substitute the result for value .	value = to_current_timezone ( value )
9529	return a list containing 2 elements : return value of the value.date method and return value of the replace method , called with the argument microseconds set to integer 0 , on the result of the method value.time .	return [ value . date ( ) , value . time ( ) . replace ( microsecond = 0 ) ]
9530	return list containing 2 elements : None and None .	return [ None , None ]
9531	derive the class SplitHiddenDateTimeWidget from the SplitDateTimeWidget base class .	class SplitHiddenDateTimeWidget ( SplitDateTimeWidget ) :
9532	define the method render with 4 arguments : self , attrs set to None , date_format set to None and time_format set to None .	def __init__ ( self , attrs = None , date_format = None , time_format = None ) :
9533	call the method __init__ from the base class of the class SplitHiddenDateTimeWidget , with 3 arguments : attrs , date_format , and time_format .	super ( SplitHiddenDateTimeWidget , self ) . __init__ ( attrs , date_format , time_format )
9534	for every widget in self.widgets : ,	for widget in self . widgets :
9535	widget.input_type is a string STR0 .	widget . input_type = STR0
9536	from django.http.cookie import SimpleCookie and parse_cookie into default name space .	from django . http . cookie import SimpleCookie , parse_cookie
9537	from django.http.request import HttpRequest , QueryDict , RawPostDataException , UnreadablePostError and build_request_repr into default name space .	from django . http . request import ( HttpRequest , QueryDict , RawPostDataException , UnreadablePostError , build_request_repr )
9538	from django.http.response import HttpResponse , StreamingHttpResponse , HttpResponseRedirect , HttpResponsePermanentRedirect , HttpResponseNotModified , HttpResponseBadRequest , HttpResponseForbidden , HttpResponseNotFound , HttpResponseNotAllowed , HttpResponseGone , HttpResponseServerError , Http404 , BadHeaderError , JsonResponse into default name space .	from django . http . response import ( HttpResponse , StreamingHttpResponse , HttpResponseRedirect , HttpResponsePermanentRedirect , HttpResponseNotModified , HttpResponseBadRequest , HttpResponseForbidden , HttpResponseNotFound , HttpResponseNotAllowed , HttpResponseGone , HttpResponseServerError , Http404 , BadHeaderError , JsonResponse )
9539	from django.http.utils import fix_location_header and conditional_content_removal into default name space .	from django . http . utils import fix_location_header , conditional_content_removal
9540	__all__ is a list of strings , STR0 , STR1 , STR2 , STR3 , STR4 ,	__all__ = [ STR0 , STR1 , STR2 , STR3 , STR4 , STR5 , STR6 , STR7 , STR8 , STR9 , STR10 , STR11 , STR12 , STR13 , STR14 , STR15 , STR16 , STR17 , STR18 , STR19 , STR20 , STR21 , STR22 , ]
9541	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
9542	from django.utils.encoding import force_st into default name space .	from django . utils . encoding import force_str
9543	from django.utils import six into default name space .	from django . utils import six
9544	from django.utils.six.moves import http_cookies into default name space .	from django . utils . six . moves import http_cookies
9545	call the function http_cookies.SimpleCookie , on the return value call the value_encode method , with the argument character STR1 , if the tuple result equals to tuple containing character STR2 and string STR3 , respectively , assign _cookie_encodes_correctly the boolean True value , otherwise assign it False .	_cookie_encodes_correctly = http_cookies . SimpleCookie ( ) . value_encode ( STR1 ) == ( STR2 , STR3 )
9546	assign return value of the call to the http_cookies.SimpleCookie function to _tc .	_tc = http_cookies . SimpleCookie ( )
9547	try ,	try :
9548	call the _tc.load method with the STR0 converted to string as an argument .	_tc . load ( str ( STR0 ) )
9549	_cookie_allows_colon_in_names is a boolean True .	_cookie_allows_colon_in_names = True
9550	if http_cookies.CookieError exception is caught ,	except http_cookies . CookieError :
9551	_cookie_allows_colon_in_names is boolean False .	_cookie_allows_colon_in_names = False
9552	if _cookie_encodes_correctly and _cookie_allows_colon_in_names are boolean True ,	if _cookie_encodes_correctly and _cookie_allows_colon_in_names :
9553	substitute http_cookies.SimpleCookie for SimpleCookie .	SimpleCookie = http_cookies . SimpleCookie
9554	if not ,	else :
9555	substitute http_cookies.Morsel for Morsel .	Morsel = http_cookies . Morsel
9556	derive class SimpleCookie from the base class http_cookies.SimpleCookie .	class SimpleCookie ( http_cookies . SimpleCookie ) :
9557	if _cookie_encodes_correctly is boolean False ,	if not _cookie_encodes_correctly :
9558	define method value_encode with self class instance and val as arguments .	def value_encode ( self , val ) :
9559	from the base class of the class SimpleCookie call the value_encode method with val as the argument , store the result in the val and encoded , respectively .	val , encoded = super ( SimpleCookie , self ) . value_encode ( val )
9560	in encoded , replace all the occurrences of unicode character STR0 with STR2 character and STR1 with STR3 characters .	encoded = encoded . replace ( STR0 , STR1 ) . replace ( STR2 , STR3 )
9561	if encoded contains string STR0 and if encoded doesnt start with the double quote symbol ,	if STR0 in encoded and not encoded . startswith ( STR ) :
9562	put the double qoutes around encoded .	encoded = STR + encoded + STR
9563	return val and encoded as a tuple .	return val , encoded
9564	if _cookie_allows_colon_in_names is False ,	if not _cookie_allows_colon_in_names :
9565	define the method load with self class instance and rawdata as arguments .	def load ( self , rawdata ) :
9566	self.bad_cookies is an empty set .	self . bad_cookies = set ( )
9567	if six.PY2 is true and rawdata is an instance of the type six.text_type .	if six . PY2 and isinstance ( rawdata , six . text_type ) :
9568	call the function force_str with raw data as an argument and substitute it for rawdata .	rawdata = force_str ( rawdata )
9569	from the base class of the SimpleCookie class call the method load with rawdata as argument .	super ( SimpleCookie , self ) . load ( rawdata )
9570	for every key is self.bad_cookies ,	for key in self . bad_cookies :
9571	delete self entry under the key key .	del self [ key ]
9572	define protected method _BaseCookie__set with self class instance , key , real_value and coded_value as arguments .	def _BaseCookie__set ( self , key , real_value , coded_value ) :
9573	evaluate the function force_str with key as the argument , substitute it for key .	key = force_str ( key )
9574	try ,	try :
9575	get the value under the key of the dictionary self , if key does not exists return evaluated result of the function Morsel , substitute it for M .	M = self . get ( key , Morsel ( ) )
9576	call the M.set method with the key , real_value , coded_value as the arguments .	M . set ( key , real_value , coded_value )
9577	call the private dict.__setitem__ method with self class instance , key and M as arguments .	dict . __setitem__ ( self , key , M )
9578	if http_cookies.CookieError exception is raised .	except http_cookies . CookieError :
9579	if self does not have STR0 attribute ,	if not hasattr ( self , STR0 ) :
9580	self.bad_cookies is an empty set .	self . bad_cookies = set ( )
9581	add key to the self.bad_cookies set .	self . bad_cookies . add ( key )
9582	call the private dict.__setitem__ method with self class instance , key and result of the function http_cookies.Morsel ( ) as arguments .	dict . __setitem__ ( self , key , http_cookies . Morsel ( ) )
9583	define the function parse_cookie with cookie as the argument .	def parse_cookie ( cookie ) :
9584	if cookie is an empty string ,	if cookie == STR :
9585	return an empty dictionary .	return { }
9586	if cookie is not an instance of http_cookies.BaseCookie ,	if not isinstance ( cookie , http_cookies . BaseCookie ) :
9587	try ,	try :
9588	c is an instance of the class SimpleCookie .	c = SimpleCookie ( )
9589	call the load method on the c class instance , with the cookie argument .	c . load ( cookie )
9590	if http_cookies.CookieError exception is raised ,	except http_cookies . CookieError :
9591	return an empty dictionary .	return { }
9592	if not ,	else :
9593	substitute cookie for c .	c = cookie
9594	cookiedict is an empty dictionary .	cookiedict = { }
9595	for every key in return value of the method c.keys call ,	for key in c . keys ( ) :
9596	get the value filed from the return value of the call to the c.key with the argument key , add the value to the cookiedict under the key key .	cookiedict [ key ] = c . get ( key ) . value
9597	return cookiedict .	return cookiedict
9598	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
9599	import module base64 .	import base64
9600	import module binascii .	import binascii
9601	import module cgi .	import cgi
9602	import module sys .	import sys
9603	from django.conf import settings into default name space .	from django . conf import settings
9604	from django.core.exceptions import SuspiciousMultipartF into default name space .	from django . core . exceptions import SuspiciousMultipartForm
9605	from django.utils.datastructures import MultiValueDict into default name space .	from django . utils . datastructures import MultiValueDict
9606	from django.utils.encoding import force_text into default name space .	from django . utils . encoding import force_text
9607	from django.utils import six into default name space .	from django . utils import six
9608	from django.utils.text import unescape_entities into default name space .	from django . utils . text import unescape_entities
9609	from django.core.files.uploadhandler import StopUpload , SkipFile and StopFutureHandlers into default name space .	from django . core . files . uploadhandler import StopUpload , SkipFile , StopFutureHandlers
9610	__all__ is an tuple with 3 elements : strings STR0 , STR1 and STR2 .	__all__ = ( STR0 , STR1 , STR2 )
9611	derive the class MultiPartParserError from the Exception base class .	class MultiPartParserError ( Exception ) :
9612	do nothing .	pass
9613	derive the class InputStreamExhausted from the Exception base class .	class InputStreamExhausted ( Exception ) :
9614	do nothing .	pass
9615	RAW is a string STR0 .	RAW = STR0
9616	FILE is a file '' .	FILE = STR0
9617	FIELD is a field '' .	FIELD = STR0
9618	if six.PY2 is true , _BASE64_DECODE_ERROR is TypeError , if not , _BASE64_DECODE_ERROR is binascii.Error .	_BASE64_DECODE_ERROR = TypeError if six . PY2 else binascii . Error
9619	derive the class MultiPartParser from the object base class .	class MultiPartParser ( object ) :
9620	define the method __init__ wiht 5 arguments : self , META , input_data , upload_handlers and encoding set to None .	def __init__ ( self , META , input_data , upload_handlers , encoding = None ) :
9621	get the value from META dictionary , under the STR0 key , if the key doesnt exist , return the value under the STR1 of the META dictionary , if it doesnt exist return an empty string , substitute the result for content_type .	content_type = META . get ( STR0 , META . get ( STR1 , STR ) )
9622	if content_type doesnt start with string STR0 ,	if not content_type . startswith ( STR0 ) :
9623	raise an MultiPartParserError with an argument string STR0 , where STR1 is replaced with content_type .	raise MultiPartParserError ( STR0 % content_type )
9624	call the method boundary with an argument string STR0 , use the result to call to the parse_header function , assign the result to ctypes and opts .	ctypes , opts = parse_header ( content_type . encode ( STR0 ) )
9625	get the value under the STR0 key of the opts dictionary , substitute it for boundary .	boundary = opts . get ( STR0 )
9626	if boundary is false or return value of the method cgi.valid_boundary called with an argument boundary evaluates to false ,	if not boundary or not cgi . valid_boundary ( boundary ) :
9627	raise an MultiPartParserError with an argument string STR0 is replaced with boundary .	raise MultiPartParserError ( STR0 % boundary )
9628	try ,	try :
9629	convert value under the STR0 key of the META dictionary to an integer of base of value under the STR1 key of META dictionary , if the key doesnt exists use 0 as the base , substitute the result for content_length .	content_length = int ( META . get ( STR0 , META . get ( STR1 , 0 ) ) )
9630	if ValueError or TypeError are caught ,	except ( ValueError , TypeError ) :
9631	content_length is integer 0 .	content_length = 0
9632	if content_length is lesser than integer 0 ,	if content_length < 0 :
9633	raise an MultiPartParserError with an argument string STR0 , where STR1 is replaced with content_length .	raise MultiPartParserError ( STR0 % content_length )
9634	if boundary is an instance of six.text_type class ,	if isinstance ( boundary , six . text_type ) :
9635	call the method boundary.encode with an argument string STR0 , substitute the result for boundary .	boundary = boundary . encode ( STR0 )
9636	substitute boundary for self._boundary .	self . _boundary = boundary
9637	substitute input_data for self._input_data .	self . _input_data = input_data
9638	for every x in upload_handlers if x.chunk_size is true , append x.chunk_size to a list , substitute the result for possible_sizes .	possible_sizes = [ x . chunk_size for x in upload_handlers if x . chunk_size ]
9639	bring integer 2 to the power of 31 , subtract the result by 4 , put the result into a list , append possible_sizes to it , substitute minimal element of the resulting list for self._chunk_size .	self . _chunk_size = min ( [ 2 ** 31 - 4 ] + possible_sizes )
9640	substitute META for self._meta .	self . _meta = META
9641	if encoding is true , substitute it for self._encoding , if not substitute settings.DEFAULT_CHARSET for self._encoding .	self . _encoding = encoding or settings . DEFAULT_CHARSET
9642	substitute content_length for self._content_length .	self . _content_length = content_length
9643	substitute _upload_handlers for self.__upload_handlers .	self . _upload_handlers = upload_handlers
9644	define the method parse with an argument self .	def parse ( self ) :
9645	from django.http import QueryDict into default namespace .	from django . http import QueryDict
9646	substitute self._encoding for encoding .	encoding = self . _encoding
9647	substitute self._upload_handlers for handlers .	handlers = self . _upload_handlers
9648	if self._content_length equals integer 0 ,	if self . _content_length == 0 :
9649	instantiate QueryDict class with 2 arguments : an empty string and encoding set to self._encoding , instantiate a class MultiValueDict , return them .	return QueryDict ( STR , encoding = self . _encoding ) , MultiValueDict ( )
9650	for every handler in handlers ,	for handler in handlers :
9651	call the method handler.handle_raw_input with 5 arguments : self._input_data , self._meta , self._content_length , self._boundary , and encoding , substitute the result for result .	result = handler . handle_raw_input ( self . _input_data , self . _meta , self . _content_length , self . _boundary , encoding )
9652	if result is not None ,	if result is not None :
9653	return first and second element of result .	return result [ 0 ] , result [ 1 ]
9654	self._post is an instance of QueryDict class , created with an empty string and mutable set to boolean True .	self . _post = QueryDict ( STR , mutable = True )
9655	self._files is an instance of MultiValueDict class .	self . _files = MultiValueDict ( )
9656	instantiate class ChunkIter with 2 arguments : self._input_data and self._chunk_size , use it to instantiate LazyStream class , assign the handle to stream .	stream = LazyStream ( ChunkIter ( self . _input_data , self . _chunk_size ) )
9657	old_field_name is None .	old_field_name = None
9658	counters is a list containing length of handlers number of zeros .	counters = [ 0 ] * len ( handlers )
9659	try ,	try :
9660	call the Parser object with stream and self._boundary , for every item_type , meta_data and field_stream in return value ,	for item_type , meta_data , field_stream in Parser ( stream , self . _boundary ) :
9661	if old_field_name is true ,	if old_field_name :
9662	call the method self.handle_file_complete with arguments old_field_name , counters .	self . handle_file_complete ( old_field_name , counters )
9663	old_field_name is None .	old_field_name = None
9664	try ,	try :
9665	get the value under the STR0 key of the meta_data dictionary , substitute second element of it for disposition .	disposition = meta_data [ STR0 ] [ 1 ]
9666	get the value under the STR0 key of the disposition dictionary , strip it of whitespaces , substitute the result for field_name .	field_name = disposition [ STR0 ] . strip ( )
9667	if KeyError , IndexError and AttributeError exception is caught ,	except ( KeyError , IndexError , AttributeError ) :
9668	skip this loop iteration ,	continue
9669	get the value under the STR0 key of the disposition meta_data , substitute it for transfer_encoding .	transfer_encoding = meta_data . get ( STR0 )
9670	if transfer_encoding is not None ,	if transfer_encoding is not None :
9671	strip of the whitespaces first element of transfer_encoding , substitute the result for transfer_encoding .	transfer_encoding = transfer_encoding [ 0 ] . strip ( )
9672	call the function force_text with 3 arguments : field_name , encoding and errors as a string STR0 , substitute the result for field_name .	field_name = force_text ( field_name , encoding , errors = STR0 )
9673	if item_type equals FIELD ,	if item_type == FIELD :
9674	if transfer_encoding equals a string STR0 ,	if transfer_encoding == STR0 :
9675	call the method field_stream.read , substitute the result for raw_data .	raw_data = field_stream . read ( )
9676	try ,	try :
9677	call the function base64.b64decode with an argument raw_data , substitute the result for data .	data = base64 . b64decode ( raw_data )
9678	if _BASE64_DECODE_ERROR exception is caught ,	except _BASE64_DECODE_ERROR :
9679	substitute raw_data for data .	data = raw_data
9680	if not ,	else :
9681	call the method field_stream.read , substitute the result for data .	data = field_stream . read ( )
9682	call the method self._post.appendlist with 2 arguments : field_name and result of the function force_text called with 3 arguments : data , encoding and errors as a string STR0 .	self . _post . appendlist ( field_name , force_text ( data , encoding , errors = STR0 ) )
9683	otherwise if item_type equals FILE ,	elif item_type == FILE :
9684	get the value under the STR0 key of the disposition dictionary , substitute it for file_name .	file_name = disposition . get ( STR0 )
9685	if file_name is false ,	if not file_name :
9686	skip this loop execution .	continue
9687	call the function force_text with 3 arguments : file_name , encoding and errors set to string STR0 , substitute the result for file_name .	file_name = force_text ( file_name , encoding , errors = STR0 )
9688	call the function unescape_entities with an argument file_name , use the result as an argument for the call to the self.IE_sanitize , method , substitute the result for file_name .	file_name = self . IE_sanitize ( unescape_entities ( file_name ) )
9689	get the value under the STR0 of the meta_data dictionary , if it exists assign it to content_type , content_type_extra , if not , content_type is an empty string and content_type_extra is an empty dictionary .	content_type , content_type_extra = meta_data . get ( STR0 , ( STR , { } ) )
9690	strip the content_type of the whitespaces , substitute it for content_type .	content_type = content_type . strip ( )
9691	get the value under the STR0 key of the content_type_extra dictionary , substitute it for charset .	charset = content_type_extra . get ( STR0 )
9692	try ,	try :
9693	convert to an integer first element of the value under the STR0 key of the meta_data dictionary , substitute it for content_length .	content_length = int ( meta_data . get ( STR0 ) [ 0 ] )
9694	if IndexError , TypeError or ValueError exception is caught ,	except ( IndexError , TypeError , ValueError ) :
9695	content_length is None .	content_length = None
9696	counters is a list containing length of handlers number of zeros .	counters = [ 0 ] * len ( handlers )
9697	try ,	try :
9698	for every handler in handlers ,	for handler in handlers :
9699	try ,	try :
9700	call the method handler.new_file with 6 arguments : field_name , file_name , content_type , content_length , charset and content_type_extra .	handler . new_file ( field_name , file_name , content_type , content_length , charset , content_type_extra )
9701	if StopFutureHandlers exception is caught .	except StopFutureHandlers :
9702	break the loop execution .	break
9703	for every chunk in field_stream ,	for chunk in field_stream :
9704	if transfer_encoding equals string STR0 ,	if transfer_encoding == STR0 :
9705	calculate length of chunk modulo integer 4 , substitute the result for over_bytes .	over_bytes = len ( chunk ) % 4
9706	if over_bytes is true ,	if over_bytes :
9707	call the method field_stream.read with an argument : over_bytes subtracted from integer 4 , substitute the result for over_chunk .	over_chunk = field_stream . read ( 4 - over_bytes )
9708	increment chunk by over_chunk .	chunk += over_chunk
9709	try ,	try :
9710	call the method base64.b64decode with an argument chunk , substitute the result for chunk .	chunk = base64 . b64decode ( chunk )
9711	if Exception , renamed to e , exception is caught ,	except Exception as e :
9712	msg is a string STR0 , where STR1 is replace with e .	msg = STR0 % e
9713	call the method six.reraise with 3 arguments : MultiPartParserError , MultiPartParserError created with msg , and third element of the result of the function sys.exc_info .	six . reraise ( MultiPartParserError , MultiPartParserError ( msg ) , sys . exc_info ( ) [ 2 ] )
9714	for every i and handler in enumerated iterable handlers ,	for i , handler in enumerate ( handlers ) :
9715	substitute length of chunk for chunk_length .	chunk_length = len ( chunk )
9716	call the method handler.receive_data_chunk with 2 arguments : chunk and i-th element of counters , substitute the result for chunk .	chunk = handler . receive_data_chunk ( chunk , counters [ i ] )
9717	increment i-th element of counters by chunk_length .	counters [ i ] += chunk_length
9718	if chunk is None ,	if chunk is None :
9719	break the loop execution .	break
9720	if SkipFile exception is caught ,	except SkipFile :
9721	call the method self._close_files .	self . _close_files ( )
9722	call the function exhaust with an argument field_stream .	exhaust ( field_stream )
9723	if not ,	else :
9724	substitute field_name for old_field_name .	old_field_name = field_name
9725	if not ,	else :
9726	call the function exhaust with an argument stream .	exhaust ( stream )
9727	if StopUpload , renamed to e , exception is caught ,	except StopUpload as e :
9728	call the method self._close_files .	self . _close_files ( )
9729	if e.connection_reset is false ,	if not e . connection_reset :
9730	call the function exhaust with an argument self._input_data .	exhaust ( self . _input_data )
9731	if not ,	else :
9732	call the function exhaust with an argument self._input_data .	exhaust ( self . _input_data )
9733	for every handler in handlers ,	for handler in handlers :
9734	call the method handler.upload_complete , substitute the result for retval .	retval = handler . upload_complete ( )
9735	if retval is true ,	if retval :
9736	break the loop execution .	break
9737	return self._post and self._files .	return self . _post , self . _files
9738	define the method handle_file_complete with 3 arguments : self , old_field_name and counters .	def handle_file_complete ( self , old_field_name , counters ) :
9739	for every i and handler in enumerated iterator self._upload_handlers ,	for i , handler in enumerate ( self . _upload_handlers ) :
9740	call the method handler.file_complete with i-th element of counters as an argument , substitute the result for file_obj .	file_obj = handler . file_complete ( counters [ i ] )
9741	if file_obj is true ,	if file_obj :
9742	call the function force_text with 3 arguments : old_field_name , self._encoding and errors as a string STR0 , use the result and file_obj as arguments for the call to the method self._files.appendlist .	self . _files . appendlist ( force_text ( old_field_name , self . _encoding , errors = STR0 ) , file_obj )
9743	break the loop execution .	break
9744	define the method IE_sanitize with arguments self and filename .	def IE_sanitize ( self , filename ) :
9745	call the method filename.rfind with an argument string `` \STR , increment the result by one , slice the filename from the previous result as start index to the end , strip it of white spaces from both ends , if the result is not an empty string and filename is not an empty string , return boolean True , otherwise return boolean False .	return filename and filename [ filename . rfind ( STR0 ) + 1 : ] . strip ( )
9746	define the method _close_files with an argument self .	def _close_files ( self ) :
9747	for every handler in self._upload_handlers ,	for handler in self . _upload_handlers :
9748	if handler has an attribute STR0 ,	if hasattr ( handler , STR0 ) :
9749	call the method handler.file.close .	handler . file . close ( )
9750	derive the class LazyStream from the six.Iterator base class .	class LazyStream ( six . Iterator ) :
9751	define the method __init__ with 3 arguments : self , producer and length set to None .	def __init__ ( self , producer , length = None ) :
9752	substitute producer for self._producer .	self . _producer = producer
9753	self._empty is boolean False .	self . _empty = False
9754	self._leftover is an empty string .	self . _leftover = STR
9755	substitute length for self._length .	self . length = length
9756	self.position is an integer 0 .	self . position = 0
9757	substitute length for self._remaining .	self . _remaining = length
9758	self._unget_history is an empty list .	self . _unget_history = [ ]
9759	define the method tell with an argument self .	def tell ( self ) :
9760	return self.position .	return self . position
9761	define the method read with arguments self and size set to None .	def read ( self , size = None ) :
9762	define the function parts .	def parts ( ) :
9763	if size is None substitute self._remaining for remaining , if not , substitute size for remaining .	remaining = self . _remaining if size is None else size
9764	if remaining is None ,	if remaining is None :
9765	join self into a bytes string , yield the result as the return value of the generator .	yield STR . join ( self )
9766	return nothing .	return
9767	while remaining is not equal to integer 0 ,	while remaining != 0 :
9768	if remaining is not greater than 0 , assert an error with the message string STR0 .	assert remaining > 0 , STR0
9769	get the next element of iterable self , substitute it for chunk .	chunk = next ( self )
9770	create list of first remaining elements of chunk , substitute it for emitting .	emitting = chunk [ : remaining ]
9771	call the method self.unget with list containing first remaining elements of chunk as an argument .	self . unget ( chunk [ remaining : ] )
9772	decrement remaining by length of emitting .	remaining -= len ( emitting )
9773	yield emitting as result of the generator .	yield emitting
9774	join result of the parts function into a bytes string , substitute it for out .	out = STR . join ( parts ( ) )
9775	return out .	return out
9776	define the method __next__ with an argument self .	def __next__ ( self ) :
9777	if self._leftover is true ,	if self . _leftover :
9778	substitute self._leftover for output .	output = self . _leftover
9779	self._leftover is an empty string .	self . _leftover = STR
9780	if not ,	else :
9781	get the next element of the self._producer iterable , substitute it for output .	output = next ( self . _producer )
9782	self._unget_history is an empty list .	self . _unget_history = [ ]
9783	increment self.position by length of output .	self . position += len ( output )
9784	return output .	return output
9785	define the method close with an argument self .	def close ( self ) :
9786	self._producer is an empty list .	self . _producer = [ ]
9787	define the method _iter with an argument self .	def __iter__ ( self ) :
9788	return self .	return self
9789	define the method unget with arguments self and bytes .	def unget ( self , bytes ) :
9790	if bytes is false ,	if not bytes :
9791	return nothing .	return
9792	call the method self._update_unget_history with length of bytes as an argument .	self . _update_unget_history ( len ( bytes ) )
9793	decrement self.position by length of bytes .	self . position -= len ( bytes )
9794	join bytes and self._leftover into a bytes string , substitute it for self._leftover .	self . _leftover = STR . join ( [ bytes , self . _leftover ] )
9795	define the method _update_unget_history with arguments self and num_bytes .	def _update_unget_history ( self , num_bytes ) :
9796	append first 49 elements of self._unget_history to list containing num_bytes , substitute the result for self._unget_history .	self . _unget_history = [ num_bytes ] + self . _unget_history [ : 49 ]
9797	append current_number to a list for current_number in self._unget_history , if current_number is equal to num_bytes , substitute the length of the resulting list for number_equal .	number_equal = len ( [ current_number for current_number in self . _unget_history if current_number == num_bytes ] )
9798	if number_equal is greater than integer 40 ,	if number_equal > 40 :
9799	raise SuspiciousMultipartForm exception with an argument string , STR0 .	raise SuspiciousMultipartForm ( STR0 )
9800	derive the class ChunkIter from the six.Iterator base class .	class ChunkIter ( six . Iterator ) :
9801	define the method __init__ with arguments self , flo and chunk_size set to integer 64 multiplied by integer 1024 .	def __init__ ( self , flo , chunk_size = 64 * 1024 ) :
9802	substitute flo for self.flo .	self . flo = flo
9803	substitute chunk_size for self.chunk_size .	self . chunk_size = chunk_size
9804	define the method __next__ with an argument self .	def __next__ ( self ) :
9805	try ,	try :
9806	call the method self.flo.read with an argument self.chunk_size , substitute the result for data .	data = self . flo . read ( self . chunk_size )
9807	if InputStreamExhausted exception is caught ,	except InputStreamExhausted :
9808	raise an StopIteration exception .	raise StopIteration ( )
9809	if data is true ,	if data :
9810	return data .	return data
9811	if not ,	else :
9812	raise an StopIteration exception .	raise StopIteration ( )
9813	define the method __iter__ with an argument self .	def __iter__ ( self ) :
9814	return self .	return self
9815	derive the class InterBoundaryIter from the six.Iterator base class .	class InterBoundaryIter ( six . Iterator ) :
9816	define the method __init__ with arguments self , stream and boundary .	def __init__ ( self , stream , boundary ) :
9817	substitute stream for self._stream .	self . _stream = stream
9818	substitute boundary for self.boundary .	self . _boundary = boundary
9819	define the method __iter__ with an argument self .	def __iter__ ( self ) :
9820	return self .	return self
9821	define the method __next__ with an argument self .	def __next__ ( self ) :
9822	try ,	try :
9823	instantiate class BoundaryIter with 2 arguments : self._stream and self._boundary , use it to instantiate LazyStream class , return it .	return LazyStream ( BoundaryIter ( self . _stream , self . _boundary ) )
9824	if InputStreamExhausted exception is caught ,	except InputStreamExhausted :
9825	raise an StopIteration .	raise StopIteration ( )
9826	derive the class BoundaryIter from the six.Iterator base class .	class BoundaryIter ( six . Iterator ) :
9827	define the method __init__ with arguments self , stream and boundary .	def __init__ ( self , stream , boundary ) :
9828	substitute stream for self._stream .	self . _stream = stream
9829	substitute boundary for self._boundary .	self . _boundary = boundary
9830	self._done is boolean False .	self . _done = False
9831	increment length of boundary by integer 6 , substitute the result for self._rollback .	self . _rollback = len ( boundary ) + 6
9832	call the method self._stream.read with an argument integer 1 , substitute the result for unused_char .	unused_char = self . _stream . read ( 1 )
9833	if unused_char is false ,	if not unused_char :
9834	raise an InputStreamExhausted exception ,	raise InputStreamExhausted ( )
9835	call the method self._stream.unget with an argument unused_char .	self . _stream . unget ( unused_char )
9836	define the method __iter__ with an argument self .	def __iter__ ( self ) :
9837	return self .	return self
9838	define the method __next__ with an argument self .	def __next__ ( self ) :
9839	if self._done is true ,	if self . _done :
9840	raise an StopIteration exception ,	raise StopIteration ( )
9841	substitute self._stream for stream .	stream = self . _stream
9842	substitute self._rollback for rollback .	rollback = self . _rollback
9843	bytes_read is integer 0 .	bytes_read = 0
9844	chunks is an empty list .	chunks = [ ]
9845	for every bytes in stream ,	for bytes in stream :
9846	increment bytes_read by length of bytes .	bytes_read += len ( bytes )
9847	append bytes to chunks .	chunks . append ( bytes )
9848	if bytes_read is greater than rollback ,	if bytes_read > rollback :
9849	break the loop execution .	break
9850	if bytes is false ,	if not bytes :
9851	break the loop execution .	break
9852	if not ,	else :
9853	self._done is boolean True .	self . _done = True
9854	if chunks is false ,	if not chunks :
9855	raise an StopIteration exception .	raise StopIteration ( )
9856	join chunks into bytes string , substitute it for chunk .	chunk = STR . join ( chunks )
9857	call the method self._find_boundary with 2 arguments : chunk and boolean if length of chunks is lesser than self._rollback , or boolean False if not , substitute the result for boundary .	boundary = self . _find_boundary ( chunk , len ( chunk ) < self . _rollback )
9858	if boundary is true ,	if boundary :
9859	substitute elements of tuple boundary to end and next , respectively .	end , next = boundary
9860	call the method stream.unget with elements of list chunk from the index next to the end .	stream . unget ( chunk [ next : ] )
9861	self._done is boolean True .	self . _done = True
9862	return first end elements of list chunk .	return chunk [ : end ]
9863	if not ,	else :
9864	slice chunk list to get the last rollback elements , if the new list is not empty ,	if not chunk [ : - rollback ] :
9865	self._done is boolean True .	self . _done = True
9866	return chunk .	return chunk
9867	if not ,	else :
9868	call the method stream.unget with last rollback elements of chunk as an argument .	stream . unget ( chunk [ - rollback : ] )
9869	return last rollback elements of chunk .	return chunk [ : - rollback ]
9870	define the method _find_boundary with an arguments self , data and eof set to boolean False .	def _find_boundary ( self , data , eof = False ) :
9871	call the method data.find with an argument self._boundary , substitute the result for index .	index = data . find ( self . _boundary )
9872	if index is lesser than integer 0 ,	if index < 0 :
9873	return None .	return None
9874	if not ,	else :
9875	substitute index for end .	end = index
9876	sum index and length of self._boundary , substitute the result for next .	next = index + len ( self . _boundary )
9877	substitute greater element between integer 0 and end decremented by one for last .	last = max ( 0 , end - 1 )
9878	element of data at the index last equals to newline bytes character .	if data [ last : last + 1 ] == STR0 :
9879	decrement end by one .	end -= 1
9880	substitute greater element between integer 0 and end decremented by one for last .	last = max ( 0 , end - 1 )
9881	element of data at the index last equals to carriage return bytes character .	if data [ last : last + 1 ] == STR0 :
9882	decrement end by one .	end -= 1
9883	return end ans next .	return end , next
9884	define the function exhaust with an argument stream_or_iterable .	def exhaust ( stream_or_iterable ) :
9885	iterator is None .	iterator = None
9886	try ,	try :
9887	iterator is iterator created out of stream_or_iterable .	iterator = iter ( stream_or_iterable )
9888	if TypeError exception is caught ,	except TypeError :
9889	iterator is an instance of ChunkIter class , created with arguments : stream_or_iterable and integer 16384 .	iterator = ChunkIter ( stream_or_iterable , 16384 )
9890	if iterator is None ,	if iterator is None :
9891	raise an MultiPartParserError with an argument string STR0 .	raise MultiPartParserError ( STR0 )
9892	for every __ in iterator ,	for __ in iterator :
9893	do nothing .	pass
9894	define the function parse_boundary_stream with arguments stream and max_header_size .	def parse_boundary_stream ( stream , max_header_size ) :
9895	call the method stream.read with an argument max_header_size , substitute the result for chunk .	chunk = stream . read ( max_header_size )
9896	call the method chunk.find with an argument bytes string STR0 , substitute the result for header_end .	header_end = chunk . find ( STR0 )
9897	define the method _parse_header with an argument line .	def _parse_header ( line ) :
9898	call the function parse_header with an argument line , substitute the result for main_value_pair and params , respectively .	main_value_pair , params = parse_header ( line )
9899	try ,	try :
9900	split into two parts string main_value_pair at character STR0 , substitute the parts for name and value , respectively .	name , value = main_value_pair . split ( STR0 , 1 )
9901	if ValueError exception is caught ,	except ValueError :
9902	raise an ValueError with an argument string STR0 , where STR1 is replaced with line .	raise ValueError ( STR0 % line )
9903	return name and tuple containing 2 elements value and params .	return name , ( value , params )
9904	if header_end equals integer negative 1 ,	if header_end == - 1 :
9905	call the method stream.unget with an argument chunk .	stream . unget ( chunk )
9906	return tuple containing 3 elements : RAW , an empty dictionary and stream .	return ( RAW , { } , stream )
9907	substitute first header_end elements of chunk list for header .	header = chunk [ : header_end ]
9908	call the method stream.unget with list containing elements of chunk list from the header_end incremented by integer 4 as a start index to the end as argument .	stream . unget ( chunk [ header_end + 4 : ] )
9909	substitute RAW for TYPE .	TYPE = RAW
9910	outdict is an empty dictionary .	outdict = { }
9911	split header string at string STR0 , for every line in result ,	for line in header . split ( STR0 ) :
9912	try ,	try :
9913	call the method _parse_header with an argument line , assign the result to name and tuple with 2 elements : value and params , respectively .	name , ( value , params ) = _parse_header ( line )
9914	if ValueError exception is caught ,	except ValueError :
9915	skip this loop iteration .	continue
9916	if name equals a string STR0 ,	if name == STR0 :
9917	substitute FIELD for TYPE ,	TYPE = FIELD
9918	get the value under the STR0 key of the params dictionary , if it is true ,	if params . get ( STR0 ) :
9919	substitute FILE for TYPE .	TYPE = FILE
9920	assign value and params to the value under the name key of the outdict dictionary .	outdict [ name ] = value , params
9921	if TYPE equals to RAW ,	if TYPE == RAW :
9922	call the method stream.unget with an argument chunk .	stream . unget ( chunk )
9923	return a tuple with 3 elements : TYPE , outdict and stream .	return ( TYPE , outdict , stream )
9924	derive the class Parser from the base class object .	class Parser ( object ) :
9925	define the method __init__ with arguments self , stream and boundary .	def __init__ ( self , stream , boundary ) :
9926	substitute stream for self._stream .	self . _stream = stream
9927	append boundary to bytes string STR0 , substitute the result for self._separator .	self . _separator = STR0 + boundary
9928	define the method __iter__ with an argument self .	def __iter__ ( self ) :
9929	boundarystream is an instance of InterBoundaryIter class , created with self._stream and self._separator as arguments .	boundarystream = InterBoundaryIter ( self . _stream , self . _separator )
9930	for every sub_stream in boundarystream ,	for sub_stream in boundarystream :
9931	call the function parse_boundary_stream with 2 arguments : sub_stream and integer 1024 , yield the result as the return value of the generator .	yield parse_boundary_stream ( sub_stream , 1024 )
9932	define the function parse_header with an argument line .	def parse_header ( line ) :
9933	append line to bytes string STR0 , use it as an argument for the call to the function _parse_header_params , substitute the result for plist .	plist = _parse_header_params ( STR0 + line )
9934	pop the first element from plist , convert it to lowercase , call the method decode on it , with string STR0 as an argument , substitute the result for key .	key = plist . pop ( 0 ) . lower ( ) . decode ( STR0 )
9935	pdict is an empty dictionary .	pdict = { }
9936	for every p in plist ,	for p in plist :
9937	call the method p.find with bytes string STR0 as an argument , substitute the result for i .	i = p . find ( STR0 )
9938	if i is greater or equal to integer 0 ,	if i >= 0 :
9939	take the first i elements of string p , strip the whitespaces from the both sides , convert it to lowercase and apply on it the method , decode with an argument string STR0 , substitute the result for name .	name = p [ : i ] . strip ( ) . lower ( ) . decode ( STR0 )
9940	take elements of p from index i incremented by 1 to the end , strip the result of the whitespaces , substitute it for value .	value = p [ i + 1 : ] . strip ( )
9941	if length of value is greater or equal to integer 2 and first and last elements of value are an empty string ,	if len ( value ) >= 2 and value [ : 1 ] == value [ - 1 : ] == STR :
9942	strip value of the first and last element .	value = value [ 1 : - 1 ]
9943	replace all the occurrences of STR0 in string value with STRspecial and all occurrences of STR1 for STR , substitute the result for value .	value = value . replace ( STR0 , STRspecial ) . replace ( STR1 , STR )
9944	substitute value for the vale under the name key of the pdict dictionary .	pdict [ name ] = value
9945	return key and pdict .	return key , pdict
9946	define the function _parse_header_params with an argument s .	def _parse_header_params ( s ) :
9947	plist is an empty list .	plist = [ ]
9948	while first element of s is equal to bytes string STR0 ,	while s [ : 1 ] == STR0 :
9949	substitute s without the first element for s .	s = s [ 1 : ]
9950	call the method s.find with an argument bytes string STR0 , substitute the result for end .	end = s . find ( STR0 )
9951	while end is greater than integer 0 and return value of the s.count called with 3 arguments : an empty string , integer 0 and end ,	while end > 0 and s . count ( STR , 0 , end ) % 2 :
9952	is an even number , call the method s.find with 2 arguments : bytes string STR0 and end incremented by one , substitute the result for end .	end = s . find ( STR0 , end + 1 )
9953	if end is lesser than integer 0 ,	if end < 0 :
9954	substitute length of s for end .	end = len ( s )
9955	substitute first end elements of s for f .	f = s [ : end ]
9956	strip f of whitespaces and append it to plist .	plist . append ( f . strip ( ) )
9957	substitute elements of s from the end index to end for s .	s = s [ end : ]
9958	return plist .	return plist
9959	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
9960	import module copy .	import copy
9961	import module os .	import os
9962	import module re .	import re
9963	import module sys .	import sys
9964	from io import BytesIO into default name space .	from io import BytesIO
9965	from itertools import chain into default name space .	from itertools import chain
9966	from pprint import pformat into default name space .	from pprint import pformat
9967	from django.conf import settings into default name space .	from django . conf import settings
9968	from django.core import signing into default name space .	from django . core import signing
9969	from django.core.exceptions import DisallowedHost and ImproperlyConfigured into default name space .	from django . core . exceptions import DisallowedHost , ImproperlyConfigured
9970	from django.core.files import uploadhandler into default name space .	from django . core . files import uploadhandler
9971	from django.http.multipartparser import MultiPartParser and MultiPartParserError into default name space .	from django . http . multipartparser import MultiPartParser , MultiPartParserError
9972	from django.utils import six into default name space .	from django . utils import six
9973	from django.utils.datastructures import MultiValueDict and ImmutableList into default name space .	from django . utils . datastructures import MultiValueDict , ImmutableList
9974	from django.utils.encoding import force_bytes , force_text , force_str and iri_to_uri into default name space .	from django . utils . encoding import force_bytes , force_text , force_str , iri_to_uri
9975	from django.utils.six.moves.urllib.parse import parse_qsl , urlencode , quote , urljoin and urlsplit into default name space .	from django . utils . six . moves . urllib . parse import parse_qsl , urlencode , quote , urljoin , urlsplit
9976	RAISE_ERROR is an instance of object class .	RAISE_ERROR = object ( )
9977	compile the regex STR0 with an argument re.I , substitute it for absolute_http_url_re .	absolute_http_url_re = re . compile ( STR0 , re . I )
9978	compile the regex STR0 , substitute it for host_validation_re .	host_validation_re = re . compile ( STR0 )
9979	derive the class UnreadablePostError from the base class IOError .	class UnreadablePostError ( IOError ) :
9980	do nothing .	pass
9981	derive the class RawPostDataException from the base class Exception .	class RawPostDataException ( Exception ) :
9982	do nothing .	pass
9983	derive the class HttpRequest from the object base class .	class HttpRequest ( object ) :
9984	_encoding is None .	_encoding = None
9985	_upload_handlers is an empty list .	_upload_handlers = [ ]
9986	define the method __init__ with an argument self .	def __init__ ( self ) :
9987	self.GET is an instance of QueryDict class created with an argument mutable set to boolean True .	self . GET = QueryDict ( mutable = True )
9988	self.POST is an instance of QueryDict class created with an argument mutable set to boolean True .	self . POST = QueryDict ( mutable = True )
9989	self.COOKIES is an empty dictionary .	self . COOKIES = { }
9990	self.META is an empty dictionary .	self . META = { }
9991	self.FILES is an instance of MultiValueDict class .	self . FILES = MultiValueDict ( )
9992	self.path is an empty string .	self . path = STR
9993	self.path_info is an empty string .	self . path_info = STR
9994	self.method is None .	self . method = None
9995	self.resolver_match is None .	self . resolver_match = None
9996	self._post_parse_error is boolen False .	self . _post_parse_error = False
9997	define the method __repr__ with an argument self .	def __repr__ ( self ) :
9998	call the method build_request_repr with an argument self , return the result .	return build_request_repr ( self )
9999	define the method get_host with an argument self .	def get_host ( self ) :
10000	if settings.USE_X_FORWARDED_HOST is true and STR0 is contained in self.META .	if settings . USE_X_FORWARDED_HOST and ( STR0 in self . META ) :
10001	get the value under the STR0 key of the self.META dictionary , substitute the result for host .	host = self . META [ STR0 ]
10002	if STR0 is contained in self.META ,	elif STR0 in self . META :
10003	substitute the value under the STR0 key of the self.META dictionary , substitute it for host .	host = self . META [ STR0 ]
10004	if not ,	else :
10005	substitute the value under the STR0 key of the self.META dictionary , substitute it for host .	host = self . META [ STR0 ]
10006	convert the value under the STR0 key of the self.META dictionary to a string , substitute result for server_port .	server_port = str ( self . META [ STR0 ] )
10007	if return value of the self.is_secure method is true and server_port is not equal to string STR0 ,	if server_port != ( STR0 if self . is_secure ( ) else STR1 ) :
10008	if return value of the self.is_secure is false and server port is not equal to string STR0 , join host and server_port into a string , separated with STR1 , substitute the result for host .	host = STR0 % ( host , server_port )
10009	if settings.DEBUG is true ,	if settings . DEBUG :
10010	return host .	return host
10011	call the function split_domain_port with an argument host , assign the result to domain and port , respectively .	domain , port = split_domain_port ( host )
10012	if domain is true and return value of the function validate_host called with 2 arguments : domain and settings.ALLOWED_HOSTS , evaluates to true ,	if domain and validate_host ( domain , settings . ALLOWED_HOSTS ) :
10013	return host .	return host
10014	if not ,	else :
10015	msg is a string STR0 , replace STR1 with host .	msg = STR0 % host
10016	if domain is true ,	if domain :
10017	append string STR0 to msg , where STR1 is replaced with domain .	msg += STR0 % domain
10018	if not ,	else :
10019	append string STR0 to msg .	msg += STR0
10020	raise an DisallowedHost exception with an argument msg .	raise DisallowedHost ( msg )
10021	define the method get_full_path with an argument self .	def get_full_path ( self ) :
10022	if the value under the STR0 key of the self.META dictionary is true , call the function iri_to_uri , called with value under the STR1 key of the self.META dictionary and append it to string STR2 , append the result th the self.path converted into a string and return it , if the value under the STR3 key of the self.META dictionary is false , return self.path converted into a string .	return STR0 % ( self . path , ( STR1 + iri_to_uri ( self . META . get ( STR2 , STR ) ) ) if self . META . get ( STR3 , STR ) else STR )
10023	def the method get_signed_cookie with 5 arguments : self , key , default set to RAISE_ERROR , salt as an empty string ,	def get_signed_cookie ( self , key , default = RAISE_ERROR , salt = STR , max_age = None ) :
10024	try ,	try :
10025	substitute value under the key key of the self.COOKIES dictionary , substitute it for cookie_value .	cookie_value = self . COOKIES [ key ]
10026	if KeyError exception is caught ,	except KeyError :
10027	if default is true and RAISE_ERROR is false ,	if default is not RAISE_ERROR :
10028	return default .	return default
10029	if not ,	else :
10030	raise an exception .	raise
10031	try ,	try :
10032	call the method signing.get_cookie_signer with an argument salt set to sum of key and salt , call the method unsign on the result , with arguments cookie_value and max_age set to max_age .	value = signing . get_cookie_signer ( salt = key + salt ) . unsign ( cookie_value , max_age = max_age )
10033	if signing.BadSignature exception is caught ,	except signing . BadSignature :
10034	if default is true and RAISE_ERROR is false ,	if default is not RAISE_ERROR :
10035	return default .	return default
10036	if not ,	else :
10037	raise an exception .	raise
10038	return value .	return value
10039	define the method build_absolute_uri with an arguments self and location set to None .	def build_absolute_uri ( self , location = None ) :
10040	if location is None ,	if location is None :
10041	call the method self.get_full_path , append the result to string STR0 , substitute it for location .	location = STR0 % self . get_full_path ( )
10042	call the function urlsplit with an argument location , substitute the result for bits .	bits = urlsplit ( location )
10043	do not perform the following only if bits.scheme and bits.netloc are both true ,	if not ( bits . scheme and bits . netloc ) :
10044	format the string STR0 by replacing scheme with self.scheme , host with return value of the self.get_host method , and path with self.path , substitute the result for current_uri .	current_uri = STR0 . format ( scheme = self . scheme , host = self . get_host ( ) , path = self . path )
10045	call the function urljoin with arguments current_uri and location , substitute the result for location .	location = urljoin ( current_uri , location )
10046	call the function iri_to_uri with an argument location , return the result .	return iri_to_uri ( location )
10047	define the method _get_scheme with an argument self .	def _get_scheme ( self ) :
10048	return string STR1 if value under the STR0 key of the os.environ dictionary equals string STR2 , if not return STR3 .	return STR2 if os . environ . get ( STR0 ) == STR1 else STR3
10049	property decorator .	@ property
10050	define the method scheme with an argument self .	def scheme ( self ) :
10051	if settings.SECURE_PROXY_SSL_HEADER is true ,	if settings . SECURE_PROXY_SSL_HEADER :
10052	try ,	try :
10053	assign the settings.SECURE_PROXY_SSL_HEADER to header and value , respectively .	header , value = settings . SECURE_PROXY_SSL_HEADER
10054	if ValueError exception is caught ,	except ValueError :
10055	raise an ImproperlyConfigured exception with an argument string STR0 .	raise ImproperlyConfigured ( STR0 )
10056	if value under the header key of the self.META dictionary is equal to value ,	if self . META . get ( header , None ) == value :
10057	return string STR0 .	return STR0
10058	call the method self._get_scheme , return the result .	return self . _get_scheme ( )
10059	define the method is_secure with an argument self .	def is_secure ( self ) :
10060	if self.scheme equals to string STR0 , return boolean True , otherwise return boolean False .	return self . scheme == STR0
10061	define the method is_ajax with an argument self .	def is_ajax ( self ) :
10062	get the value under the STR0 key of the self.META dictionary , if it equals string STR1 , return boolean True , otherwise return boolean False .	return self . META . get ( STR0 ) == STR1
10063	property decorator .	@ property
10064	define the method encoding with an argument self .	def encoding ( self ) :
10065	return self._encoding .	return self . _encoding
10066	encoding.setter decorator ,	@ encoding . setter
10067	define the method encoding with arguments self and val .	def encoding ( self , val ) :
10068	substitute val for self._encoding .	self . _encoding = val
10069	if self has an STR0 attribute ,	if hasattr ( self , STR0 ) :
10070	delete self._get .	del self . _get
10071	if self has an STR0 attribute ,	if hasattr ( self , STR0 ) :
10072	del self._post	del self . _post
10073	define the method _initialize_handlers with an argument self .	def _initialize_handlers ( self ) :
10074	for every handler in settings.FILE_UPLOAD_HANDLERS , add to a list result of the method uploadhandler.load_handler called with arguments handler and self , substitute resulting list for self._upload_handlers .	self . _upload_handlers = [ uploadhandler . load_handler ( handler , self ) for handler in settings . FILE_UPLOAD_HANDLERS ]
10075	property decorator ,	@ property
10076	define the method upload_handlers with an argument self .	def upload_handlers ( self ) :
10077	if self._upload_handlers is false ,	if not self . _upload_handlers :
10078	call the method self._initialize_handlers ,	self . _initialize_handlers ( )
10079	return self._upload_handlers .	return self . _upload_handlers
10080	upload_handlers.setter decorator .	@ upload_handlers . setter
10081	define the method upload_handlers with arguments : self and upload_handlers .	def upload_handlers ( self , upload_handlers ) :
10082	if self has an STR0 attribute .	if hasattr ( self , STR0 ) :
10083	raise an AttributeError exception with an argument string STR0 .	raise AttributeError ( STR0 )
10084	substitute upload_handlers for self._upload_handlers .	self . _upload_handlers = upload_handlers
10085	define the method parse_file_upload with 3 arguments : self , META and post_data .	def parse_file_upload ( self , META , post_data ) :
10086	self.upload_handlers is an instance of ImmutableList , created with 2 arguments : self.upload_handlers , and warning as a string STR0 .	self . upload_handlers = ImmutableList ( self . upload_handlers , warning = STR0 )
10087	parser is an instance of MultiPartParser class , created with 4 arguments : META , post_data , self.upload_handlers and self.encoding .	parser = MultiPartParser ( META , post_data , self . upload_handlers , self . encoding )
10088	call the method parser.parse , return the result .	return parser . parse ( )
10089	property decorator ,	@ property
10090	define the method body with an argument self .	def body ( self ) :
10091	if self doesnt have an STR0 attribute ,	if not hasattr ( self , STR0 ) :
10092	if self._read_started is true ,	if self . _read_started :
10093	raise an RawPostDataException exception with an argument string STR0 .	raise RawPostDataException ( STR0 )
10094	try ,	try :
10095	call the method self.read , substitute the result or self._body .	self . _body = self . read ( )
10096	if IOError , renamed to e , exception is caught ,	except IOError as e :
10097	call the function six.reraise with 3 arguments : UnreadablePostError , UnreadablePostError instantiated with unpacked list e.args , third element of the result of the function sys.exc_info .	six . reraise ( UnreadablePostError , UnreadablePostError ( * e . args ) , sys . exc_info ( ) [ 2 ] )
10098	self._stream is an instance of BytesIO class created with an argument self._body .	self . _stream = BytesIO ( self . _body )
10099	return self._body .	return self . _body
10100	define the method_mark_post_parse_error with an argument self .	def _mark_post_parse_error ( self ) :
10101	self._post is an instance of QueryDict class created with an empty string as argument .	self . _post = QueryDict ( STR )
10102	self._files is an instance of MultiValueDict class .	self . _files = MultiValueDict ( )
10103	self._post_parse_error is boolean True .	self . _post_parse_error = True
10104	define the method _load_post_and_files with an argument self .	def _load_post_and_files ( self ) :
10105	if self.method is not equal to string STR0 ,	if self . method != STR0 :
10106	self._post is an instance of QueryDict created with arguments : an empty string and encoding set to self._encoding ,	self . _post , self . _files = QueryDict ( STR , encoding = self . _encoding ) , MultiValueDict ( )
10107	self._files is an instance of class MultiValueDict . return nothing .	return
10108	if self._read_started is true and self doesnt have an STR0 attribute .	if self . _read_started and not hasattr ( self , STR0 ) :
10109	call the method self._mark_post_parse_error .	self . _mark_post_parse_error ( )
10110	return nothing .	return
10111	get the value under the STR0 key of the self.META dictionary , if it starts with a string STR1 ,	if self . META . get ( STR0 , STR ) . startswith ( STR1 ) :
10112	if self has an attribute STR0 ,	if hasattr ( self , STR0 ) :
10113	data is an instance of BytesIO class , created with an argument : self._body .	data = BytesIO ( self . _body )
10114	if not ,	else :
10115	substitute self for data .	data = self
10116	try ,	try :
10117	call the method self.parse_file_upload with arguments self.META and data , assign the result to self._post and self._files .	self . _post , self . _files = self . parse_file_upload ( self . META , data )
10118	if MultiPartParserError exception is caught ,	except MultiPartParserError :
10119	call the method self._mark_post_parse_error .	self . _mark_post_parse_error ( )
10120	raise an exception .	raise
10121	otherwise if value under the STR0 key of hte self.META dictionary starts with STR1 ,	elif self . META . get ( STR0 , STR ) . startswith ( STR1 ) :
10122	self._post is an instance of QueryDict created with arguments : self.body and encoding set to self._encoding , self._files is an instance of class MultiValueDict .	self . _post , self . _files = QueryDict ( self . body , encoding = self . _encoding ) , MultiValueDict ( )
10123	if not ,	else :
10124	self._post is an instance of QueryDict created with arguments : an empty string and encoding set to self._encoding , self._files is an instance of class MultiValueDict .	self . _post , self . _files = QueryDict ( STR , encoding = self . _encoding ) , MultiValueDict ( )
10125	define the method close with an argument self .	def close ( self ) :
10126	if self has an attribute STR0 ,	if hasattr ( self , STR0 ) :
10127	for every f in return value of the return value of the method chain.from_iterable called with argument :	for f in chain . from_iterable ( l [ 1 ] for l in self . _files . lists ( ) ) :
10128	second element of l for every l in return value of the self._files.lists call the method f.close .	f . close ( )
10129	define the method read with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .	def read ( self , * args , ** kwargs ) :
10130	self._read_started is True .	self . _read_started = True
10131	try ,	try :
10132	call the method self._stream.read with 2 arguments : unpacked list args and unpacked dictionary kwargs .	return self . _stream . read ( * args , ** kwargs )
10133	if IOError , renamed to e , exception is caught ,	except IOError as e :
10134	call the function six.reraise with 3 arguments : UnreadablePostError , UnreadablePostError instantiated with unpacked list e.args , third element of the result of the function sys.exc_info .	six . reraise ( UnreadablePostError , UnreadablePostError ( * e . args ) , sys . exc_info ( ) [ 2 ] )
10135	define the method readline with 3 arguments : self , unpacked list args and unpacked list kwargs .	def readline ( self , * args , ** kwargs ) :
10136	self._read_started is boolean True .	self . _read_started = True
10137	try ,	try :
10138	call the method self._stream.readline with 2 arguments : unpacked list args , unpacked dictionary kwargs .	return self . _stream . readline ( * args , ** kwargs )
10139	if IOError , substituted to e , exception is caught ,	except IOError as e :
10140	call the function six.reraise with 3 arguments : UnreadablePostError , UnreadablePostError instantiated with unpacked list e.args , third element of the result of the function sys.exc_info .	six . reraise ( UnreadablePostError , UnreadablePostError ( * e . args ) , sys . exc_info ( ) [ 2 ] )
10141	define the method __init__ with an argument self .	def xreadlines ( self ) :
10142	endless loop ,	while True :
10143	read one line from self file stream , substitute the result for buf .	buf = self . readline ( )
10144	if buf is false ,	if not buf :
10145	break the loop execution .	break
10146	yield buf as return value of the generator .	yield buf
10147	substitute xreadlines for __iter__ .	__iter__ = xreadlines
10148	define the method __init__ with an argument self .	def readlines ( self ) :
10149	append to a list elements of the iterator self , return the resulting list .	return list ( iter ( self ) )
10150	derive the class QueryDict from the base class MultiValueDict .	class QueryDict ( MultiValueDict ) :
10151	_mutable is boolean True .	_mutable = True
10152	_encoding is None .	_encoding = None
10153	define the method __init__ with 4 arguments : self , query_string is None , mutable is boolean False and encoding set to None .	def __init__ ( self , query_string = None , mutable = False , encoding = None ) :
10154	call the __init__ method of the base class of the QueryDict class .	super ( QueryDict , self ) . __init__ ( )
10155	if encoding is false .	if not encoding :
10156	substitute settings.DEFAULT_CHARSET for encoding .	encoding = settings . DEFAULT_CHARSET
10157	substitute encoding for self.encoding .	self . encoding = encoding
10158	if six.PY3 is true ,	if six . PY3 :
10159	if query_string is an instance of bytes ,	if isinstance ( query_string , bytes ) :
10160	call the method query_string.decode , substitute the result for query_string .	query_string = query_string . decode ( )
10161	for every key and value in return value of the parse_qsl with 3 arguments : query_string is it exists or an empty string if not , keep_blank_values set to boolean True , encoding set to encoding .	for key , value in parse_qsl ( query_string or STR , keep_blank_values = True , encoding = encoding ) :
10162	call the method appendlist with 2 arguments : key and value .	self . appendlist ( key , value )
10163	if not ,	else :
10164	for every key and value in parse_gsl with query_string is it exists or an empty string if not and keep_blank_values set to boolean True .	for key , value in parse_qsl ( query_string or STR , keep_blank_values = True ) :
10165	call the method self.appendlist with 2 arguments : return value of the function force_text with 3 arguments : key , encoding and errors set to string STR0 , and return value of the function force_text with 3 arguments : value , encoding and errors set to string STR1 .	self . appendlist ( force_text ( key , encoding , errors = STR0 ) , force_text ( value , encoding , errors = STR1 ) )
10166	call the method mutable substitute for self._mutable .	self . _mutable = mutable
10167	property decorator ,	@ property
10168	define the method encoding with an argument self .	def encoding ( self ) :
10169	if self._encoding is None ,	if self . _encoding is None :
10170	substitute settings.DEFAULT_CHARSET for self._encoding .	self . _encoding = settings . DEFAULT_CHARSET
10171	return self._encoding .	return self . _encoding
10172	encoding.setter decorator ,	@ encoding . setter
10173	define the method encoding with arguments self and value .	def encoding ( self , value ) :
10174	substitute value for self._encoding .	self . _encoding = value
10175	define the method _assert_mutable with an argument self .	def _assert_mutable ( self ) :
10176	if not self._mutable ,	if not self . _mutable :
10177	raise an AttributeError with an argument string STR0 .	raise AttributeError ( STR0 )
10178	define the method __setitem__ with 3 arguments : self , key and value .	def __setitem__ ( self , key , value ) :
10179	call the method self._assert_mutable .	self . _assert_mutable ( )
10180	call the method bytes_to_text with 2 arguments : key and self.encoding , substitute the result for key .	key = bytes_to_text ( key , self . encoding )
10181	call the method bytes_to_text with 2 arguments : key and self.encoding , substitute the result for value .	value = bytes_to_text ( value , self . encoding )
10182	call the method __setitem__ from the base class of the QueryDict class , with arguments key and value .	super ( QueryDict , self ) . __setitem__ ( key , value )
10183	define the method __delitem__ with 3 arguments : self and key .	def __delitem__ ( self , key ) :
10184	call the method self._assert_mutable .	self . _assert_mutable ( )
10185	call the method __delitem__ from the base class of the QueryDict class , with an argument key .	super ( QueryDict , self ) . __delitem__ ( key )
10186	define the method __copy__ with an argument self .	def __copy__ ( self ) :
10187	call the method self.__class__ with 3 arguments : an empty string , mutable is boolean True , encoding is self.encoding , substitute the result for result .	result = self . __class__ ( STR , mutable = True , encoding = self . encoding )
10188	for key and value in return value of the six.iterlists function called with an argument self ,	for key , value in six . iterlists ( self ) :
10189	call the method result.setlist with the arguments : key and value .	result . setlist ( key , value )
10190	return result .	return result
10191	define the method __deepcopy__ with 3 arguments : self and memo .	def __deepcopy__ ( self , memo ) :
10192	call the method self.__class__ with 3 arguments : an empty string , mutable is boolean True , encoding is self.encoding , substitute the result for result .	result = self . __class__ ( STR , mutable = True , encoding = self . encoding )
10193	get the identity of the self object , use it as a key to get the value of the memo dictionary , substitute result for it .	memo [ id ( self ) ] = result
10194	for key and value in result of the function six.iterlists called with an argument ,	for key , value in six . iterlists ( self ) :
10195	call the method result.setlist with 2 arguments : return value of the function copy.deepcopy called with 2 arguments : key and memo , and return value of the function copy.deepcopy called with 2 arguments : value and memo .	result . setlist ( copy . deepcopy ( key , memo ) , copy . deepcopy ( value , memo ) )
10196	return result .	return result
10197	define the method setlist with 3 arguments : self , key and list_ .	def setlist ( self , key , list_ ) :
10198	call the method self._assert_mutable .	self . _assert_mutable ( )
10199	call the method bytes_to_text with an arguments key and self.encoding , substitute the result for key .	key = bytes_to_text ( key , self . encoding )
10200	for every elt in list_ call the method bytes_to_text with 2 argument : elt and self.encoding , append the result into a list , substitute the resulting list for list_ .	list_ = [ bytes_to_text ( elt , self . encoding ) for elt in list_ ]
10201	call the method setlist from the base class of the QueryDict class , with arguments key and list_ .	super ( QueryDict , self ) . setlist ( key , list_ )
10202	define the method setlistdefault with 3 arguments : self , key and default_list set to None .	def setlistdefault ( self , key , default_list = None ) :
10203	call the method self._assert_mutable .	self . _assert_mutable ( )
10204	call the method setlistdefault from the base class of the class QueryDict , with arguments key and default_list , return the result .	return super ( QueryDict , self ) . setlistdefault ( key , default_list )
10205	define the method appendlist with 3 arguments : self , key and value .	def appendlist ( self , key , value ) :
10206	call the method self._assert_mutable .	self . _assert_mutable ( )
10207	call the method bytes_to_text with 2 arguments : key and self.encoding , substitute the result for key .	key = bytes_to_text ( key , self . encoding )
10208	call the method bytes_to_text with 2 arguments : value and self.encoding , substitute the result for value .	value = bytes_to_text ( value , self . encoding )
10209	call the method appendlist from the base class of the QueryDict class , with arguments key and value .	super ( QueryDict , self ) . appendlist ( key , value )
10210	define the method pop with 3 arguments : self , key and unpacked list args .	def pop ( self , key , * args ) :
10211	call the method self._assert_mutable .	self . _assert_mutable ( )
10212	call the method pop from the base class of the class QueryDict , with arguments key and unpacked list args , return the result .	return super ( QueryDict , self ) . pop ( key , * args )
10213	define the method popitem with an argument self .	def popitem ( self ) :
10214	call the method self._assert_mutable .	self . _assert_mutable ( )
10215	call the method popitem from the base class of the class QueryDict , return the result .	return super ( QueryDict , self ) . popitem ( )
10216	define the method clear with an argument self .	def clear ( self ) :
10217	call the method self._assert_mutable .	self . _assert_mutable ( )
10218	call the method clear from the base class of the class QueryDict , return the result .	super ( QueryDict , self ) . clear ( )
10219	define the method setdefault with 3 arguments : self , key and default set to None .	def setdefault ( self , key , default = None ) :
10220	call the method self._assert_mutable .	self . _assert_mutable ( )
10221	call the method bytes_to_text with 2 arguments : key and self.encoding , substitute the result for key .	key = bytes_to_text ( key , self . encoding )
10222	call the method bytes_to_text with 2 arguments : default and self.encoding , substitute the result for default .	default = bytes_to_text ( default , self . encoding )
10223	call the method setlistdefault from the base class of the class QueryDict , with arguments key and default_list , return the result .	return super ( QueryDict , self ) . setdefault ( key , default )
10224	define the method copy with an argument self .	def copy ( self ) :
10225	call the method self.__deepcopy__ with an empty dictionary as an argument .	return self . __deepcopy__ ( { } )
10226	define the method urlencode with 3 arguments : self and safe set to None .	def urlencode ( self , safe = None ) :
10227	output is an empty list .	output = [ ]
10228	if safe is true ,	if safe :
10229	call the function force_bytes with 2 arguments : safe and self.encoding , substitute it for safe .	safe = force_bytes ( safe , self . encoding )
10230	encode is an lambda function with arguments k and v , return value is string STR0 , where STR1 is replaced with : return value of the function quote called with arguments k and safe , and with return value of the function quote called with arguments v and safe .	encode = lambda k , v : STR0 % ( ( quote ( k , safe ) , quote ( v , safe ) ) )
10231	if not ,	else :
10232	encode is an lambda function with 2 arguments k and v , return value is the result of the function urlencode , called with an argument : dictionary containing element v for k .	encode = lambda k , v : urlencode ( { k : v } )
10233	for every k and list_ in return value of the method self.lists ,	for k , list_ in self . lists ( ) :
10234	call the function force_bytes with arguments k and self.encoding , substitute the result for k .	k = force_bytes ( k , self . encoding )
10235	for every v in list_ append to a list result of the function encode , called with arguments : k and result of the function force_bytes , called with arguments v and self.encoding , extend the output with the result .	output . extend ( [ encode ( k , force_bytes ( v , self . encoding ) ) for v in list_ ] )
10236	join elements of the output into a string , separated with STR0 , return the result .	return STR0 . join ( output )
10237	define the function build_request_repr with arguments : request , path_override set to None , GET_override set to None ,	def build_request_repr ( request , path_override = None , GET_override = None , POST_override = None , COOKIES_override = None , META_override = None ) :
10238	try ,	try :
10239	get is a tuple containing elements generated by the call to the function pformat with an argument GET_override , if GET_override is not None , or otherwise generated with the call to the function pformat with an argument request.GET .	get = ( pformat ( GET_override ) if GET_override is not None else pformat ( request . GET ) )
10240	if Exception exception is caught ,	except Exception :
10241	get is a string STR0 .	get = STR0
10242	if request._post_parse_error is true ,	if request . _post_parse_error :
10243	post is a string STR0 .	post = STR0
10244	if not ,	else :
10245	try ,	try :
10246	get is a tuple containing elements generated by the call to the function pformat with an argument POST_override , if POST_override is not None , or otherwise generated with the call to the function pformat with an argument request.POST .	post = ( pformat ( POST_override ) if POST_override is not None else pformat ( request . POST ) )
10247	if Exception exception is caught ,	except Exception :
10248	post is a string STR0 .	post = STR0
10249	try ,	try :
10250	get is a tuple containing elements generated by the call to the function pformat with an argument COOKIES_override , if COOKIES_override is not None , or otherwise generated with the call to the function pformat with an argument request.COOKIES .	cookies = ( pformat ( COOKIES_override ) if COOKIES_override is not None else pformat ( request . COOKIES ) )
10251	if Exception exception is caught ,	except Exception :
10252	cookies is a string STR0 .	cookies = STR0
10253	try ,	try :
10254	get is a tuple containing elements generated by the call to the function pformat with an argument META_override , if META_override is not None , or otherwise generated with the call to the function pformat with an argument request.META .	meta = ( pformat ( META_override ) if META_override is not None else pformat ( request . META ) )
10255	if Exception exception is caught ,	except Exception :
10256	meta is a string STR0 .	meta = STR0
10257	substitute path_override for path if path_override is not None , otherwise substitute request.path for path	path = path_override if path_override is not None else request . path
10258	call the function force_str with an argument string STR0 , where STR1 is replaced with request.__class__.__name__ , path , return value of the function six.text_type called with an argument get , return value of the function six.text_type called with an argument post , return value of the function six.text_type , called with an argument cookies and return value of the function six.text_type called with an argument meta .	return force_str ( STR0 % ( request . __class__ . __name__ , path , six . text_type ( get ) , six . text_type ( post ) , six . text_type ( cookies ) , six . text_type ( meta ) ) )
10259	define the function bytes_to_text with 2 arguments s and encoding .	def bytes_to_text ( s , encoding ) :
10260	if s is an instance of bytes class ,	if isinstance ( s , bytes ) :
10261	call the method six.text_type with 3 arguments : s , encoding and string STR0 .	return six . text_type ( s , encoding , STR0 )
10262	if not ,	else :
10263	return s .	return s
10264	define the function split_domain_port with an argument host .	def split_domain_port ( host ) :
10265	convert host to lowercase .	host = host . lower ( )
10266	call the method host_validation_re.match with an argument host .	if not host_validation_re . match ( host ) :
10267	return an empty string and an empty string .	return STR , STR
10268	if last element of host equals character STR0 ,	if host [ - 1 ] == STR0 :
10269	return host and an empty string .	return host , STR
10270	split host from the right side into 2 parts at the STR0 , substitute the result for bits .	bits = host . rsplit ( STR0 , 1 )
10271	if length of bits equals integer 2 ,	if len ( bits ) == 2 :
10272	add bits to a tuple , return it .	return tuple ( bits )
10273	return the first element of bits and an empty string .	return bits [ 0 ] , STR
10274	define the method validate_host with 2 arguments : host and allowed_hosts .	def validate_host ( host , allowed_hosts ) :
10275	if host ends with STR0 , remove the last element from host .	host = host [ : - 1 ] if host . endswith ( STR0 ) else host
10276	for every pattern in allowed_hosts :	for pattern in allowed_hosts :
10277	convert pattern to lowercase , substitute it for pattern .	pattern = pattern . lower ( )
10278	if pattern equals STR0 or pattern starts with STR1 or pattern equals host , and only if : host ends with STR2 and host ends with pattern or host is equal to all but first elements of pattern , substitute boolean true for match , otherwise substitute boolean False for match .	match = ( pattern == STR0 or pattern . startswith ( STR1 ) and ( host . endswith ( pattern ) or host == pattern [ 1 : ] ) or pattern == host )
10279	if match is true ,	if match :
10280	return boolean True .	return True
10281	return boolean False .	return False
10282	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
10283	import module datetime .	import datetime
10284	import module json .	import json
10285	import module sys .	import sys
10286	import module time .	import time
10287	from email.header import Header into default name space .	from email . header import Header
10288	from django.conf import settings into default name space .	from django . conf import settings
10289	from django.core import signals into default name space .	from django . core import signals
10290	from django.core import signing into default name space .	from django . core import signing
10291	from django.core.exceptions import DisallowedRedirect into default name space .	from django . core . exceptions import DisallowedRedirect
10292	from django.core.serializers.json import DjangoJSONEncode into default name space .	from django . core . serializers . json import DjangoJSONEncoder
10293	from django.http.cookie import SimpleCookie into default name space .	from django . http . cookie import SimpleCookie
10294	from django.utils import six and timezone into default name space .	from django . utils import six , timezone
10295	from django.utils.encoding import force_bytes , force_text and iri_to_uri into default name space .	from django . utils . encoding import force_bytes , force_text , iri_to_uri
10296	from django.utils.http import cookie_date into default name space .	from django . utils . http import cookie_date
10297	from django.utils.six.moves import map into default name space .	from django . utils . six . moves import map
10298	from django.utils.six.moves.urllib.parse import urlparse into default name space .	from django . utils . six . moves . urllib . parse import urlparse
10299	REASON_PHRASES is a dictionary containing 59 initial entries : STR0 for 100 , STR1 for 101 , STR2 for 102 , STR3 for 200 , STR4 for 201 , STR5 for 202 , STR6 for 203 , STR7 for 204 , STR8 for 205 , STR9 for 206 , STR10 for 207 , STR11 for 208 , STR12 for 226 , STR13 for 300 , STR14 for 301 , STR15 for 302 , STR16 for 303 , STR17 for 304 , STR18 for 305 , STR19 for 306 , STR20 for 307 , STR21 for 308 , STR22 for 400 , STR23 for 401 , STR24 for 402 , STR25 for 403 , STR26 for 404 , STR27 for 405 , STR28 for 406 , STR29 for 407 , STR30 for 408 , STR31 for 409 , STR32 for 410 , STR33 for 411 , STR34 for 412 , STR35 for 413 , STR36 for 414 , STR37 for 415 , STR38 for 416 , STR39 for 417 , STR40M A TEAPOT STR41UNPROCESSABLE ENTITY STR42LOCKED STR43FAILED DEPENDENCY STR44UPGRADE REQUIRED STR45PRECONDITION REQUIRED STR46TOO MANY REQUESTS STR47REQUEST HEADER FIELDS TOO LARGE STR48INTERNAL SERVER ERROR STR49NOT IMPLEMENTED STR50BAD GATEWAY STR51SERVICE UNAVAILABLE STR52GATEWAY TIMEOUT STR53HTTP VERSION NOT SUPPORTED STR54VARIANT ALSO NEGOTIATES STR55INSUFFICIENT STORAGE STR56LOOP DETECTED STR57NOT EXTENDED STR58NETWORK AUTHENTICATION REQUIRED ' for 511 .	REASON_PHRASES = { 100 : STR1 , 101 : STR2 , 102 : STR3 , 200 : STR4 , 201 : STR5 , 202 : STR6 , 203 : STR7 , 204 : STR8 , 205 : STR9 , 206 : STR10 , 207 : STR11 , 208 : STR12 , 226 : STR13 , 300 : STR14 , 301 : STR15 , 302 : STR16 , 303 : STR17 , 304 : STR18 , 305 : STR19 , 306 : STR20 , 307 : STR21 , 308 : STR22 , 400 : STR23 , 401 : STR24 , 402 : STR25 , 403 : STR26 , 404 : STR27 , 405 : STR28 , 406 : STR29 , 407 : STR30 , 408 : STR31 , 409 : STR32 , 410 : STR33 , 411 : STR34 , 412 : STR35 , 413 : STR36 , 414 : STR37 , 415 : STR38 , 416 : STR39 , 417 : STR40 , 418 : STR0 , 422 : STR41 , 423 : STR42 , 424 : STR43 , 426 : STR44 , 428 : STR45 , 429 : STR46 , 431 : STR47 , 500 : STR48 , 501 : STR49 , 502 : STR50 , 503 : STR51 , 504 : STR52 , 505 : STR53 , 506 : STR54 , 507 : STR55 , 508 : STR56 , 510 : STR57 , 511 : STR58 , }
10300	derive the class BadHeaderError from the ValueError base class .	class BadHeaderError ( ValueError ) :
10301	do nothing .	pass
10302	derive the class HttpResponseBase from the six.Iterator base class .	class HttpResponseBase ( six . Iterator ) :
10303	status_code is an integer 200 .	status_code = 200
10304	reason_phrase is None .	reason_phrase = None
10305	define the method __init__ with 4 arguments : self , content_type set to None , status set to None , reason set to None .	def __init__ ( self , content_type = None , status = None , reason = None ) :
10306	self._headers is an empty dictionary .	self . _headers = { }
10307	substitute settings.DEFAULT_CHARSET for self._charset .	self . _charset = settings . DEFAULT_CHARSET
10308	self._closable_objects is an empty list .	self . _closable_objects = [ ]
10309	self._handler_class is None .	self . _handler_class = None
10310	if content_type is false ,	if not content_type :
10311	replace STR1 in string STR0 with settings.DEFAULT_CONTENT_TYPE and self._charset , substitute it for content_type .	content_type = STR0 % ( settings . DEFAULT_CONTENT_TYPE , self . _charset )
10312	self.cookies is an instance of a class SimpleCookie .	self . cookies = SimpleCookie ( )
10313	if status is not None .	if status is not None :
10314	substitute status for self.status_code .	self . status_code = status
10315	if reason is not None ,	if reason is not None :
10316	substitute reason for self.reason_phrase .	self . reason_phrase = reason
10317	otherwise if self.reason_phrase is None ,	elif self . reason_phrase is None :
10318	get the value under the self.status_code key of the REASON_PHRASES dictionary , if it exists substitute it for the self.reason_phrase , if not , self.reason_phrase is a string STR0 .	self . reason_phrase = REASON_PHRASES . get ( self . status_code , STR0 )
10319	substitute content_type for value under the STR0 key of the self dictionary .	self [ STR0 ] = content_type
10320	define the method serialize_headers with an argument self .	def serialize_headers ( self ) :
10321	define the function to_bytes with arguments val and encoding .	def to_bytes ( val , encoding ) :
10322	if val is an instance of bytes , return val , otherwise return result of the method val.encode called with an argument encoding .	return val if isinstance ( val , bytes ) else val . encode ( encoding )
10323	for every key and value in return value of the self._headers.values method , call the function to_bytes with 2 arguments : key , and string STR0 and call the function to_bytes with 2 arguments : value and string STR1 , join the previous 2 results into a string , separated by STR2 , append it to a list , substitute the resulting list for headers .	headers = [ ( STR0 . join ( [ to_bytes ( key , STR1 ) , to_bytes ( value , STR2 ) ] ) ) for key , value in self . _headers . values ( ) ]
10324	join headers into a string , separated by string STR0 .	return STR0 . join ( headers )
10325	if six.PY3 is true ,	if six . PY3 :
10326	substitute serialize_headers for __bytes__ .	__bytes__ = serialize_headers
10327	if not ,	else :
10328	substitute serialize_headers for __str__ .	__str__ = serialize_headers
10329	define the method _convert_to_charset with 4 arguments : self , value , charset and mime_encode set to boolean False .	def _convert_to_charset ( self , value , charset , mime_encode = False ) :
10330	if value is not an instance of bytes or six.text_type classes ,	if not isinstance ( value , ( bytes , six . text_type ) ) :
10331	convert value to an string and substitute it for value .	value = str ( value )
10332	try ,	try :
10333	if six.PY3 is true ,	if six . PY3 :
10334	if value is an instance of str type ,	if isinstance ( value , str ) :
10335	call the method value.encode with an argument charset .	value . encode ( charset )
10336	if not ,	else :
10337	call the method value.decode with an argument charset , substitute the result for value .	value = value . decode ( charset )
10338	if not ,	else :
10339	if value is an instance of str type ,	if isinstance ( value , str ) :
10340	call the method value.decode with an argument charset .	value . decode ( charset )
10341	if not ,	else :
10342	call the method value.encode with an argument charset , substitute the result for value .	value = value . encode ( charset )
10343	if UnicodeError , renamed to e , exception is caught ,	except UnicodeError as e :
10344	if mime_encode is true ,	if mime_encode :
10345	instantiate class Header with 3 arguments : value , string STR0 , maxlinelen set to sys.maxsize , call the encode method on it , convert the result into a string and substitute it for value .	value = str ( Header ( value , STR0 , maxlinelen = sys . maxsize ) . encode ( ) )
10346	if not ,	else :
10347	replace STR0 in string STR1 for charset , append it to e.reason .	e . reason += STR0 % charset
10348	raise an exception .	raise
10349	convert STR0 to a string , if it is contained in value or STR1 converted to an string is contained in value ,	if str ( STR0 ) in value or str ( STR1 ) in value :
10350	raise an BadHeaderError exception with an argument string STR0 , where STR1 is replaced with value .	raise BadHeaderError ( STR0 % value )
10351	return value .	return value
10352	define the method __setitem__ with 3 arguments : self , header and value .	def __setitem__ ( self , header , value ) :
10353	call the method self._convert_to_charset with arguments : header and string STR0 , substitute the result for header .	header = self . _convert_to_charset ( header , STR0 )
10354	call the method self._convert_to_charset with arguments : header , string STR0 and mime_encode set to boolean True , substitute the result for value .	value = self . _convert_to_charset ( value , STR0 , mime_encode = True )
10355	substitute tuple containing 2 elements : header and value for the value under the header converted to lowercase key of the self._headers dictionary .	self . _headers [ header . lower ( ) ] = ( header , value )
10356	define the method __delitem__ with 2 arguments : self and header .	def __delitem__ ( self , header ) :
10357	try ,	try :
10358	delete the value under the header converted to lowercase key of the self._headers dictionary .	del self . _headers [ header . lower ( ) ]
10359	if KeyError exception is caught ,	except KeyError :
10360	do nothing .	pass
10361	define the method __getitem__ with 2 arguments : self and header .	def __getitem__ ( self , header ) :
10362	convert header to lowercase , use it as the key to get the value from the self._headers dictionary , return the second element of the result .	return self . _headers [ header . lower ( ) ] [ 1 ]
10363	define the method __getstate__ with an argument self .	def __getstate__ ( self ) :
10364	call the method self.__dict__.copy , substitute the result for state .	state = self . __dict__ . copy ( )
10365	get the value under the STR0 key of the state dictionary , convert it to a string and substitute it for value under the STR1 key of the state dictionary .	state [ STR0 ] = str ( state [ STR1 ] )
10366	return state .	return state
10367	define the method __setstate__ with 2 arguments : self and state .	def __setstate__ ( self , state ) :
10368	add state element to self.__dict__ dictionary .	self . __dict__ . update ( state )
10369	self.cookies is an instance of SimpleCookie class created with self.cookies as an argument .	self . cookies = SimpleCookie ( self . cookies )
10370	define the method has_header with 2 arguments : self and header .	def has_header ( self , header ) :
10371	convert deader to lowercase , if it is contained in self._headers return boolean True , if not , return boolean False .	return header . lower ( ) in self . _headers
10372	substitute has_header for __contains__ .	__contains__ = has_header
10373	define the method items with an argument self .	def items ( self ) :
10374	call the method self._headers.values , return the result ,	return self . _headers . values ( )
10375	define the method get with 3 arguments : self , header and alternate set to None .	def get ( self , header , alternate = None ) :
10376	convert header to lowercase , use it to as a key to get the value of the self._headers dictionary , if it exists return the second element of the result , if not , return alternate .	return self . _headers . get ( header . lower ( ) , ( None , alternate ) ) [ 1 ]
10377	define the method set_cookie with 9 arguments : self , key , value set to an empty string , max_age set to None , expires set to None ,	def set_cookie ( self , key , value = STR , max_age = None , expires = None , path = STR0 , domain = None , secure = False , httponly = False ) :
10378	substitute value for self.cookies dictionary value under the key key .	self . cookies [ key ] = value
10379	if expires is not None ,	if expires is not None :
10380	if expires is an instance of datetime.datetime class ,	if isinstance ( expires , datetime . datetime ) :
10381	call the method timezone.is_aware with an argument expires , if it evaluates to true ,	if timezone . is_aware ( expires ) :
10382	call the method timezone.make_naive with arguments : expires , timezone.utc , substitute the result for expires .	expires = timezone . make_naive ( expires , timezone . utc )
10383	call the method expires.utcnow , subtract the result from expires , substitute the result for delta .	delta = expires - expires . utcnow ( )
10384	call the method datetime.timedelta with an argument seconds set to integer 1 , increment delta by it .	delta = delta + datetime . timedelta ( seconds = 1 )
10385	expires is None .	expires = None
10386	multiply delta.days with an integer 86400 add to the result delta.seconds , if the result is greater than integer 0 , substitute it for max_age , if not , max_age is integer 0 .	max_age = max ( 0 , delta . days * 86400 + delta . seconds )
10387	if not ,	else :
10388	get the value under the key key of the self.cookies dictionary , substitute expires for STR0 key of the returned dictionary .	self . cookies [ key ] [ STR0 ] = expires
10389	if max_age is not None ,	if max_age is not None :
10390	get the value under the key key of the self.cookies dictionary , substitute max-age for STR0 key of the returned dictionary .	self . cookies [ key ] [ STR0 ] = max_age
10391	if expires is false ,	if not expires :
10392	get the value under the key key of the self.cookies dictionary , call the cookie_date function with an argument : sum of the result of the function time.time and max_age , substitute it for STR0 key of the previously returned dictionary .	self . cookies [ key ] [ STR0 ] = cookie_date ( time . time ( ) + max_age )
10393	if path is not None ,	if path is not None :
10394	get the value under the key key of the self.cookies dictionary , substitute path for STR0 key of the returned dictionary .	self . cookies [ key ] [ STR0 ] = path
10395	if domain is not None ,	if domain is not None :
10396	get the value under the key key of the self.cookies dictionary , domain expires for STR0 key of the returned dictionary .	self . cookies [ key ] [ STR0 ] = domain
10397	if secure is true ,	if secure :
10398	get the value under the key key of the self.cookies dictionary , substitute boolean True for STR0 key of the returned dictionary .	self . cookies [ key ] [ STR0 ] = True
10399	if httponly is true ,	if httponly :
10400	get the value under the key key of the self.cookies dictionary , substitute boolean True for STR0 key of the returned dictionary .	self . cookies [ key ] [ STR0 ] = True
10401	define the method set_signed_cookie with 5 arguments : self , key , value , salt as an empty string and unpacked dictionary kwarg .	def set_signed_cookie ( self , key , value , salt = STR , ** kwargs ) :
10402	call the method signing.get_cookie_signer with an argument salt set to sum of key and salt , call the method sign on the result with an argument value , substitute the result for value .	value = signing . get_cookie_signer ( salt = key + salt ) . sign ( value )
10403	call the method self.set_cookie with 3 arguments : key , value and unpacked dictionary kwargs , return the result .	return self . set_cookie ( key , value , ** kwargs )
10404	define the method delete_cookie with 4 arguments : self , key , path set to character STR0 and domain set to None .	def delete_cookie ( self , key , path = STR0 , domain = None ) :
10405	call the method self.set_cookie with 5 arguments : key , max_age as integer 0 , path as path , domain as domain , expires as a string STR0 , return the result .	self . set_cookie ( key , max_age = 0 , path = path , domain = domain , expires = STR0 )
10406	define the method make_bytes with 2 arguments : self and value .	def make_bytes ( self , value ) :
10407	call the method self.has_header with string STR0 as an argument , if it evaluates to true ,	if self . has_header ( STR0 ) :
10408	call the function bytes with an argument value , return the result .	return bytes ( value )
10409	if value is an instance of bytes class ,	if isinstance ( value , bytes ) :
10410	call the function bytes with an argument value , return the result .	return bytes ( value )
10411	if value is an instance of six.text_type class ,	if isinstance ( value , six . text_type ) :
10412	call the method value.encode with an argument self._charset , use the result as an argument for the call to the bytes function , return the result .	return bytes ( value . encode ( self . _charset ) )
10413	call the function force_bytes with arguments value and self._charset , return the result .	return force_bytes ( value , self . _charset )
10414	define the method close with an argument self .	def close ( self ) :
10415	for every closable in self._closable_objects ,	for closable in self . _closable_objects :
10416	try ,	try :
10417	call the method closable.close .	closable . close ( )
10418	if Exception exception is caught ,	except Exception :
10419	do nothing .	pass
10420	call the method signals.request_finished.send with an argument sender set to self._handler_class .	signals . request_finished . send ( sender = self . _handler_class )
10421	define the method write with 2 arguments : self and value .	def write ( self , content ) :
10422	raise an Exception exception with an argument string STR0 , where STR1 is replaced with self.__class__.__name__ .	raise Exception ( STR0 % self . __class__ . __name__ )
10423	define the method flush with an argument self .	def flush ( self ) :
10424	do nothing .	pass
10425	define the method tell with an argument self .	def tell ( self ) :
10426	raise an Exception exception with an argument string STR0 , where STR1 is replaced with self.__class__.__name__ .	raise Exception ( STR0 % self . __class__ . __name__ )
10427	derive the class HttpResponse from the HttpResponseBase base class .	class HttpResponse ( HttpResponseBase ) :
10428	streaming is boolean False .	streaming = False
10429	define the method __init__ with 4 arguments : self , content set to an empty list , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , content = STR , * args , ** kwargs ) :
10430	call the __init__ method from the base class of the HttpResponse class , with the arguments : unpacked list args and unpacked dictionary kwargs .	super ( HttpResponse , self ) . __init__ ( * args , ** kwargs )
10431	substitute content for self.content .	self . content = content
10432	define the serialize content with an argument self .	def serialize ( self ) :
10433	call method self.serialize_headers , append bytes string STR0 to the result , append self.content to the result , return it .	return self . serialize_headers ( ) + STR0 + self . content
10434	if six.PY3 is true ,	if six . PY3 :
10435	substitute serialize for __bytes__ .	__bytes__ = serialize
10436	if not ,	else :
10437	substitute serialize for __str__ .	__str__ = serialize
10438	property decorator ,	@ property
10439	define the method content with an argument self .	def content ( self ) :
10440	join self._container elements into a string , return it .	return STR . join ( self . _container )
10441	content.setter decorator ,	@ content . setter
10442	define the method content with 2 arguments : self and value .	def content ( self , value ) :
10443	if value has an STR0 attribute and value is not an instance of bytes or six.string_types class .	if hasattr ( value , STR0 ) and not isinstance ( value , ( bytes , six . string_types ) ) :
10444	if value has an STR0 attribute ,	if hasattr ( value , STR0 ) :
10445	append value to the self._closable_objects list .	self . _closable_objects . append ( value )
10446	call the self.make_bytes method with an argument chunk , for every chunk in value join the result to a bytes string , substitute the result for value .	value = STR . join ( self . make_bytes ( chunk ) for chunk in value )
10447	if not ,	else :
10448	call the method self.make_bytes with an argument value , substitute the result for value .	value = self . make_bytes ( value )
10449	self._container is a list containing element value .	self . _container = [ value ]
10450	define the method __iter__ with an argument self .	def __iter__ ( self ) :
10451	return self._container converted into a iterable .	return iter ( self . _container )
10452	define the method write with 2 arguments : self and content .	def write ( self , content ) :
10453	call the method self.make_bytes with an argument content , append it to self._container .	self . _container . append ( self . make_bytes ( content ) )
10454	define the method tell with an argument self .	def tell ( self ) :
10455	return the length of self.content .	return len ( self . content )
10456	derive the class StreamingHttpResponse from the HttpResponseBase base class .	class StreamingHttpResponse ( HttpResponseBase ) :
10457	streaming is boolean True .	streaming = True
10458	define the method __init__ with 4 arguments : self , result of the function streaming_content= ( ) , unpacked list args , and unpacked dictionary kwargs .	def __init__ ( self , streaming_content = ( ) , * args , ** kwargs ) :
10459	call the __init__ method from the base class of the StreamingHttpResponse class , called with arguments : unpacked list args , and unpacked dictionary kwargs .	super ( StreamingHttpResponse , self ) . __init__ ( * args , ** kwargs )
10460	substitute streaming_content for self.streaming_content .	self . streaming_content = streaming_content
10461	property decorator ,	@ property
10462	define the method content with an argument self .	def content ( self ) :
10463	raise an AttributeError with an argument string STR0Use `streaming_content` instead . `` , where STR1 is replaced with self.__class__.__name__ .	raise AttributeError ( STR0 % self . __class__ . __name__ )
10464	property decorator ,	@ property
10465	define the method serialize_headers with an argument self .	def streaming_content ( self ) :
10466	map elements of self._iterator through self.make_bytes function , return the result .	return map ( self . make_bytes , self . _iterator )
10467	streaming_content.setter decorator ,	@ streaming_content . setter
10468	define the method streaming_content with 2 arguments : self and value .	def streaming_content ( self , value ) :
10469	convert value into a iterator , substitute the result for self._iterator .	self . _iterator = iter ( value )
10470	if value has an attribute STR0 ,	if hasattr ( value , STR0 ) :
10471	append value to self._closable_objects list .	self . _closable_objects . append ( value )
10472	define the method __iter__ with an argument self .	def __iter__ ( self ) :
10473	return self.streaming_content	return self . streaming_content
10474	derive the class HttpResponseRedirectBase from the HttpResponse base class .	class HttpResponseRedirectBase ( HttpResponse ) :
10475	allowed_schemes is an list containing 3 elements : strings STR0 , STR1 and STR2 .	allowed_schemes = [ STR0 , STR1 , STR2 ]
10476	define the method __init__ with 4 arguments : self , redirect_to , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , redirect_to , * args , ** kwargs ) :
10477	call the function force_text with an argument redirect_to , use the result as an argument for the call to the function urlparse , substitute the result for parsed .	parsed = urlparse ( force_text ( redirect_to ) )
10478	if parsed.scheme is true and parsed.scheme is not contained in self.allowed_schemes ,	if parsed . scheme and parsed . scheme not in self . allowed_schemes :
10479	raise an DisallowedRedirect exception with an argument string STR0 , where STR1 is replaced with parsed.scheme .	raise DisallowedRedirect ( STR0 % parsed . scheme )
10480	call the __init__ method from the base class of the HttpResponseRedirectBase class , called with arguments : unpacked list args , and unpacked dictionary kwargs .	super ( HttpResponseRedirectBase , self ) . __init__ ( * args , ** kwargs )
10481	call the function iri_to_uri with an argument redirect_to , substitute the result for the value under the STR0 key of the self dictionary .	self [ STR0 ] = iri_to_uri ( redirect_to )
10482	url is a property of the class , lambda function is getter attribute with an argument self and return value is the value under the STR0 key of the self dictionary .	url = property ( lambda self : self [ STR0 ] )
10483	derive the class HttpResponseRedirect from the HttpResponseRedirectBase base class .	class HttpResponseRedirect ( HttpResponseRedirectBase ) :
10484	status_code is an integer 302 .	status_code = 302
10485	derive the class HttpResponsePermanentRedirect from the HttpResponseRedirectBase base class .	class HttpResponsePermanentRedirect ( HttpResponseRedirectBase ) :
10486	status_code is an integer 301 .	status_code = 301
10487	derive the class HttpResponseNotModified from the HttpResponse base class .	class HttpResponseNotModified ( HttpResponse ) :
10488	status_code is an integer 304 .	status_code = 304
10489	define the method __init__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , * args , ** kwargs ) :
10490	call the __init__ method from the base class of the HttpResponseNotModified class , called with arguments : unpacked list args , and unpacked dictionary kwargs .	super ( HttpResponseNotModified , self ) . __init__ ( * args , ** kwargs )
10491	delete the value under the STR0 key of the self dictionary .	del self [ STR0 ]
10492	HttpResponse.content.setter property ,	@ HttpResponse . content . setter
10493	define the method content with self and value .	def content ( self , value ) :
10494	if value ,	if value :
10495	raise an AttributeError exception with an argument string STR0 .	raise AttributeError ( STR0 )
10496	self._container is an list .	self . _container = [ ]
10497	derive the class HttpResponseBadRequest from the HttpResponse base class .	class HttpResponseBadRequest ( HttpResponse ) :
10498	status_code is an integer 400 .	status_code = 400
10499	derive the class HttpResponseNotFound from the HttpResponse base class .	class HttpResponseNotFound ( HttpResponse ) :
10500	status_code is an integer 404 .	status_code = 404
10501	derive the class HttpResponseForbidden from the HttpResponse base class .	class HttpResponseForbidden ( HttpResponse ) :
10502	status_code is an integer 403 .	status_code = 403
10503	derive the class HttpResponseNotAllowed from the HttpResponse base class .	class HttpResponseNotAllowed ( HttpResponse ) :
10504	status_code is an integer 405 .	status_code = 405
10505	define the method __init__ with 4 arguments : self , permitted_methods , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , permitted_methods , * args , ** kwargs ) :
10506	call the __init__ method from the base class of the HttpResponseNotAllowed class , called with arguments : unpacked list args , and unpacked dictionary kwargs .	super ( HttpResponseNotAllowed , self ) . __init__ ( * args , ** kwargs )
10507	join into a string permitted_methods , separated by string STR0 , substitute it for value under the STR1 key of the self dictionary .	self [ STR0 ] = STR1 . join ( permitted_methods )
10508	derive the class HttpResponseGone from the HttpResponse base class .	class HttpResponseGone ( HttpResponse ) :
10509	status_code is an integer 410 .	status_code = 410
10510	derive the class HttpResponseServerError from the HttpResponse base class .	class HttpResponseServerError ( HttpResponse ) :
10511	status_code is an integer 500 .	status_code = 500
10512	derive the class Http404 from the Exception base class .	class Http404 ( Exception ) :
10513	do nothing .	pass
10514	derive the class JsonResponse from the HttpResponse base class .	class JsonResponse ( HttpResponse ) :
10515	define the method __init__ with 5 arguments : self , data , encoder set to DjangoJSONEncoder , safe set to boolean True , and unpacked dictionary kwargs .	def __init__ ( self , data , encoder = DjangoJSONEncoder , safe = True , ** kwargs ) :
10516	if safe is true and data is not an instance of dict type .	if safe and not isinstance ( data , dict ) :
10517	raise an TypeError exception with an argument string STR0 .	raise TypeError ( STR0 )
10518	if STR0 key doesnt exist in kwargs , set its value to STR1 .	kwargs . setdefault ( STR0 , STR1 )
10519	serialize data to JSON format with cls set to encoder , substitute it for data .	data = json . dumps ( data , cls = encoder )
10520	call the __init__ method from the base class of the JsonResponse class , called with arguments : content set to data ,	super ( JsonResponse , self ) . __init__ ( content = data , ** kwargs )
10521	define function fix_location_header with request and response as arguments .	def fix_location_header ( request , response ) :
10522	if STR0 is contained in response and function request.get_host evaluates to True ,	if STR0 in response and request . get_host ( ) :
10523	modify value at the key STR0 of the dictionary response by applying function request.build_absolute_uri on it .	response [ STR0 ] = request . build_absolute_uri ( response [ STR1 ] )
10524	return response .	return response
10525	define the function conditional_content_removal with request and response as the arguments .	def conditional_content_removal ( request , response ) :
10526	if response.status_code is lesser than integer 200 and grater or equal than 100 , or response.status_code equals to integer 204 or 304 ,	if 100 <= response . status_code < 200 or response . status_code in ( 204 , 304 ) :
10527	if response.streaming is True ,	if response . streaming :
10528	response.streaming_content is an empty list .	response . streaming_content = [ ]
10529	if not ,	else :
10530	response.content is bytes empty string .	response . content = STR
10531	substitute char STR0 for the value under the STR1 key of the response dictionary .	response [ STR0 ] = STR1
10532	if request.method equals to string STR0 ,	if request . method == STR0 :
10533	if response.streaming is true ,	if response . streaming :
10534	response.streaming_content is an empty list .	response . streaming_content = [ ]
10535	if not ,	else :
10536	response.content is bytes empty string .	response . content = STR
10537	return response .	return response
10538	from django.template.base import ALLOWED_VARIABLE_CHARS , BLOCK_TAG_END , BLOCK_TAG_START , COMMENT_TAG_END , COMMENT_TAG_START , FILTER_ARGUMENT_SEPARATOR , FILTER_SEPARATOR , SINGLE_BRACE_END , SINGLE_BRACE_START , TOKEN_BLOCK , TOKEN_COMMENT , TOKEN_TEXT , TOKEN_VAR , TRANSLATOR_COMMENT_MARK , UNKNOWN_SOURCE , VARIABLE_ATTRIBUTE_SEPARATOR , VARIABLE_TAG_END , VARIABLE_TAG_START , filter_re and tag_re .	from django . template . base import ( ALLOWED_VARIABLE_CHARS , BLOCK_TAG_END , BLOCK_TAG_START , COMMENT_TAG_END , COMMENT_TAG_START , FILTER_ARGUMENT_SEPARATOR , FILTER_SEPARATOR , SINGLE_BRACE_END , SINGLE_BRACE_START , TOKEN_BLOCK , TOKEN_COMMENT , TOKEN_TEXT , TOKEN_VAR , TRANSLATOR_COMMENT_MARK , UNKNOWN_SOURCE , VARIABLE_ATTRIBUTE_SEPARATOR , VARIABLE_TAG_END , VARIABLE_TAG_START , filter_re , tag_re )
10539	from django.template.base import ContextPopException , InvalidTemplateLibrary , TemplateDoesNotExist , TemplateEncodingError , TemplateSyntaxError and VariableDoesNotExist .	from django . template . base import ( ContextPopException , InvalidTemplateLibrary , TemplateDoesNotExist , TemplateEncodingError , TemplateSyntaxError , VariableDoesNotExist )
10540	from django.template.base import Context , FilterExpression , Lexer , Node , NodeList , Parser , RequestContext , Origin , StringOrigin , Template , TextNode , Token , TokenParser , Variable , VariableNode , constant_string and filter_raw_string .	from django . template . base import ( Context , FilterExpression , Lexer , Node , NodeList , Parser , RequestContext , Origin , StringOrigin , Template , TextNode , Token , TokenParser , Variable , VariableNode , constant_string , filter_raw_string )
10541	from django.template.base import compile_string , resolve_variable , unescape_string_literal and generic_tag_compiler .	from django . template . base import ( compile_string , resolve_variable , unescape_string_literal , generic_tag_compiler )
10542	from django.template.base import Library , add_to_builtins , builtins , get_library , get_templatetags_modules , get_text_list , import_library and libraries .	from django . template . base import ( Library , add_to_builtins , builtins , get_library , get_templatetags_modules , get_text_list , import_library , libraries )
10543	__all__ is a tuple containing 4 strings : STR0 , STR1 , STR2 and STR3 .	__all__ = ( STR0 , STR1 , STR2 , STR3 )
10544	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
10545	import module re .	import re
10546	from functools import partial into default name space .	from functools import partial
10547	from importlib import import_module into default name space .	from importlib import import_module
10548	from inspect import getargspec and getcallargs into default name space .	from inspect import getargspec , getcallargs
10549	import module warnings .	import warnings
10550	from django.apps import apps into default name space .	from django . apps import apps
10551	from django.conf import settings into default name space .	from django . conf import settings
10552	from django.template.context import BaseContext , Context , RequestContext and ContextPopException into default namespace .	from django . template . context import ( BaseContext , Context , RequestContext , ContextPopException )
10553	from django.utils.deprecation import RemovedInDjango20Warning into default name space .	from django . utils . deprecation import RemovedInDjango20Warning
10554	from django.utils.itercompat import is_iterable into default name space .	from django . utils . itercompat import is_iterable
10555	from django.utils.text import smart_split , unescape_string_literal and get_text_list into default namespace .	from django . utils . text import ( smart_split , unescape_string_literal , get_text_list )
10556	from django.utils.encoding import force_str and force_text into default name space .	from django . utils . encoding import force_str , force_text
10557	from django.utils.translation import ugettext_lazy and pgettext_lazy into default name space .	from django . utils . translation import ugettext_lazy , pgettext_lazy
10558	from django.utils.safestring import SafeData , EscapeData , mark_safe and mark_for_escaping into default namespace .	from django . utils . safestring import ( SafeData , EscapeData , mark_safe , mark_for_escaping )
10559	from django.utils.formats import localize into default name space .	from django . utils . formats import localize
10560	from django.utils.html import escape into default name space .	from django . utils . html import escape
10561	from django.utils.module_loading import module_has_submodule into default name space .	from django . utils . module_loading import module_has_submodule
10562	from django.utils import six into default name space .	from django . utils import six
10563	from django.utils.timezone import template_localtime into default name space .	from django . utils . timezone import template_localtime
10564	from django.utils.encoding import python_2_unicode_compatible into default name space .	from django . utils . encoding import python_2_unicode_compatible
10565	TOKEN_TEXT is integer 0	TOKEN_TEXT = 0
10566	TOKEN_VAR is integer 1	TOKEN_VAR = 1
10567	TOKEN_BLOCK is integer 2	TOKEN_BLOCK = 2
10568	TOKEN_COMMENT is integer 3 .	TOKEN_COMMENT = 3
10569	TOKEN_MAPPING is a dictionary with 4 initial entries : STR0 for TOKEN_TEXT , STR1 for TOKEN_VAR , STR2 for TOKEN_BLOCK , and STR3 for TOKEN_COMMENT .	TOKEN_MAPPING = { TOKEN_TEXT : STR0 , TOKEN_VAR : STR1 , TOKEN_BLOCK : STR2 , TOKEN_COMMENT : STR3 , }
10570	FILTER_SEPARATOR is a string STR0 .	FILTER_SEPARATOR = STR0
10571	FILTER_ARGUMENT_SEPARATOR is a string STR0 .	FILTER_ARGUMENT_SEPARATOR = STR0
10572	VARIABLE_ATTRIBUTE_SEPARATOR is a string STR0 .	VARIABLE_ATTRIBUTE_SEPARATOR = STR0
10573	BLOCK_TAG_START is a string STR0 .	BLOCK_TAG_START = STR0
10574	BLOCK_TAG_END is a string STR0 .	BLOCK_TAG_END = STR0
10575	VARIABLE_TAG_START is a string STR0 .	VARIABLE_TAG_START = STR0
10576	VARIABLE_TAG_END is a string STR0 .	VARIABLE_TAG_END = STR0
10577	COMMENT_TAG_START is a string STR0 .	COMMENT_TAG_START = STR0
10578	COMMENT_TAG_END is a string STR0 .	COMMENT_TAG_END = STR0
10579	TRANSLATOR_COMMENT_MARK is a string STR0 .	TRANSLATOR_COMMENT_MARK = STR0
10580	SINGLE_BRACE_START is a string STR0 .	SINGLE_BRACE_START = STR0
10581	SINGLE_BRACE_END is a string STR0 .	SINGLE_BRACE_END = STR0
10582	ALLOWED_VARIABLE_CHARS is a string STR0 .	ALLOWED_VARIABLE_CHARS = ( STR0 )
10583	UNKNOWN_SOURCE is a string STR0 .	UNKNOWN_SOURCE = STR0
10584	call the function re.compile with an argument string STR0 , substitute all occurrences of STR1 with , return value of the function re.escape called with an argument BLOCK_TAG_START , return value of the function re.escape called with an argument BLOCK_TAG_END , return value of the function re.escape called with an argument VARIABLE_TAG_START , return value of the function re.escape called with an argument VARIABLE_TAG_END , return value of the function re.escape called with an argument COMMENT_TAG_START , and return value of the function re.escape called with an argument COMMENT_TAG_END , substitute the result for tag_re .	tag_re = ( re . compile ( STR0 % ( re . escape ( BLOCK_TAG_START ) , re . escape ( BLOCK_TAG_END ) , re . escape ( VARIABLE_TAG_START ) , re . escape ( VARIABLE_TAG_END ) , re . escape ( COMMENT_TAG_START ) , re . escape ( COMMENT_TAG_END ) ) ) )
10585	libraries is an empty dictionary .	libraries = { }
10586	builtins is an empty list .	builtins = [ ]
10587	invalid_var_format_string is None .	invalid_var_format_string = None
10588	derive the class TemplateSyntaxError form the base class Exception .	class TemplateSyntaxError ( Exception ) :
10589	do nothing .	pass
10590	derive the class TemplateDoesNotExist form the base class Exception .	class TemplateDoesNotExist ( Exception ) :
10591	do nothing .	pass
10592	derive the class TemplateEncodingError form the base class Exception .	class TemplateEncodingError ( Exception ) :
10593	do nothing .	pass
10594	python_2_unicode_compatible decorator ,	@ python_2_unicode_compatible
10595	derive the class VariableDoesNotExist form the base class Exception .	class VariableDoesNotExist ( Exception ) :
10596	define the method __init__ with 3 arguments : self , msg and params set to an empty tuple .	def __init__ ( self , msg , params = ( ) ) :
10597	substitute msg for self.msg .	self . msg = msg
10598	substitute params for self.params .	self . params = params
10599	define the method __str__ with an argument self .	def __str__ ( self ) :
10600	return self.msg formatted with a tuple , with elements generated from return value of the function force_text with 2 arguments : p and errors set to string STR0 , for p in self.params .	return self . msg % tuple ( force_text ( p , errors = STR0 ) for p in self . params )
10601	derive the class InvalidTemplateLibrary form the base class Exception .	class InvalidTemplateLibrary ( Exception ) :
10602	do nothing .	pass
10603	derive the class Origin form the base class object .	class Origin ( object ) :
10604	define the method __init__ with 2 arguments : self and name .	def __init__ ( self , name ) :
10605	substitute name for self.name .	self . name = name
10606	define the method reload with an argument self .	def reload ( self ) :
10607	raise an NotImplementedError exception with an argument string STR0 .	raise NotImplementedError ( STR0 )
10608	define the method with reload with an argument self .	def __str__ ( self ) :
10609	return self.name .	return self . name
10610	derive the class StringOrigin form the base class Origin .	class StringOrigin ( Origin ) :
10611	define the method __init__ with 2 arguments : self and source .	def __init__ ( self , source ) :
10612	call the method __init__ with an argument UNKNOWN_SOURCE , from the base class of the class StringOrigin .	super ( StringOrigin , self ) . __init__ ( UNKNOWN_SOURCE )
10613	substitute source for self.source .	self . source = source
10614	define the method with reload with an argument self .	def reload ( self ) :
10615	return self.source .	return self . source
10616	derive the class Template form the base class object .	class Template ( object ) :
10617	define the method __init__ with 4 arguments : self , template_string , origin set to None and name set to None .	def __init__ ( self , template_string , origin = None , name = None ) :
10618	try ,	try :
10619	call the function force_text with an argument template_string .	template_string = force_text ( template_string )
10620	if UnicodeDecodeError exception is caught ,	except UnicodeDecodeError :
10621	raise an TemplateEncodingError exception with an argument STR0 .	raise TemplateEncodingError ( STR0 )
10622	if settings.TEMPLATE_DEBUG is true and origin is None ,	if settings . TEMPLATE_DEBUG and origin is None :
10623	origin is an instance of StringOrigin class created with an argument template_string .	origin = StringOrigin ( template_string )
10624	call the function compile_string with 2 arguments : template_string and origin , substitute the result for self.nodelist .	self . nodelist = compile_string ( template_string , origin )
10625	substitute name for self.name .	self . name = name
10626	substitute origin for self.origin .	self . origin = origin
10627	define the method __iter__ with an argument self .	def __iter__ ( self ) :
10628	for every node in self.nodelist ,	for node in self . nodelist :
10629	for every subnode in node ,	for subnode in node :
10630	yield subnode .	yield subnode
10631	define the method _render with 2 arguments self and context .	def _render ( self , context ) :
10632	call the method self.nodelist.render with an argument context , return the result .	return self . nodelist . render ( context )
10633	define the method render with 2 arguments self and context .	def render ( self , context ) :
10634	call the method context.render_context.push .	context . render_context . push ( )
10635	try ,	try :
10636	call the method self._render with an argument context , return the result ,	return self . _render ( context )
10637	finally perform ,	finally :
10638	remove the first element from context.render_context .	context . render_context . pop ( )
10639	define the method compile_string with 2 arguments : template_string and origin .	def compile_string ( template_string , origin ) :
10640	if settings.TEMPLATE_DEBUG is true ,	if settings . TEMPLATE_DEBUG :
10641	from django.template.debug import DebugLexer and DebugParser .	from django . template . debug import DebugLexer , DebugParser
10642	substitute DebugLexer and DebugParser for lexer_class and parser_class .	lexer_class , parser_class = DebugLexer , DebugParser
10643	if not ,	else :
10644	substitute Lexer and Parser for lexer_class and parser_class .	lexer_class , parser_class = Lexer , Parser
10645	call the method lexer_class with an arguments template_string and origin , substitute the result for lexer .	lexer = lexer_class ( template_string , origin )
10646	call the method lexer.tokenize , use it as an argument for the call to the parser_class function , substitute the result for parser .	parser = parser_class ( lexer . tokenize ( ) )
10647	call the method parser.parse , return the result .	return parser . parse ( )
10648	derive the class Token form the base class object .	class Token ( object ) :
10649	define the method __init__ with 3 arguments : self , token_type and contents .	def __init__ ( self , token_type , contents ) :
10650	substitute token_type and contents for self.token_type and self.contents .	self . token_type , self . contents = token_type , contents
10651	self.lineno is None .	self . lineno = None
10652	define the method __str__ with an argument self .	def __str__ ( self ) :
10653	substitute value under the self.token_type key of the TOKEN_MAPPING dictionary for token_name .	token_name = TOKEN_MAPPING [ self . token_type ]
10654	return a string STR1 with STR2 , replace STR3 with token_name and 20 self.contents elements with every newline deleted .	return ( STR1 % ( token_name , self . contents [ : 20 ] . replace ( STR2 , STR ) ) )
10655	define the method split_contents with an argument self .	def split_contents ( self ) :
10656	split is an empty list .	split = [ ]
10657	call the function smart_split with an argument self.contents , substitute the result converted to an iterable for bits .	bits = iter ( smart_split ( self . contents ) )
10658	for every bit in bits ,	for bit in bits :
10659	if bit starts with STR0 ot bit starts with STRspecial ,	if bit . startswith ( STR0 ) or bit . startswith ( STRspecial ) :
10660	append STR0 to third element of bit , substitute it for sentinal .	sentinal = bit [ 2 ] + STR0
10661	trans_bit is a list with an element bit .	trans_bit = [ bit ]
10662	while bit doesnt end with sential ,	while not bit . endswith ( sentinal ) :
10663	call the method next with an argument bits , substitute the result for bit .	bit = next ( bits )
10664	append bit to trans_bit .	trans_bit . append ( bit )
10665	join trans_bit into a string separated with whitespaces , substitute the result for bit .	bit = STR . join ( trans_bit )
10666	append bit to split .	split . append ( bit )
10667	return split .	return split
10668	derive the class Lexer form the base class object .	class Lexer ( object ) :
10669	define the method __init__ with 3 arguments : self , template_string and origin .	def __init__ ( self , template_string , origin ) :
10670	substitute template_string for self.template_string .	self . template_string = template_string
10671	substitute origin for self.origin .	self . origin = origin
10672	self.lineno is integer 1 .	self . lineno = 1
10673	self.verbatim is boolean False .	self . verbatim = False
10674	define the method tokenize with an argument self .	def tokenize ( self ) :
10675	in_tag is boolean False .	in_tag = False
10676	result is an empty list .	result = [ ]
10677	split tag_re by self.template_string separator , for every bit in result ,	for bit in tag_re . split ( self . template_string ) :
10678	if bit is true ,	if bit :
10679	call the method self.create_token with 2 arguments bit and in_tag , append the result to result .	result . append ( self . create_token ( bit , in_tag ) )
10680	in_tag is boolean True if in_tag is False , otherwise is boolean False .	in_tag = not in_tag
10681	return result .	return result
10682	define the method create_token with 3 arguments : self , token_string and in_tag .	def create_token ( self , token_string , in_tag ) :
10683	if in_tag is true and token_string starts with BLOCK_TAG_START .	if in_tag and token_string . startswith ( BLOCK_TAG_START ) :
10684	take elements of token_string from second to second last element and strip the whitespaces surrounding the result , substitute the result for block_content .	block_content = token_string [ 2 : - 2 ] . strip ( )
10685	if self.verbatim is true and block_content equals self.verbatim ,	if self . verbatim and block_content == self . verbatim :
10686	self.verbatim is boolean False .	self . verbatim = False
10687	if in_tag and is not contained in self.verbatim ,	if in_tag and not self . verbatim :
10688	if token_string starts with VARIABLE_TAG_START ,	if token_string . startswith ( VARIABLE_TAG_START ) :
10689	token is an instance of Token class , created with 2 arguments : TOKEN_VAR , and elements of token_string from second to second last element wiht the whitespaces striped from the both sides .	token = Token ( TOKEN_VAR , token_string [ 2 : - 2 ] . strip ( ) )
10690	otherwise if token_string starts with BLOCK_TAG_START ,	elif token_string . startswith ( BLOCK_TAG_START ) :
10691	if first nine elements of block_content is string STR0 or STR1 ,	if block_content [ : 9 ] in ( STR0 , STR1 ) :
10692	append block_content to a string STR0 , substitute the result for self.verbatim .	self . verbatim = STR0 % block_content
10693	token is an instance of Token class , created with 2 arguments : TOKEN_BLOCK and block_content .	token = Token ( TOKEN_BLOCK , block_content )
10694	otherwise if token_string starts with COMMENT_TAG_START ,	elif token_string . startswith ( COMMENT_TAG_START ) :
10695	content is an empty string .	content = STR
10696	call the method token_string.find with an argument TRANSLATOR_COMMENT_MARK , if it evaluates to true ,	if token_string . find ( TRANSLATOR_COMMENT_MARK ) :
10697	take elements of token_string from second to second last element and strip the whitespaces surrounding the result , substitute the result for content .	content = token_string [ 2 : - 2 ] . strip ( )
10698	token is an instance of Token class , created with 2 arguments : TOKEN_COMMENT and content .	token = Token ( TOKEN_COMMENT , content )
10699	if not ,	else :
10700	token is an instance of Token class , created with 2 arguments : TOKEN_TEXT and token_string .	token = Token ( TOKEN_TEXT , token_string )
10701	substitute self.lineno for token.lineno .	token . lineno = self . lineno
10702	call the method token_string.count with an argument STR0 , append the result to self.lineno .	self . lineno += token_string . count ( STR0 )
10703	return token .	return token
10704	derive the class Parser form the base class object .	class Parser ( object ) :
10705	define the method __init__ with 2 arguments : self and token .	def __init__ ( self , tokens ) :
10706	substitute tokens for self.tokens .	self . tokens = tokens
10707	self.tags is an empty dictionary .	self . tags = { }
10708	self.filters is an empty dictionary .	self . filters = { }
10709	for every lib in builtins ,	for lib in builtins :
10710	call the method self.add_library with an argument lib .	self . add_library ( lib )
10711	define the emethod parse with 2 arguments : self and parse_until set to None .	def parse ( self , parse_until = None ) :
10712	if parse_until is None ,	if parse_until is None :
10713	parse_until is an empty list ,	parse_until = [ ]
10714	call the method self.create_nodelist , substitute the result for nodelist .	nodelist = self . create_nodelist ( )
10715	while self.tokens is true ,	while self . tokens :
10716	call the method self.next_token , substitute the result for token .	token = self . next_token ( )
10717	if token.token_type equals integer 0 ,	if token . token_type == 0 :
10718	call the method self.extend_nodelist with 3 arguments : nodelist , instance of TextNode class , created with an argument token.contents , and token .	self . extend_nodelist ( nodelist , TextNode ( token . contents ) , token )
10719	otherwise if token.token_type equals integer 1 ,	elif token . token_type == 1 :
10720	if token.contents is false ,	if not token . contents :
10721	call the method self.empty_variable with an argument token ,	self . empty_variable ( token )
10722	try ,	try :
10723	call the method self.compile_filter with an argument token.contents , substitute the result for filter_expression .	filter_expression = self . compile_filter ( token . contents )
10724	if TemplateSyntaxError , replaced with e , exception is caught ,	except TemplateSyntaxError as e :
10725	call the method self.compile_filter_error with 2 arguments : token and e , if it evaluates to false ,	if not self . compile_filter_error ( token , e ) :
10726	raise an exception ,	raise
10727	call the method self.create_variable_node with an argument filter_expression , substitute the result for var_node .	var_node = self . create_variable_node ( filter_expression )
10728	call the method self.extend_nodelist with 3 arguments : nodelist , var_node and token .	self . extend_nodelist ( nodelist , var_node , token )
10729	otherwise if token.token_type equals integer 2 ,	elif token . token_type == 2 :
10730	try ,	try :
10731	split token.contents into separate words , substitute the first element of the result for command .	command = token . contents . split ( ) [ 0 ]
10732	if IndexError exception is caught ,	except IndexError :
10733	call the method self.empty_block_tag with an argument token .	self . empty_block_tag ( token )
10734	if command is contained in parse_until ,	if command in parse_until :
10735	call the method self.prepend_token with an argument token ,	self . prepend_token ( token )
10736	return nodelist .	return nodelist
10737	call the method self.enter_command with 2 arguments command and token .	self . enter_command ( command , token )
10738	try ,	try :
10739	substitute the value under the command key of self.tags dictionary for compile_func .	compile_func = self . tags [ command ]
10740	if KeyError exception is caught ,	except KeyError :
10741	call the method self.invalid_block_tag with 3 arguments : token , command and parse_until .	self . invalid_block_tag ( token , command , parse_until )
10742	try ,	try :
10743	call the method compile_func with 2 arguments self and token , substitute the result for compiled_result .	compiled_result = compile_func ( self , token )
10744	if TemplateSyntaxError , renamed to e , exception is caught ,	except TemplateSyntaxError as e :
10745	call the method self.compile_function_error with 2 arguments token and e , if it evaluates to false ,	if not self . compile_function_error ( token , e ) :
10746	raise an exception ,	raise
10747	call the method self.extend_nodelist with 3 arguments : nodelist , compiled_result and token .	self . extend_nodelist ( nodelist , compiled_result , token )
10748	call the method self.exit_command .	self . exit_command ( )
10749	if parse_until is true ,	if parse_until :
10750	call the method self.unclosed_block_tag with an argument parse_until .	self . unclosed_block_tag ( parse_until )
10751	return nodelist .	return nodelist
10752	define the method skip_past with 2 arguments : self and endtag .	def skip_past ( self , endtag ) :
10753	while self.tokens is true ,	while self . tokens :
10754	call the method self.next_token , substitute the result for token .	token = self . next_token ( )
10755	if token.token_type equals TOKEN_BLOCK and token.contents equals endtag ,	if token . token_type == TOKEN_BLOCK and token . contents == endtag :
10756	return nothing .	return
10757	call the method self.unclosed_block_tag with an argument list with an element endtag .	self . unclosed_block_tag ( [ endtag ] )
10758	define the method create_variable_node with 2 arguments self and filter_expression .	def create_variable_node ( self , filter_expression ) :
10759	return an instance of VariableNode class with an argument filter_expression .	return VariableNode ( filter_expression )
10760	define the method create_nodelist with an argument self .	def create_nodelist ( self ) :
10761	return an instance of NodeList class .	return NodeList ( )
10762	define the method extend_nodelist with 4 arguments : self , nodelist , node and token .	def extend_nodelist ( self , nodelist , node , token ) :
10763	if node.must_be_first is true and nodelist is true ,	if node . must_be_first and nodelist :
10764	try ,	try :
10765	if nodelist.contains_nontext is true ,	if nodelist . contains_nontext :
10766	raise AttributeError exception ,	raise AttributeError
10767	if AttributeError exception is raised ,	except AttributeError :
10768	raise TemplateSyntaxError ( STR0 , where STR1 is replaced with node .	raise TemplateSyntaxError ( STR0 % node )
10769	if nodelist is an instance of NodeList and node is not an instance of TextNode class .	if isinstance ( nodelist , NodeList ) and not isinstance ( node , TextNode ) :
10770	nodelist.contains_nontext is boolean True .	nodelist . contains_nontext = True
10771	append node to nodelist .	nodelist . append ( node )
10772	define the method enter_command with 3 arguments : self , command and token .	def enter_command ( self , command , token ) :
10773	do nothing .	pass
10774	define the method exit_command with an argument self .	def exit_command ( self ) :
10775	do nothing .	pass
10776	define the method enter_command with 3 arguments : self , token and msg .	def error ( self , token , msg ) :
10777	return an instance of TemplateSyntaxError class with an argument msg .	return TemplateSyntaxError ( msg )
10778	define the method empty_variable with 2 arguments : self and token .	def empty_variable ( self , token ) :
10779	call the method self.error with 2 arguments : token and string STR0 , return the result .	raise self . error ( token , STR0 )
10780	define the method empty_block_tag with 2 arguments : self and token .	def empty_block_tag ( self , token ) :
10781	call the method self.error with 2 arguments : token and string STR0 , return the result .	raise self . error ( token , STR0 )
10782	define the method invalid_block_tag with 4 arguments : self , token , command and parse_until as None .	def invalid_block_tag ( self , token , command , parse_until = None ) :
10783	if parse_until is true ,	if parse_until :
10784	raise an self.error exception with 2 arguments : token and string STR0 , where STR1 is replaced with command and result of the function get_text_list called with an argument list , with p converted into a string and surrounded with single quotes for every p in parse_until .	raise self . error ( token , STR0 % ( command , get_text_list ( [ STR1 % p for p in parse_until ] ) ) )
10785	call the method self.error with 2 arguments : token and string STR0 , where STR1 is replaced with command , return the result .	raise self . error ( token , STR0 % command )
10786	define the method unclosed_block_tag with 2 arguments : self and parse_until .	def unclosed_block_tag ( self , parse_until ) :
10787	raise an self.error with 2 arguments : None and string STR0 , where STR1 is replaced with parse_until elements joined into a string , separated with STR2 .	raise self . error ( None , STR0 % STR1 . join ( parse_until ) )
10788	define the method compile_filter_error with 3 arguments : self , token and e .	def compile_filter_error ( self , token , e ) :
10789	do nothing .	pass
10790	define the method compile_function_error with 3 arguments : self , token and e .	def compile_function_error ( self , token , e ) :
10791	do nothing .	pass
10792	define the method next_token with an argument self .	def next_token ( self ) :
10793	remove first element from self.tokens , return removed element .	return self . tokens . pop ( 0 )
10794	define the function prepend_token with 2 arguments : self and token .	def prepend_token ( self , token ) :
10795	insert token at the beginning of self.tokens .	self . tokens . insert ( 0 , token )
10796	define the method delete_first_token with an argument self .	def delete_first_token ( self ) :
10797	delete the first element of self.tokens .	del self . tokens [ 0 ]
10798	define the function add_library with 2 arguments : self and lib .	def add_library ( self , lib ) :
10799	update self.tags dictionary with lib.tags .	self . tags . update ( lib . tags )
10800	update self.filters dictionary with lib.filters .	self . filters . update ( lib . filters )
10801	define the function compile_filter with 2 arguments : self and token .	def compile_filter ( self , token ) :
10802	return an instance of FilterExpression class , created with 2 arguments : token and self .	return FilterExpression ( token , self )
10803	define the function find_filter with 2 arguments : self and filter_name .	def find_filter ( self , filter_name ) :
10804	if filter_name is contained in self.filters ,	if filter_name in self . filters :
10805	return the value under the filter_name key of the self.filters dictionary .	return self . filters [ filter_name ]
10806	if not ,	else :
10807	raise an TemplateSyntaxError with an argument string STR0 , substitute STR1 with filter_name .	raise TemplateSyntaxError ( STR0 % filter_name )
10808	derive the class TokenParser form the base class object .	class TokenParser ( object ) :
10809	define the function next_space_index with 2 arguments : self and subject .	def __init__ ( self , subject ) :
10810	substitute subject for self.subject .	self . subject = subject
10811	self.pointer is integer 0 .	self . pointer = 0
10812	self.backout is an empty list .	self . backout = [ ]
10813	call the method self.tag , substitute the result for self.tagname .	self . tagname = self . tag ( )
10814	define the method top with an argument self .	def top ( self ) :
10815	raise an NotImplementedError with an argument string STR0 .	raise NotImplementedError ( STR0 )
10816	define the method more with an argument self .	def more ( self ) :
10817	if self.pointer is smaller than length of self.subject , return boolean True , otherwise return False .	return self . pointer < len ( self . subject )
10818	define the method back with an argument self .	def back ( self ) :
10819	if length of self.backout is greater than zero ,	if not len ( self . backout ) :
10820	raise an TemplateSyntaxError exception with an argument string STR0 .	raise TemplateSyntaxError ( STR0 )
10821	remove the first element from self.backout , substitute the result for self.pointer .	self . pointer = self . backout . pop ( )
10822	define the method tag with an argument self .	def tag ( self ) :
10823	substitute self.subject for subject .	subject = self . subject
10824	substitute self.pointer for i .	i = self . pointer
10825	if i is greater than or equal to length of subject .	if i >= len ( subject ) :
10826	raise an TemplateSyntaxError exception with an argument string STR0 , where STR1 is replaced with subject .	raise TemplateSyntaxError ( STR0 % subject )
10827	substitute i for p .	p = i
10828	while i is lesser than length of subject and i-th element of subject is not an empty space or tab character ,	while i < len ( subject ) and subject [ i ] not in ( STR , STR0 ) :
10829	increment i by integer 1 .	i += 1
10830	take subject elements from p-th to i-th index , substitute it for s .	s = subject [ p : i ]
10831	while i is lesser than length of subject and i-th element of subject is an empty space or tab character ,	while i < len ( subject ) and subject [ i ] in ( STR , STR0 ) :
10832	increment i by integer 1 .	i += 1
10833	append self.pointer to self.backout .	self . backout . append ( self . pointer )
10834	substitute i for self.pointer .	self . pointer = i
10835	return s .	return s
10836	define the method value with an argument self .	def value ( self ) :
10837	substitute self.subject for subject .	subject = self . subject
10838	substitute self.pointer for i .	i = self . pointer
10839	define the next_space_index with 2 arguments : subject and i .	def next_space_index ( subject , i ) :
10840	while i is lesser than length of subject and i-th element of subject is not an empty space or tab character ,	while i < len ( subject ) and subject [ i ] not in ( STR , STR0 ) :
10841	if i-th element of subject is STR character or STR character ,	if subject [ i ] in ( STR , STR ) :
10842	substitute i-th element of subject for c .	c = subject [ i ]
10843	increment i by integer 1 .	i += 1
10844	while i is lesser than length of subject and i-th element of subject is not equal to c ,	while i < len ( subject ) and subject [ i ] != c :
10845	increment i by one .	i += 1
10846	if i is greater than , or equal to subject ,	if i >= len ( subject ) :
10847	raise an TemplateSyntaxError exception with an argument string STR0 , where STR1 is replaced with i and STR2 is replaced with subject .	raise TemplateSyntaxError ( STR0 % ( i , subject ) )
10848	increment i by one .	i += 1
10849	return i .	return i
10850	if i is greater than or equal to length of subject ,	if i >= len ( subject ) :
10851	raise an TemplateSyntaxError exception with an argument STR0 , where STR1 is replaced with subject .	raise TemplateSyntaxError ( STR0 % subject )
10852	if i-th element of subject is STR character or STR character ,	if subject [ i ] in ( STR , STR ) :
10853	substitute i for p .	p = i
10854	increment i by integer 1 ,	i += 1
10855	while i is lesser than length of subject and i-th element of subject is not equal to p-th element of subject ,	while i < len ( subject ) and subject [ i ] != subject [ p ] :
10856	increment i by integer 1 ,	i += 1
10857	if i is greater than length of subject ,	if i >= len ( subject ) :
10858	raise an TemplateSyntaxError exception with an argument string STR0 , where STR1 is replaced with i and STR2 is replaced with subject .	raise TemplateSyntaxError ( STR0 % ( i , subject ) )
10859	increment i by integer 1 ,	i += 1
10860	call the function next_space_index with 2 arguments : subject and i , substitute the result for i .	i = next_space_index ( subject , i )
10861	substitute subject elements from p-th to i-th index for res .	res = subject [ p : i ]
10862	while i is lesser than length of subject and i-th element of subject is an empty space or tab character .	while i < len ( subject ) and subject [ i ] in ( STR , STR0 ) :
10863	increment i by integer 1 ,	i += 1
10864	append self.pointer to self.backout .	self . backout . append ( self . pointer )
10865	substitute i for self.pointer .	self . pointer = i
10866	return res .	return res
10867	if not ,	else :
10868	substitute i for p .	p = i
10869	call the function next_space_index with 2 arguments subject and i , substitute the result for i .	i = next_space_index ( subject , i )
10870	take subject elements from p-th to i-th index , substitute it for s .	s = subject [ p : i ]
10871	while i is lesser than length of subject and i-th element of subject is an empty space or tab character .	while i < len ( subject ) and subject [ i ] in ( STR , STR0 ) :
10872	increment i by integer 1 , .	i += 1
10873	append self.pointer to self.backout .	self . backout . append ( self . pointer )
10874	substitute i for self.pointer .	self . pointer = i
10875	return s .	return s
10876	constant_string is a raw string STR0 , where STR4 is replaced with STR5 , STR6 is replaced with STR3 , STR7 is replaced with return value of function re.escape called with an argument string STR8 , STR9 is replaced with return value of function re.escape called with an argument string STR10 .	constant_string = STR0 % { STR6 : STR7 , STR8 : STR3 , STR9 : re . escape ( STR4 ) , STR10 : re . escape ( STR5 ) , }
10877	remove all occurrences of newline character from constant_string .	constant_string = constant_string . replace ( STR0 , STR )
10878	filter_raw_string is a raw string STR0 , where STR2 is replaced with constant_string , STR3 with raw string STR4 , STR5 with string STR1 , STR6 with result of the function re.escape called with an argument FILTER_SEPARATOR , anbd STR7 with result of the function re.escape called with an argument FILTER_ARGUMENT_SEPARATOR .	filter_raw_string = STR0 % { STR2 : constant_string , STR3 : STR4 , STR5 : STR1 , STR6 : re . escape ( FILTER_SEPARATOR ) , STR7 : re . escape ( FILTER_ARGUMENT_SEPARATOR ) , }
10879	call the function re.compile with 2 arguments : filter_raw_string and result for bitwise OR on 2 operands re.UNICODE and re.VERBOSE , substitute the result for filter_re .	filter_re = re . compile ( filter_raw_string , re . UNICODE | re . VERBOSE )
10880	derive the class FilterExpression form the base class object .	class FilterExpression ( object ) :
10881	define the function __init__ with 3 arguments : self , token and parser .	def __init__ ( self , token , parser ) :
10882	substitute token for self.token .	self . token = token
10883	call the method filter_re.finditer with an argument token , substitute the result for matches .	matches = filter_re . finditer ( token )
10884	var_obj is None .	var_obj = None
10885	filters is an empty list .	filters = [ ]
10886	upto is integer 0 .	upto = 0
10887	for every match in matches ,	for match in matches :
10888	call the method match.start , substitute the result for start .	start = match . start ( )
10889	if upto is not equal to start .	if upto != start :
10890	raise an TemplateSyntaxError exception with an argument string STR0 , where STR1 is replaced with first upto elements of token string , token string elements from upto to start index , and token string elements from start index to the end .	raise TemplateSyntaxError ( STR0 % ( token [ : upto ] , token [ upto : start ] , token [ start : ] ) )
10891	if var_obj is None ,	if var_obj is None :
10892	call the method match.group with 2 arguments : strings STR0 and STR1 , substitute the result for var and constant , respectively .	var , constant = match . group ( STR0 , STR1 )
10893	if constant is true ,	if constant :
10894	try ,	try :
10895	instantiate Variable class , with an argument constant , call the resolve method with an empty dictionary as an argument , substitute the result for var_obj .	var_obj = Variable ( constant ) . resolve ( { } )
10896	if VariableDoesNotExist exception is not caught ,	except VariableDoesNotExist :
10897	var_obj is None .	var_obj = None
10898	otherwise if var is None ,	elif var is None :
10899	raise an TemplateSyntaxError exception with an argument STR0 , replace STR1 with token .	raise TemplateSyntaxError ( STR0 % token )
10900	if not ,	else :
10901	var_obj is an instance of Variable class , created with an argument var .	var_obj = Variable ( var )
10902	if not ,	else :
10903	call the methof match.group with an argument STR0 , substitute the result for filter_name .	filter_name = match . group ( STR0 )
10904	args is an empty list .	args = [ ]
10905	call the method match.group with 2 arguments : strings STR0 and STR1 , substitute the result for constant_arg , and var_arg , respectively .	constant_arg , var_arg = match . group ( STR0 , STR1 )
10906	if constant_arg is true ,	if constant_arg :
10907	take a tuple with 2 elements : boolean False and method resolve called with an empty dictionary on the instance of Variable class , created with an argument constant_arg , append it to args .	args . append ( ( False , Variable ( constant_arg ) . resolve ( { } ) ) )
10908	otherwise if var_arg is true ,	elif var_arg :
10909	take a tuple with 2 elements : boolean False and instance of Variable class , created with an argument constant_arg , append it to args .	args . append ( ( True , Variable ( var_arg ) ) )
10910	call the method parser.find_filter with an argument filter_name , substitute the result for filter_func .	filter_func = parser . find_filter ( filter_name )
10911	call the method self.args_check with 3 arguments : filter_name , filter_func and args .	self . args_check ( filter_name , filter_func , args )
10912	append a tuple with 2 arguments : filter_func and args to filters .	filters . append ( ( filter_func , args ) )
10913	call the method match.end , substitute the result for upto .	upto = match . end ( )
10914	if upto is not equal to length of token ,	if upto != len ( token ) :
10915	raise an TemplateSyntaxError exception with an argument string STR0 , where STR1 is replaced with elemnts of token from upto index till the end , and token .	raise TemplateSyntaxError ( STR0 % ( token [ upto : ] , token ) )
10916	substitute filters for self.filters .	self . filters = filters
10917	substitute var_obj for self.var .	self . var = var_obj
10918	define the method resolve with 3 arguments : self , context and ignore_failures set to boolean False .	def resolve ( self , context , ignore_failures = False ) :
10919	if self.var is an instance of Variable class ,	if isinstance ( self . var , Variable ) :
10920	try ,	try :
10921	call the method self.var.resolve with an argument context , substitute it for obj .	obj = self . var . resolve ( context )
10922	if VariableDoesNotExist exception is caught ,	except VariableDoesNotExist :
10923	if ignore_failures is true ,	if ignore_failures :
10924	obj is None ,	obj = None
10925	if not ,	else :
10926	if settings.TEMPLATE_STRING_IF_INVALID is true ,	if settings . TEMPLATE_STRING_IF_INVALID :
10927	use global variable invalid_var_format_string .	global invalid_var_format_string
10928	if invalid_var_format_string is None ,	if invalid_var_format_string is None :
10929	if STR0 is contained in settings.TEMPLATE_STRING_IF_INVALID , invalid_var_format_string is boolean True , otherwise it is False .	invalid_var_format_string = STR0 in settings . TEMPLATE_STRING_IF_INVALID
10930	if invalid_var_format_string is true ,	if invalid_var_format_string :
10931	format settings.TEMPLATE_STRING_IF_INVALID with self.var , return the result .	return settings . TEMPLATE_STRING_IF_INVALID % self . var
10932	return settings.TEMPLATE_STRING_IF_INVALID .	return settings . TEMPLATE_STRING_IF_INVALID
10933	if not ,	else :
10934	substitute settings.TEMPLATE_STRING_IF_INVALID with obj .	obj = settings . TEMPLATE_STRING_IF_INVALID
10935	if not ,	else :
10936	substitute self.var for obj .	obj = self . var
10937	for every func and args in self.filters ,	for func , args in self . filters :
10938	arg_vals is an empty list ,	arg_vals = [ ]
10939	for every lookup and arg in args ,	for lookup , arg in args :
10940	if lookup is false ,	if not lookup :
10941	call the function mark_safe with an argument arg , append it to arg_vals .	arg_vals . append ( mark_safe ( arg ) )
10942	if not ,	else :
10943	call the method arg.resolve with an argument context , append the result to arg_vals .	arg_vals . append ( arg . resolve ( context ) )
10944	if STR0 attribute of func object exists and is true ,	if getattr ( func , STR0 , False ) :
10945	call the function template_localtime with 2 arguments : obj and context.use_tz , substitute the result for obj .	obj = template_localtime ( obj , context . use_tz )
10946	if STR0 attribute of func object exists and is true ,	if getattr ( func , STR0 , False ) :
10947	call the function func with 3 arguments : obj , autoescape set to context.autoescape and unpacked list arg_vals , substitute the result for new_obj .	new_obj = func ( obj , autoescape = context . autoescape , * arg_vals )
10948	if not ,	else :
10949	call the function func with 2 arguments : obj and unpacked list arg_vals , substitute the result for new_obj .	new_obj = func ( obj , * arg_vals )
10950	if STR0 attribute of func object exists and is true and obj is an instance of SafeData ,	if getattr ( func , STR0 , False ) and isinstance ( obj , SafeData ) :
10951	call the function mark_safe with an argument new_obj , substitute the result for obj .	obj = mark_safe ( new_obj )
10952	otherwise if obj is an instance of EscapeData ,	elif isinstance ( obj , EscapeData ) :
10953	call the function mark_for_escaping with an argument new_obj , substitute the result for obj .	obj = mark_for_escaping ( new_obj )
10954	if not ,	else :
10955	substitute new_obj for obj .	obj = new_obj
10956	return obj .	return obj
10957	define the method args_check with 3 arguments : name , func and provided .	def args_check ( name , func , provided ) :
10958	convert provided into a list and substitute it for provided .	provided = list ( provided )
10959	calculate length of provided and increment it by one , substitute the result for plen .	plen = len ( provided ) + 1
10960	get the STR0 attribute from func object , if it exists substitute it for func .	func = getattr ( func , STR0 , func )
10961	call the function getargspec with an argument func , substitute the result for args , varargs , varkw and defaults , respectively .	args , varargs , varkw , defaults = getargspec ( func )
10962	calculate the length of args , substitute it for alen .	alen = len ( args )
10963	substitute the length of defaults for dlen .	dlen = len ( defaults or [ ] )
10964	if plen is lesser than difference of alen and dlen , or if plen is greater than alen ,	if plen < ( alen - dlen ) or plen > alen :
10965	raise an TemplateSyntaxError exception with an argument string STR0 , where STR1 is replaced with name , dlen subtracted from alen , and plen .	raise TemplateSyntaxError ( STR0 % ( name , alen - dlen , plen ) )
10966	return boolean True .	return True
10967	args_check is a static method .	args_check = staticmethod ( args_check )
10968	define the method __str__ with an argument self .	def __str__ ( self ) :
10969	return self.token .	return self . token
10970	define the method resolve_variable with 2 arguments : path and context .	def resolve_variable ( path , context ) :
10971	call the function warnings.warn with 3 arguments : string STR0 , RemovedInDjango20Warning , and stacklevel set to integer 2 .	warnings . warn ( STR0 , RemovedInDjango20Warning , stacklevel = 2 )
10972	call the method resolve with an argument context , from the instance of Variable class , created with an argument path .	return Variable ( path ) . resolve ( context )
10973	derive the class Variable form the base class object .	class Variable ( object ) :
10974	define the method __init__ with 2 arguments self and var .	def __init__ ( self , var ) :
10975	substitute var for self.var .	self . var = var
10976	self.literal is None ,	self . literal = None
10977	self.lookups is None .	self . lookups = None
10978	self.translate is boolean False .	self . translate = False
10979	self.message_context is None .	self . message_context = None
10980	if var is not an instance of six.string_types ,	if not isinstance ( var , six . string_types ) :
10981	raise an TypeError exception with an argument string STR0 , replace STR1 with type of var .	raise TypeError ( STR0 % type ( var ) )
10982	try ,	try :
10983	convert var into an floating point number , substitute it for self.literal .	self . literal = float ( var )
10984	if STR0 is not contained in var and STR1 is not contained in var converted into lowercase ,	if STR0 not in var and STR1 not in var . lower ( ) :
10985	convert self.literal into an integer , substitute it for self.literal .	self . literal = int ( self . literal )
10986	if var ends with STR0 ,	if var . endswith ( STR0 ) :
10987	raise an ValueError exception .	raise ValueError
10988	if ValueError exception is caught ,	except ValueError :
10989	if var starts with STR0 and var ends with STR1 ,	if var . startswith ( STR0 ) and var . endswith ( STR1 ) :
10990	self.translate is boolean True .	self . translate = True
10991	remove first 2 and last 2 elements from var .	var = var [ 2 : - 1 ]
10992	try ,	try :
10993	call the function unescape_string_literal with an argument var , use it as an argument for the call to the function mark_safe , substitute the result for self.literal .	self . literal = mark_safe ( unescape_string_literal ( var ) )
10994	if ValueError exception is caught ,	except ValueError :
10995	call the function var.find with an argument : STR0 appended to VARIABLE_ATTRIBUTE_SEPARATOR , if the result is greater than integer -1 ,	if var . find ( VARIABLE_ATTRIBUTE_SEPARATOR + STR0 ) > - 1 or var [ 0 ] == STR1 :
10996	or first element of var equals STR1 , raise an TemplateSyntaxError exception with an argument string STR0 , where STR2 is replaced with var .	raise TemplateSyntaxError ( STR0 % var )
10997	call the method var.split with an argument VARIABLE_ATTRIBUTE_SEPARATOR , convert the result to a tuple and substitute it for self.lookups .	self . lookups = tuple ( var . split ( VARIABLE_ATTRIBUTE_SEPARATOR ) )
10998	define the method resolve with 2 arguments : self and context .	def resolve ( self , context ) :
10999	if self.lookups is not None ,	if self . lookups is not None :
11000	call the function self._resolve_lookup with an argument context , substitute the result for value .	value = self . _resolve_lookup ( context )
11001	if else ,	else :
11002	substitute self.literal for value .	value = self . literal
11003	if self.translate is true ,	if self . translate :
11004	if self.message_context is true ,	if self . message_context :
11005	call the function pgettext_lazy with an argument self.message_context and value , return the result .	return pgettext_lazy ( self . message_context , value )
11006	if not ,	else :
11007	call the function ugettext_lazy with an argument value , return the result .	return ugettext_lazy ( value )
11008	return value .	return value
11009	define the method __repr__ with an argument self .	def __repr__ ( self ) :
11010	return an string STR0 , where STR1 is replaced with self.__class__.__name__ and self.var , respectively .	return STR0 % ( self . __class__ . __name__ , self . var )
11011	define the method __str__ with an argument self .	def __str__ ( self ) :
11012	return self.var .	return self . var
11013	define the method _resolve_lookup with 2 arguments : self and context .	def _resolve_lookup ( self , context ) :
11014	substitute context for current .	current = context
11015	try ,	try :
11016	for bit in self.lookups ,	for bit in self . lookups :
11017	try ,	try :
11018	substitute element at the bit index of current for current .	current = current [ bit ]
11019	if TypeError , AttributeError , KeyError or ValueError exceptions are caught ,	except ( TypeError , AttributeError , KeyError , ValueError ) :
11020	try ,	try :
11021	if current is an instance of BaseContext and bit attribute of type of current is true ,	if isinstance ( current , BaseContext ) and getattr ( type ( current ) , bit ) :
11022	raise an AttributeError exception .	raise AttributeError
11023	get the bit attribute of current object , substitute it for current .	current = getattr ( current , bit )
11024	if TypeError and AttributeError exceptions are caught ,	except ( TypeError , AttributeError ) :
11025	try ,	try :
11026	convert bit to an integer and use it as index to obtain an element for list current , substitute it for current .	current = current [ int ( bit ) ]
11027	if IndexError , ValueError , KeyError or TypeError exceptions are caught ,	except ( IndexError , ValueError , KeyError , TypeError ) :
11028	raise an VariableDoesNotExist exception with an argument string STR0 , where STR1 is replaced with bit and STR2 is replaced with current .	raise VariableDoesNotExist ( STR0 , ( bit , current ) )
11029	if current is callable object ,	if callable ( current ) :
11030	get the STR0 attribute of current object , if it exists and is true ,	if getattr ( current , STR0 , False ) :
11031	do nothing .	pass
11032	otherwise , get the STR0 attribute of current object , if it exists and is true ,	elif getattr ( current , STR0 , False ) :
11033	substitute settings.TEMPLATE_STRING_IF_INVALID for current .	current = settings . TEMPLATE_STRING_IF_INVALID
11034	if not ,	else :
11035	try ,	try :
11036	call the function current , substitute the result for current .	current = current ( )
11037	if TypeError exception is caught ,	except TypeError :
11038	try ,	try :
11039	call the function getcallargs with an argument current ,	getcallargs ( current )
11040	if TypeError exception is caught ,	except TypeError :
11041	substitute settings.TEMPLATE_STRING_IF_INVALID for current ,	current = settings . TEMPLATE_STRING_IF_INVALID
11042	if not ,	else :
11043	raise an exception ,	raise
11044	if Exception , renamed to e , exception is caught ,	except Exception as e :
11045	get the STR0 attribute of e object , if it exists and is true ,	if getattr ( e , STR0 , False ) :
11046	substitute settings.TEMPLATE_STRING_IF_INVALID for current .	current = settings . TEMPLATE_STRING_IF_INVALID
11047	if not ,	else :
11048	raise an exception .	raise
11049	return current .	return current
11050	derive the class Node form the base class object .	class Node ( object ) :
11051	must_be_first is boolean False .	must_be_first = False
11052	child_nodelists is an tuple with an element STR0 .	child_nodelists = ( STR0 , )
11053	define the method render with 2 arguments : self and context .	def render ( self , context ) :
11054	do nothing .	pass
11055	define the method __iter__ with an argument self .	def __iter__ ( self ) :
11056	yield self .	yield self
11057	define the method get_nodes_by_type with 2 arguments : self and nodetype .	def get_nodes_by_type ( self , nodetype ) :
11058	nodes is an empty list .	nodes = [ ]
11059	if self is an instance of nodetype ,	if isinstance ( self , nodetype ) :
11060	append self to nodes .	nodes . append ( self )
11061	for every attr in self.child_nodelists ,	for attr in self . child_nodelists :
11062	get attr attribute of self object , if it exists substitute it for nodelist , if not nodelist is None .	nodelist = getattr ( self , attr , None )
11063	if nodelist is true ,	if nodelist :
11064	call the method nodelist.get_nodes_by_type with an argument nodetype , extend nodes with the result .	nodes . extend ( nodelist . get_nodes_by_type ( nodetype ) )
11065	return nodes .	return nodes
11066	derive the class NodeList form the base class list .	class NodeList ( list ) :
11067	contains_nontext is boolean False .	contains_nontext = False
11068	define the method render with 2 arguments : self and context .	def render ( self , context ) :
11069	bits is an empty list .	bits = [ ]
11070	for every node in self ,	for node in self :
11071	if node is an instance of Node ,	if isinstance ( node , Node ) :
11072	call the method self.render_node with 2 arguments : node and context , substitute the result for bit .	bit = self . render_node ( node , context )
11073	if not ,	else :
11074	substitute node for bit .	bit = node
11075	call the function force_text with an argument bit , append the result to bits .	bits . append ( force_text ( bit ) )
11076	call the function mark_safe with an argument , elements of bits joined into a string , return the result .	return mark_safe ( STR . join ( bits ) )
11077	define the method get_nodes_by_type with 2 arguments : self and nodetype .	def get_nodes_by_type ( self , nodetype ) :
11078	modes is an empty list .	nodes = [ ]
11079	for every node in self ,	for node in self :
11080	call the method node.get_nodes_by_type with an argument nodetype , extend nodes with it .	nodes . extend ( node . get_nodes_by_type ( nodetype ) )
11081	return nodes .	return nodes
11082	define the method render_node with 3 arguments : self , node and context .	def render_node ( self , node , context ) :
11083	call the method node.render with an argument context , return the result .	return node . render ( context )
11084	derive the class TextNode form the base class Node .	class TextNode ( Node ) :
11085	define the method __init__ with 2 arguments : self and s .	def __init__ ( self , s ) :
11086	substitute s for self.s .	self . s = s
11087	define the method __repr__ with an argument self .	def __repr__ ( self ) :
11088	call the function force_str with 3 arguments : string STR0 , with STR1 replaced with first 25 elements of self.s string , string STR2 and errors set to a string STR3 , return the result .	return force_str ( STR0 % self . s [ : 25 ] , STR1 , errors = STR2 )
11089	define the method render with 2 arguments : self and context .	def render ( self , context ) :
11090	return self.s .	return self . s
11091	define the function render_value_in_context with 2 arguments : value and context .	def render_value_in_context ( value , context ) :
11092	call the method template_localtime with 2 arguments : value and use_tz=context.use_tz , substitute the result for value .	value = template_localtime ( value , use_tz = context . use_tz )
11093	call the function localize with 2 arguments : value and use_l10n=context.use_l10n , substitute the result for value .	value = localize ( value , use_l10n = context . use_l10n )
11094	call the function force_text with an argument value , substitute the result for value .	value = force_text ( value )
11095	if context.autoescape is true and value is not an instance of SafeData , or value is an instance of EscapeData ,	if ( ( context . autoescape and not isinstance ( value , SafeData ) ) or isinstance ( value , EscapeData ) ) :
11096	call the function escape with an argument value , return the result .	return escape ( value )
11097	if not ,	else :
11098	return value .	return value
11099	derive the class VariableNode form the base class Node .	class VariableNode ( Node ) :
11100	define the method __init__ with 2 arguments : self and filter_expression .	def __init__ ( self , filter_expression ) :
11101	substitute filter_expression for self.filter_expression .	self . filter_expression = filter_expression
11102	define the method __repr__ with an argument self .	def __repr__ ( self ) :
11103	return a string STR0 , substitute STR1 with self.filter_expression .	return STR0 % self . filter_expression
11104	define the method render with 2 arguments self and context .	def render ( self , context ) :
11105	try ,	try :
11106	call the method self.filter_expression.resolve with an argument context , substitute the result for output .	output = self . filter_expression . resolve ( context )
11107	if UnicodeDecodeError exception is caught ,	except UnicodeDecodeError :
11108	return an empty string .	return STR
11109	call the function render_value_in_context with 2 arguments output and context , return the result .	return render_value_in_context ( output , context )
11110	call the function re.compile with an argument raw string STR0 , substitute the result for kwarg_re .	kwarg_re = re . compile ( STR0 )
11111	define the method token_kwargs : bits , parser and support_legacy set to boolean False .	def token_kwargs ( bits , parser , support_legacy = False ) :
11112	if bits is false ,	if not bits :
11113	return an empty dictionary .	return { }
11114	call the method kwarg_re.match with an argument first element of bits , substitute the result for match .	match = kwarg_re . match ( bits [ 0 ] )
11115	if match is true and call to the method match.group with an argument integer 1 evaluates to true , kwarg_format is boolean True , otherwise it is boolean False .	kwarg_format = match and match . group ( 1 )
11116	if kwarg_format is false ,	if not kwarg_format :
11117	if support_legacy is false ,	if not support_legacy :
11118	return an empty dictionary .	return { }
11119	if length of bits is lesser than integer 3 or second element of bits is not equal to string STR0 ,	if len ( bits ) < 3 or bits [ 1 ] != STR0 :
11120	return an empty dictionary .	return { }
11121	kwargs is an empty dictionary ,	kwargs = { }
11122	while bits is true ,	while bits :
11123	if kwarg_format is true ,	if kwarg_format :
11124	call the method kwarg_re.match with an argument first element of bits , substitute the result for match .	match = kwarg_re . match ( bits [ 0 ] )
11125	if match is false or call to the method match.group with an argument integer 1 evaluates to boolean false ,	if not match or not match . group ( 1 ) :
11126	return kwargs .	return kwargs
11127	call the method match.groups with 2 arguments : key and value .	key , value = match . groups ( )
11128	delete first element of bits .	del bits [ : 1 ]
11129	if not ,	else :
11130	if length of bits is lesser than integer 3 or second element of bits is not equal to string STR0 ,	if len ( bits ) < 3 or bits [ 1 ] != STR0 :
11131	return kwargs .	return kwargs
11132	substitute third and first element of bits for key and value , respectively .	key , value = bits [ 2 ] , bits [ 0 ]
11133	delete first 3 elements of bits .	del bits [ : 3 ]
11134	call the method parser.compile_filter with an argument value , substitute the result for value under the key key of kwargs dictionary .	kwargs [ key ] = parser . compile_filter ( value )
11135	if bits is true and kwarg_format is false ,	if bits and not kwarg_format :
11136	if first element of bits is not equal to string STR0 ,	if bits [ 0 ] != STR0 :
11137	return kwargs .	return kwargs
11138	delete first element of bits .	del bits [ : 1 ]
11139	return kwargs .	return kwargs
11140	define the function parse_bits with 8 arguments : parser , bits , params , varargs , varkw , defaults , takes_context and name .	def parse_bits ( parser , bits , params , varargs , varkw , defaults , takes_context , name ) :
11141	if takes_context is true ,	if takes_context :
11142	if first element of params equals a string STR0 ,	if params [ 0 ] == STR0 :
11143	substitute params without the first element for params .	params = params [ 1 : ]
11144	if not ,	else :
11145	raise an TemplateSyntaxError exception STR0 , where STR1 is replaced with name .	raise TemplateSyntaxError ( STR0 % name )
11146	args is an empty list .	args = [ ]
11147	kwargs is an empty dictionary .	kwargs = { }
11148	convert params into a list , substitute it for unhandled_params .	unhandled_params = list ( params )
11149	for every bit in bits ,	for bit in bits :
11150	call the function	kwarg = token_kwargs ( [ bit ] , parser )
11151	if kwarg is true ,	if kwarg :
11152	call the method six.iteritems with an argument kwarg , convert the result into a list , substitute first element of the result for param and value .	param , value = list ( six . iteritems ( kwarg ) ) [ 0 ]
11153	if param is not in params and varkw is None ,	if param not in params and varkw is None :
11154	raise an TemplateSyntaxError exception with an argument STR0 , where STR1 are replaced with name and param .	raise TemplateSyntaxError ( STR0 % ( name , param ) )
11155	otherwise if param is contained in kwargs ,	elif param in kwargs :
11156	raise an TemplateSyntaxError exception with an argument string STR0 , where STR1 are replaced with name and param .	raise TemplateSyntaxError ( STR0 % ( name , param ) )
11157	if not ,	else :
11158	convert param to a string , use it as a key to get the value from kwargs dictionary , assign it value .	kwargs [ str ( param ) ] = value
11159	if param is contained in unhandled_params ,	if param in unhandled_params :
11160	call the method unhandled_params.remove with an argument param .	unhandled_params . remove ( param )
11161	if not ,	else :
11162	if kwargs is true ,	if kwargs :
11163	raise an TemplateSyntaxError exception with an argument string STR0 , where STR1 is replaced with name .	raise TemplateSyntaxError ( STR0 % name )
11164	if not ,	else :
11165	call the method parser.compile_filter with an argument bit , append the result to args .	args . append ( parser . compile_filter ( bit ) )
11166	try ,	try :
11167	remove first element of unhandled_params .	unhandled_params . pop ( 0 )
11168	if IndexError exception is caught ,	except IndexError :
11169	if varargs is None ,	if varargs is None :
11170	raise an TemplateSyntaxError exception with an argument string STR0 , where STR1 is replaced with name .	raise TemplateSyntaxError ( STR0 % name )
11171	if defaults is not None ,	if defaults is not None :
11172	slice list unhandled_params from the beginning to the length of defaults last element ,	unhandled_params = unhandled_params [ : - len ( defaults ) ]
11173	if unhandled_params is true ,	if unhandled_params :
11174	raise TemplateSyntaxError (	raise TemplateSyntaxError ( STR0 % ( name , STR1 . join ( STR2 % p for p in unhandled_params ) ) )
11175	return args and kwargs .	return args , kwargs
11176	define the method generic_tag_compiler with 9 arguments : parser , token , params , varargs , varkw , defaults , name , takes_context ,	def generic_tag_compiler ( parser , token , params , varargs , varkw , defaults , name , takes_context , node_class ) :
11177	call the function token.split_contents , substitute the result without the first element for bits .	bits = token . split_contents ( ) [ 1 : ]
11178	call the method parse_bits with 8 arguments : parser , bits , params , varargs , varkw , defaults , takes_context and name , substitute the result for args and kwargs , respectively .	args , kwargs = parse_bits ( parser , bits , params , varargs , varkw , defaults , takes_context , name )
11179	call the function node_class with 3 arguments : takes_context , args and kwargs .	return node_class ( takes_context , args , kwargs )
11180	derive the class TagHelperNode form the base class Node .	class TagHelperNode ( Node ) :
11181	define the method __init__ with 4 arguments : self , takes_context , args and kwargs .	def __init__ ( self , takes_context , args , kwargs ) :
11182	substitute takes_context for self.takes_context .	self . takes_context = takes_context
11183	substitute args for self.args .	self . args = args
11184	substitute kwargs for self.kwargs .	self . kwargs = kwargs
11185	define the method get_resolved_arguments with 2 arguments : self and context .	def get_resolved_arguments ( self , context ) :
11186	resolved_args is an list with elements , return value of the method var.resolve with an argument context , for every var in self.args .	resolved_args = [ var . resolve ( context ) for var in self . args ]
11187	if self.takes_context is true ,	if self . takes_context :
11188	append resolved_args to a list containing context element , substitute it for resolved_args .	resolved_args = [ context ] + resolved_args
11189	resolved_kwargs is dictionary with elements : return value of the method v.resolve called with an argument context , for k , for every k and v in return value of the method self.kwargs.items .	resolved_kwargs = dict ( ( k , v . resolve ( context ) ) for k , v in self . kwargs . items ( ) )
11190	return resolved_args and resolved_kwargs .	return resolved_args , resolved_kwargs
11191	derive the class Library form the base class object .	class Library ( object ) :
11192	define the method with reload with an argument self .	def __init__ ( self ) :
11193	self.filters is an empty dictionary .	self . filters = { }
11194	self.tags is an empty dictionary .	self . tags = { }
11195	define the method tag with 3 arguments : self , name set to None and compile_function set to None .	def tag ( self , name = None , compile_function = None ) :
11196	if name is None and compile_function is None ,	if name is None and compile_function is None :
11197	return self.tag_function .	return self . tag_function
11198	otherwise if name is not None and compile_function is None ,	elif name is not None and compile_function is None :
11199	if name is callable object ,	if callable ( name ) :
11200	call the method self.tag_function with an argument name , return the result .	return self . tag_function ( name )
11201	if not ,	else :
11202	define the function dec with an argument func ,	def dec ( func ) :
11203	call the method self.tag with 2 arguments name and func , return the result .	return self . tag ( name , func )
11204	return dec .	return dec
11205	otherwise if name is not None and compile_function is not None ,	elif name is not None and compile_function is not None :
11206	substitute compile_function for self.tags dictionary value under the name key .	self . tags [ name ] = compile_function
11207	return compile_function .	return compile_function
11208	if not ,	else :
11209	raise an InvalidTemplateLibrary exception with an argument string STR0 , substitute STR1 with name and compile_function .	raise InvalidTemplateLibrary ( STR0 , ( name , compile_function ) )
11210	define the method tag_function with 2 argument : self and func .	def tag_function ( self , func ) :
11211	get STR0 attribute from func , return func if the attribute doesnt exists , use its __name__ field as a key to get the value from self.tags , assign func to it .	self . tags [ getattr ( func , STR0 , func ) . __name__ ] = func
11212	return func .	return func
11213	define the method filter with 4 arguments : self , name set to None , filter_func set to None and unpacked dictionary flags .	def filter ( self , name = None , filter_func = None , ** flags ) :
11214	if name is None and filter_func is None ,	if name is None and filter_func is None :
11215	define the function dec with an argument func ,	def dec ( func ) :
11216	call the method self.filter_function with 2 arguments func and unpacked dictionary flags , return the result .	return self . filter_function ( func , ** flags )
11217	return dec .	return dec
11218	otherwise if name is not None and filter_func is None ,	elif name is not None and filter_func is None :
11219	if name is callable object ,	if callable ( name ) :
11220	call the method self.filter_function with arguments name and unpacked dictionary flags , return the result .	return self . filter_function ( name , ** flags )
11221	if not ,	else :
11222	define the function dec with an argument func ,	def dec ( func ) :
11223	call the method self.filter with 3 arguments : name , func and unpacked dictionary flags , return the result .	return self . filter ( name , func , ** flags )
11224	return dec .	return dec
11225	otherwise if name is not None and filter_func is not None ,	elif name is not None and filter_func is not None :
11226	substitute filter_func for value under the name key of self.filters dictionary .	self . filters [ name ] = filter_func
11227	for every attr in tuple with 3 arguments : strings STR0 , STR1 and STR2 ,	for attr in ( STR0 , STR1 , STR2 ) :
11228	if attr is contained in flags ,	if attr in flags :
11229	substitute value under the attr key of flags dictionary for value .	value = flags [ attr ]
11230	set filter_func objec attr attribute to value .	setattr ( filter_func , attr , value )
11231	if filter_func has an attribute STR0 ,	if hasattr ( filter_func , STR0 ) :
11232	set filter_func._decorated_function objects attr attribute to value .	setattr ( filter_func . _decorated_function , attr , value )
11233	substitute name for filter_func._filter_name .	filter_func . _filter_name = name
11234	return filter_func .	return filter_func
11235	if not ,	else :
11236	raise an InvalidTemplateLibrary exception with an argument string ( STR0 , where STR1 is replaced with name and filter_func , respectively .	raise InvalidTemplateLibrary ( STR0 , ( name , filter_func ) )
11237	define the method filter_function with 3 arguments : self , func and unpacked dictionary flags .	def filter_function ( self , func , ** flags ) :
11238	get STR0 attribute from func object , if it exists substitute __name__ field of the result for name , if not , substitute func.__name__ for name .	name = getattr ( func , STR0 , func ) . __name__
11239	call the method self.filter with 3 arguments : name , func and unpacked dictionary flags .	return self . filter ( name , func , ** flags )
11240	define the method simple_tag with 4 arguments : self , func and None , takes_context and None and name set to None .	def simple_tag ( self , func = None , takes_context = None , name = None ) :
11241	define the function dec with an argument func .	def dec ( func ) :
11242	call the function getargspec with an argument func , substitute the result for params , varargs , varkw and defaults , respectively .	params , varargs , varkw , defaults = getargspec ( func )
11243	derive the class SimpleNode form the base class TagHelperNode .	class SimpleNode ( TagHelperNode ) :
11244	define the method render with 2 arguments self and context .	def render ( self , context ) :
11245	call the method self.get_resolved_arguments with an argument context , substitute the result for resolved_args and resolved_kwargs .	resolved_args , resolved_kwargs = self . get_resolved_arguments ( context )
11246	call the function func with 2 arguments : unpacked list resolved_args and unpacked dictionary resolved_kwargs , return it .	return func ( * resolved_args , ** resolved_kwargs )
11247	if name is true , substitute it for function_name , if not get attribute STR0 from func object , substitute its __name__ field for function name , if it doesnt exists substitute func.__name__ for function_name .	function_name = ( name or getattr ( func , STR0 , func ) . __name__ )
11248	call the function generic_tag_compiler , params set to params , varargs set to varargs , varkw set to varkw , defaults set to defaults , name set to function_name , and takes_context set to takes_context and node_class set to SimpleNode .	compile_func = partial ( generic_tag_compiler , params = params , varargs = varargs , varkw = varkw , defaults = defaults , name = function_name , takes_context = takes_context , node_class = SimpleNode )
11249	substitute func.__doc__ for compile_func.__doc__ .	compile_func . __doc__ = func . __doc__
11250	call the method self.tag with 2 arguments : function_name and compile_func .	self . tag ( function_name , compile_func )
11251	return func .	return func
11252	if func is None ,	if func is None :
11253	return dec .	return dec
11254	otherwise if func is callable object ,	elif callable ( func ) :
11255	call the function dec with an argument func , return the result .	return dec ( func )
11256	if not ,	else :
11257	raise an TemplateSyntaxError exception with an argument string STR0 .	raise TemplateSyntaxError ( STR0 )
11258	define the method assignment_tag with 4 arguments : self , func set to None , takes_context set to None and name set to None .	def assignment_tag ( self , func = None , takes_context = None , name = None ) :
11259	define the function dec with an argument func .	def dec ( func ) :
11260	call the function getargspec with an argument func , substitute the result for params , varargs , varkw and defaults .	params , varargs , varkw , defaults = getargspec ( func )
11261	derive the class AssignmentNode form the base class TagHelperNode .	class AssignmentNode ( TagHelperNode ) :
11262	define the function __init__ with 5 arguments : self , takes_context , args , kwargs and target_var .	def __init__ ( self , takes_context , args , kwargs , target_var ) :
11263	call the method __init__ from the base class of the class AssignmentNode , with 3 arguments : takes_context , args and kwargs .	super ( AssignmentNode , self ) . __init__ ( takes_context , args , kwargs )
11264	substitute target_var for self.target_var .	self . target_var = target_var
11265	define the method render with 2 arguments self and context .	def render ( self , context ) :
11266	call the method self.get_resolved_arguments with an argument context , substitute the result for resolved_args and resolved_kwargs .	resolved_args , resolved_kwargs = self . get_resolved_arguments ( context )
11267	call the function func with 2 arguments : unpacked list resolved_args and unpacked dictionary resolved_kwargs , substitute the result for value under the self.target_var key of the context dictionary .	context [ self . target_var ] = func ( * resolved_args , ** resolved_kwargs )
11268	return an empty string .	return STR
11269	if name is true , substitute it for function_name , if not get STR0 attribute from func object , if it exists , substitute __name__ field of the result for function_name , in not , substitute func.__name__ for function_name .	function_name = ( name or getattr ( func , STR0 , func ) . __name__ )
11270	define the function compile_func with 2 arguments : parser and token .	def compile_func ( parser , token ) :
11271	call the function token.split_contents , substitute the result without the first element for bits .	bits = token . split_contents ( ) [ 1 : ]
11272	if length of bits is smaller than integer 2 or second last element of bits is not equal to STR0 ,	if len ( bits ) < 2 or bits [ - 2 ] != STR0 :
11273	raise an TemplateSyntaxError exception with an argument string , STR0 , where STR1 is replaced with function_name .	raise TemplateSyntaxError ( STR0 % function_name )
11274	substitute last element of bits for target_var .	target_var = bits [ - 1 ]
11275	substitute bits without last two elements for bits .	bits = bits [ : - 2 ]
11276	call the function parse_bits with 8 arguments : parser , bits , params , varargs , varkw , defaults , takes_context and function_name , substitute the result for args and kwargs .	args , kwargs = parse_bits ( parser , bits , params , varargs , varkw , defaults , takes_context , function_name )
11277	return an instance of AssignmentNode class created with 4 arguments : takes_context , args , kwargs and target_var .	return AssignmentNode ( takes_context , args , kwargs , target_var )
11278	substitute func.__doc__ for compile_func.__doc__ .	compile_func . __doc__ = func . __doc__
11279	call the method self.tag with 2 arguments : function_name and compile_func .	self . tag ( function_name , compile_func )
11280	return func .	return func
11281	if func is None ,	if func is None :
11282	return dec .	return dec
11283	otherwise if func is callable ,	elif callable ( func ) :
11284	call the function dec with an argument func , return the result .	return dec ( func )
11285	if not ,	else :
11286	raise an TemplateSyntaxError exception with an argument string STR0 .	raise TemplateSyntaxError ( STR0 )
11287	define the method inclusion_tag with 5 arguments : self , file_name , context_class set to Context , takes_context set to boolean False , and name set to None .	def inclusion_tag ( self , file_name , context_class = Context , takes_context = False , name = None ) :
11288	define the function dec with an argument func .	def dec ( func ) :
11289	call the function getargspec with an argument func , substitute the result for params , varargs , varkw and defaults .	params , varargs , varkw , defaults = getargspec ( func )
11290	derive the class InclusionNode form the base class TagHelperNode .	class InclusionNode ( TagHelperNode ) :
11291	define the method render with 2 arguments : self and context .	def render ( self , context ) :
11292	call the method self.get_resolved_arguments with context as an argument , substitute the result for resolved_args and resolved_kwargs .	resolved_args , resolved_kwargs = self . get_resolved_arguments ( context )
11293	call the function func with 2 arguments : unpacked list resolved_args and unpacked dictionary resolved_kwargs , substitute the result for _dict .	_dict = func ( * resolved_args , ** resolved_kwargs )
11294	get STR0 attribute from self object . if it doesnt exists return boolean False , if the result evaluates to false ,	if not getattr ( self , STR0 , False ) :
11295	from django.template.loader import get_template , select_template .	from django . template . loader import get_template , select_template
11296	if file_name is an instance of Template class .	if isinstance ( file_name , Template ) :
11297	substitute file_name for t .	t = file_name
11298	otherwise if file_name is not an instance of six.string_types and call to the function is_iterable with an argument file_name ,	elif not isinstance ( file_name , six . string_types ) and is_iterable ( file_name ) :
11299	evaluates to true , call the function select_template with an argument file_name , substitute the result for t .	t = select_template ( file_name )
11300	if not ,	else :
11301	call the function get_template with an argument file_name , substitute the result for t .	t = get_template ( file_name )
11302	substitute t.nodelist for self.nodelist .	self . nodelist = t . nodelist
11303	call the function context_class with 2 arguments : _dict and unpacked dictionary containing 4 entries : context.autoescape for STR0 , context.autoescape for STR1 , context.use_l10n for STR2 , and context.use_tz for STR3 , substitute the result for new_context .	new_context = context_class ( _dict , ** { STR0 : context . autoescape , STR1 : context . current_app , STR2 : context . use_l10n , STR3 : context . use_tz , } )
11304	call the function context.get with 2 argument STR0 and None , substitute the result for csrf_token .	csrf_token = context . get ( STR0 , None )
11305	if csrf_token is not None ,	if csrf_token is not None :
11306	substitute csrf_token for value under the STR0 key of new_context dictionary .	new_context [ STR0 ] = csrf_token
11307	call the method self.nodelist.render with an argument new_context , return the result .	return self . nodelist . render ( new_context )
11308	if name is true , substitute it for function_name , if not get STR0 attribute from func object , if it exists , substitute __name__ field of the result for function_name , in not , substitute func.__name__ for function_name .	function_name = ( name or getattr ( func , STR0 , func ) . __name__ )
11309	call the function partial with 8 arguments : generic_tag_compiler , params set to params , varargs set to varargs , varkw set to varkw , defaults set to defaults , name set to function_name , takes_context set to takes_context and node_class set to InclusionNode , substitute the result for compile_func .	compile_func = partial ( generic_tag_compiler , params = params , varargs = varargs , varkw = varkw , defaults = defaults , name = function_name , takes_context = takes_context , node_class = InclusionNode )
11310	substitute func.__doc__ for compile_func.__doc__ .	compile_func . __doc__ = func . __doc__
11311	call the function self.tag with 2 arguments : function_name and compile_func .	self . tag ( function_name , compile_func )
11312	return func .	return func
11313	return dec .	return dec
11314	define the function is_library_missing with an argument name .	def is_library_missing ( name ) :
11315	split string name into two parts from the right side by the separator STR0 , substitute parts for path and module , respectively .	path , module = name . rsplit ( STR0 , 1 )
11316	try ,	try :
11317	call the function import_module with an argument path , substitute it for package .	package = import_module ( path )
11318	call the function module_has_submodule with 2 arguments : package and module , return inverted boolean result .	return not module_has_submodule ( package , module )
11319	if ImportError exception is caught ,	except ImportError :
11320	call the function is_library_missing with an argument path , return the result .	return is_library_missing ( path )
11321	define the function import_library with an argument taglib_module .	def import_library ( taglib_module ) :
11322	try ,	try :
11323	call the function import_module with an argument taglib_module , substitute the result for mod .	mod = import_module ( taglib_module )
11324	if ImportError , renamed to e , exception is caught ,	except ImportError as e :
11325	call the function is_library_missing with an argument taglib_module , if it evaluates to true ,	if is_library_missing ( taglib_module ) :
11326	return None .	return None
11327	if not ,	else :
11328	raise an InvalidTemplateLibrary exception with an argument string STR0 , where STR1 is replaced with taglib_module and e .	raise InvalidTemplateLibrary ( STR0 % ( taglib_module , e ) )
11329	try ,	try :
11330	return mod.register .	return mod . register
11331	if AttributeError exception is caught ,	except AttributeError :
11332	raise an InvalidTemplateLibrary exception with an argument string STR0 , where STR1 is replaced with taglib_module .	raise InvalidTemplateLibrary ( STR0 % taglib_module )
11333	templatetags_modules is an empty list .	templatetags_modules = [ ]
11334	define the function get_templatetags_modules .	def get_templatetags_modules ( ) :
11335	use global variable templatetags_modules .	global templatetags_modules
11336	if templatetags_modules is false ,	if not templatetags_modules :
11337	_templatetags_modules is an empty list .	_templatetags_modules = [ ]
11338	templatetags_modules_candidates is an list with an argument string STR0 .	templatetags_modules_candidates = [ STR0 ]
11339	add string STR0 to a list , where STR1 is replaced with app_config.name , for every app_config in result of the method apps.get_app_configs , append the resulting list to templatetags_modules_candidates .	templatetags_modules_candidates += [ STR0 % app_config . name for app_config in apps . get_app_configs ( ) ]
11340	for every templatetag_module in templatetags_modules_candidates ,	for templatetag_module in templatetags_modules_candidates :
11341	try ,	try :
11342	call the function import_module with an argument templatetag_module .	import_module ( templatetag_module )
11343	append templatetag_module to _templatetags_modules .	_templatetags_modules . append ( templatetag_module )
11344	if ImportError exception is caught ,	except ImportError :
11345	skip this loop iteration .	continue
11346	substitute _templatetags_modules for templatetags_modules .	templatetags_modules = _templatetags_modules
11347	return templatetags_modules .	return templatetags_modules
11348	define the function get_library with an argument library_name .	def get_library ( library_name ) :
11349	get the value under the library_name key of the libraries dictionary , if it exists , substitute it for lib , if not , lib is None .	lib = libraries . get ( library_name , None )
11350	if lib is false ,	if not lib :
11351	call the function get_templatetags_modules , substitute the result for templatetags_modules .	templatetags_modules = get_templatetags_modules ( )
11352	tried_modules is an empty list .	tried_modules = [ ]
11353	for every module in templatetags_modules ,	for module in templatetags_modules :
11354	taglib_module is an string STR0 , where STR1 is replaced to module and library_name .	taglib_module = STR0 % ( module , library_name )
11355	append taglib_module to tried_modules .	tried_modules . append ( taglib_module )
11356	call the function import_library with an argument taglib_module , substitute the result for lib .	lib = import_library ( taglib_module )
11357	if lib is true ,	if lib :
11358	substitute lib for value under the library_name key of libraries dictionary .	libraries [ library_name ] = lib
11359	break loop execution .	break
11360	if lib is false ,	if not lib :
11361	raise an InvalidTemplateLibrary exception with an argument string STR0 , where STR1 is replaced with library_name and elements of tried_modules joined into a string , separated by STR2 .	raise InvalidTemplateLibrary ( STR0 % ( library_name , STR1 . join ( tried_modules ) ) )
11362	return lib .	return lib
11363	define the function add_to_builtins with an argument module .	def add_to_builtins ( module ) :
11364	call the function import_library with an argument module , append the result to builtins .	builtins . append ( import_library ( module ) )
11365	call the function add_to_builtins with an argument string STR0 .	add_to_builtins ( STR0 )
11366	call the function add_to_builtins with an argument string STR0 .	add_to_builtins ( STR0 )
11367	call the function add_to_builtins with an argument string STR0 .	add_to_builtins ( STR0 )
11368	from copy import copy into default name space .	from copy import copy
11369	from django.utils.module_loading import import_string into default name space .	from django . utils . module_loading import import_string
11370	_standard_context_processors is None .	_standard_context_processors = None
11371	_builtin_context_processors is a tuple containing a string STR0 .	_builtin_context_processors = ( STR0 , )
11372	derive the class ContextPopException from the Exception base class .	class ContextPopException ( Exception ) :
11373	do nothing .	pass
11374	derive the class ContextDict from the dict base class .	class ContextDict ( dict ) :
11375	define the method __init__ with 4 arguments : self , context , unpacked list args and unpacked dictionary kwargs .	def __init__ ( self , context , * args , ** kwargs ) :
11376	call the method __init__ from the base class of the class ContextDict , with 2 arguments : unpacked list args and unpacked dictionary kwargs .	super ( ContextDict , self ) . __init__ ( * args , ** kwargs )
11377	append self to context.dicts .	context . dicts . append ( self )
11378	substitute context for self.context .	self . context = context
11379	define the method __enter__ with an argument self .	def __enter__ ( self ) :
11380	return self .	return self
11381	define the method __exit__ with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .	def __exit__ ( self , * args , ** kwargs ) :
11382	remove the first element from the self.context .	self . context . pop ( )
11383	derive the class BaseContext from the object base class .	class BaseContext ( object ) :
11384	define the method __init__ with 2 arguments : self and dict_ set to None .	def __init__ ( self , dict_ = None ) :
11385	call the method self._reset_dicts with an argument dict_ .	self . _reset_dicts ( dict_ )
11386	define the method _reset_dicts with 2 arguments : self and value set to None .	def _reset_dicts ( self , value = None ) :
11387	builtins is an dictionary with 3 initial entries : boolean True for STR0 , boolean False for STR1 and None for STR2 .	builtins = { STR0 : True , STR1 : False , STR2 : None }
11388	self.dicts is an list with element builtins .	self . dicts = [ builtins ]
11389	if value is not None ,	if value is not None :
11390	append value to self.dicts list .	self . dicts . append ( value )
11391	define the method __copy__ with an argument self .	def __copy__ ( self ) :
11392	call the function copy with an argument base class of the class BaseContext , substitute the result for duplicate .	duplicate = copy ( super ( BaseContext , self ) )
11393	hard copy list self.dicts to duplicate.dicts .	duplicate . dicts = self . dicts [ : ]
11394	return duplicate .	return duplicate
11395	define the method __repr__ with an argument self .	def __repr__ ( self ) :
11396	return printable representation of self.dicts .	return repr ( self . dicts )
11397	define the method __iter__ with an argument self .	def __iter__ ( self ) :
11398	for every d in reversed list self.dicts ,	for d in reversed ( self . dicts ) :
11399	yield d .	yield d
11400	define the method push with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .	def push ( self , * args , ** kwargs ) :
11401	instantiate class ContextDict with 3 arguments : self , unpacked list args and unpacked dictionary kwargs , return it .	return ContextDict ( self , * args , ** kwargs )
11402	define the method pop with an argument self .	def pop ( self ) :
11403	if length of self.dicts is equal to an integer 1 ,	if len ( self . dicts ) == 1 :
11404	raise an ContextPopException .	raise ContextPopException
11405	call the method self.dicts.pop , return the result .	return self . dicts . pop ( )
11406	define the method __setitem__ with 3 arguments : self , key and value .	def __setitem__ ( self , key , value ) :
11407	substitute value for value under the key key of dictionary at last element of self.dicts .	self . dicts [ - 1 ] [ key ] = value
11408	define the method __getitem__ with 2 arguments : self and key .	def __getitem__ ( self , key ) :
11409	for every d in reversed list self.dicts ,	for d in reversed ( self . dicts ) :
11410	if key is contained in d ,	if key in d :
11411	return value under the key key of d dictionary .	return d [ key ]
11412	raise KeyError exception with an argument key .	raise KeyError ( key )
11413	define the method __delitem__ with 2 arguments : self and key .	def __delitem__ ( self , key ) :
11414	delete value under the key key of dictionary at last element of self.dicts .	del self . dicts [ - 1 ] [ key ]
11415	define the method has_key with 2 arguments : self and key .	def has_key ( self , key ) :
11416	for every d in self.dicts ,	for d in self . dicts :
11417	if key is contained in d ,	if key in d :
11418	return boolean True .	return True
11419	return boolean False .	return False
11420	define the method __contains__ with 2 arguments : self and key .	def __contains__ ( self , key ) :
11421	call the method self.has_key with an argument key , return the result .	return self . has_key ( key )
11422	define the method got with 3 arguments : self , key and otherwise set to None .	def get ( self , key , otherwise = None ) :
11423	for every d in reversed list self.dicts ,	for d in reversed ( self . dicts ) :
11424	if key is contained in d ,	if key in d :
11425	return value under the key key of d dictionary .	return d [ key ]
11426	return otherwise .	return otherwise
11427	define the method new with 2 arguments : self and values set to None .	def new ( self , values = None ) :
11428	call the function copy with an argument self , substitute the result for new_context .	new_context = copy ( self )
11429	call the method new_context._reset_dicts values .	new_context . _reset_dicts ( values )
11430	return new_context .	return new_context
11431	define the method flatten with an argument self .	def flatten ( self ) :
11432	flat is an empty dictionary ,	flat = { }
11433	for every d in self.dicts ,	for d in self . dicts :
11434	update flat dictionary with d .	flat . update ( d )
11435	return flat .	return flat
11436	define the method __eq__ with 2 arguments : self and other .	def __eq__ ( self , other ) :
11437	if other is an instance of BaseContext class ,	if isinstance ( other , BaseContext ) :
11438	call the flatten method of the self and other objects , if they are equal , return boolean True , if not return boolean False .	return self . flatten ( ) == other . flatten ( )
11439	return boolean False .	return False
11440	derive the class Context from the BaseContext base class .	class Context ( BaseContext ) :
11441	define the method __init__ with 6 arguments : self , dict_ set to None , autoescape set to True , current_app set to None , use_l10n set to None and use_tz set to None .	def __init__ ( self , dict_ = None , autoescape = True , current_app = None , use_l10n = None , use_tz = None ) :
11442	substitute autoescape for self.autoescape .	self . autoescape = autoescape
11443	substitute current_app for self.current_app .	self . current_app = current_app
11444	substitute use_l10n for self.use_l10n .	self . use_l10n = use_l10n
11445	substitute use_tz for self.use_tz .	self . use_tz = use_tz
11446	self.render_context is a instance of RenderContext class .	self . render_context = RenderContext ( )
11447	call the the method __init__ from the base class of the class Context .	super ( Context , self ) . __init__ ( dict_ )
11448	define the method __copy__ with an argument self .	def __copy__ ( self ) :
11449	call the the method __copy__ from the base class of the class Context , substitute the result for duplicate .	duplicate = super ( Context , self ) . __copy__ ( )
11450	call the function copy with an argument self.render_context , substitute the result for duplicate.render_context .	duplicate . render_context = copy ( self . render_context )
11451	return duplicate	return duplicate
11452	define the method update with 2 arguments : self and other_dict .	def update ( self , other_dict ) :
11453	if other_dict doesnt have an STR0 attribute ,	if not hasattr ( other_dict , STR0 ) :
11454	raise an TypeError exception with an argument string STR0 .	raise TypeError ( STR0 )
11455	append other_dict to self.dicts .	self . dicts . append ( other_dict )
11456	return other_dict .	return other_dict
11457	derive the class RenderContext from the BaseContext base class .	class RenderContext ( BaseContext ) :
11458	define the method __iter__ with an argument self .	def __iter__ ( self ) :
11459	for every d in last element of self.dicts ,	for d in self . dicts [ - 1 ] :
11460	yield d .	yield d
11461	define the method has_key with 2 arguments : self and key .	def has_key ( self , key ) :
11462	if key is contained in last element of self.dicts , return boolean True , otherwise return boolean False .	return key in self . dicts [ - 1 ]
11463	define the method get with 3 arguments : self , key and otherwise set to None .	def get ( self , key , otherwise = None ) :
11464	return value under the key key of dictionary in last element of self.dicts , if it doesnt exists return otherwise .	return self . dicts [ - 1 ] . get ( key , otherwise )
11465	define the method __getitem__ with 2 arguments : self and key .	def __getitem__ ( self , key ) :
11466	return value under the key key of dictionary in last element of self.dicts .	return self . dicts [ - 1 ] [ key ]
11467	define the function get_standard_processors .	def get_standard_processors ( ) :
11468	from django.conf import settings into default namespace .	from django . conf import settings
11469	use global variable _standard_context_processors .	global _standard_context_processors
11470	if _standard_context_processors is None ,	if _standard_context_processors is None :
11471	processors is an empty list .	processors = [ ]
11472	collect is an empty list .	collect = [ ]
11473	extend collect list with _builtin_context_processors .	collect . extend ( _builtin_context_processors )
11474	extend collect list with settings.TEMPLATE_CONTEXT_PROCESSORS .	collect . extend ( settings . TEMPLATE_CONTEXT_PROCESSORS )
11475	for every path in collect ,	for path in collect :
11476	call the function import_string with an argument path , substitute the result for func .	func = import_string ( path )
11477	append func to processors .	processors . append ( func )
11478	convert processors elements into a tuple , substitute it for _standard_context_processors .	_standard_context_processors = tuple ( processors )
11479	return _standard_context_processors .	return _standard_context_processors
11480	derive the class RequestContext from the Context base class .	class RequestContext ( Context ) :
11481	define the method __init__ with 7 arguments : self , request , dict_ set to None , processors set to None , current_app set to None , use_l10n set to None and use_tz set to None .	def __init__ ( self , request , dict_ = None , processors = None , current_app = None , use_l10n = None , use_tz = None ) :
11482	call the method Context.__init__ with 5 arguments : self , dict_ , current_app as current_app , use_l10n as use_l10n , use_tz as use_tz .	Context . __init__ ( self , dict_ , current_app = current_app , use_l10n = use_l10n , use_tz = use_tz )
11483	if processors is None ,	if processors is None :
11484	processors is an empty tuple .	processors = ( )
11485	if not ,	else :
11486	convert processors into a tuple and substitute it for processors .	processors = tuple ( processors )
11487	updates is an empty dictionary .	updates = dict ( )
11488	call the function get_standard_processors , append processors to the result , for every processor is the result ,	for processor in get_standard_processors ( ) + processors :
11489	call the function processor with an argument request , update updates dictionary with the result .	updates . update ( processor ( request ) )
11490	update self dictionary with updates .	self . update ( updates )
11491	from django.template.base import Lexer , Parser , tag_re , NodeList , VariableNode and TemplateSyntaxError into default name space .	from django . template . base import Lexer , Parser , tag_re , NodeList , VariableNode , TemplateSyntaxError
11492	from django.utils.encoding import force_text into default name space .	from django . utils . encoding import force_text
11493	from django.utils.html import escape into default name space .	from django . utils . html import escape
11494	from django.utils.safestring import SafeData and EscapeData into default name space .	from django . utils . safestring import SafeData , EscapeData
11495	from django.utils.formats import localize into default name space .	from django . utils . formats import localize
11496	from django.utils.timezone import template_localtime into default name space .	from django . utils . timezone import template_localtime
11497	derive the class DebugLexer from the Lexer base class .	class DebugLexer ( Lexer ) :
11498	define the method __init__ with 3 arguments : self , template_string and origin .	def __init__ ( self , template_string , origin ) :
11499	call the method __init__ from the base class of the class DebugLexer , with 2 arguments : template_string and origin .	super ( DebugLexer , self ) . __init__ ( template_string , origin )
11500	define the method tokenize with an argument self .	def tokenize ( self ) :
11501	result is an empty list , upto is integer 0 .	result , upto = [ ] , 0
11502	call the method tag_re.finditer with an argument self.template_string , for every match in result ,	for match in tag_re . finditer ( self . template_string ) :
11503	call the method match.span , substitute the result for start an end , respectively .	start , end = match . span ( )
11504	if start is greater than upto ,	if start > upto :
11505	call the method self.create_token with 3 arguments : self.template_string list elements from upto index to start index , tuple with 2 elements : upto and start and boolean False , append the result to result .	result . append ( self . create_token ( self . template_string [ upto : start ] , ( upto , start ) , False ) )
11506	substitute start for upto .	upto = start
11507	call the method self.create_token with 3 arguments : self.template_string list elements from start index to end index , tuple with 2 elements : start and end and boolean False , append the result to result .	result . append ( self . create_token ( self . template_string [ start : end ] , ( start , end ) , True ) )
11508	substitute end for upto .	upto = end
11509	substitute elements of self.template_string list from upto index to the end for last_lit .	last_bit = self . template_string [ upto : ]
11510	if last_bit is true ,	if last_bit :
11511	call the method self.create_token with 3 arguments : last_bit , tuple with 2 elements : upto and sum of upto and length of last_bit , and boolean False , append the result to result .	result . append ( self . create_token ( last_bit , ( upto , upto + len ( last_bit ) ) , False ) )
11512	return result .	return result
11513	define the method create_token with 4 arguments : self , token_string , source and in_tag .	def create_token ( self , token_string , source , in_tag ) :
11514	call the method create_token from the base class of the class DebugLexer , with 2 arguments : template_string and in_tag , substitute the result for token .	token = super ( DebugLexer , self ) . create_token ( token_string , in_tag )
11515	assign self.origin , source to token.source .	token . source = self . origin , source
11516	return token .	return token
11517	derive the class DebugParser from the Parser base class .	class DebugParser ( Parser ) :
11518	define the method __init__ with 2 arguments : self and lexer .	def __init__ ( self , lexer ) :
11519	call the method __init__ with an argument lexer , from the base class of the class DebugParser .	super ( DebugParser , self ) . __init__ ( lexer )
11520	self.command_stack is an empty list .	self . command_stack = [ ]
11521	define the method enter_command with 3 arguments : self , command and token .	def enter_command ( self , command , token ) :
11522	append tuple with 2 elements : command and token.source , append the result to self.command_stack .	self . command_stack . append ( ( command , token . source ) )
11523	define the method exit_command with an argument self .	def exit_command ( self ) :
11524	remove first element from self.command_stack .	self . command_stack . pop ( )
11525	define the method error with 3 arguments : self , token and msg .	def error ( self , token , msg ) :
11526	call the method self.source_error with 2 arguments : token.source and msg , return the result .	return self . source_error ( token . source , msg )
11527	define the method source_error with 3 arguments : self , source and msg .	def source_error ( self , source , msg ) :
11528	e is an instance of TemplateSyntaxError class , created with an argument msg .	e = TemplateSyntaxError ( msg )
11529	substitute source for e.django_template_source .	e . django_template_source = source
11530	return e .	return e
11531	define the method create_nodelist with an argument self .	def create_nodelist ( self ) :
11532	return an instance of DebugNodeList class .	return DebugNodeList ( )
11533	define the method create_variable_node with 2 arguments : self and contents .	def create_variable_node ( self , contents ) :
11534	return an instance of DebugVariableNode , created with an argument contents .	return DebugVariableNode ( contents )
11535	define the method extend_nodelist with 4 arguments : self , nodelist , node and token .	def extend_nodelist ( self , nodelist , node , token ) :
11536	substitute token.source for node.source .	node . source = token . source
11537	call the method extend_nodelist with 3 arguments : nodelist , node and token , from the base class of the class DebugParser .	super ( DebugParser , self ) . extend_nodelist ( nodelist , node , token )
11538	define the method unclosed_block_tag with 2 arguments : self and parse_until .	def unclosed_block_tag ( self , parse_until ) :
11539	remove the first element from self.command_stack , assign the result to command and source , respectively .	command , source = self . command_stack . pop ( )
11540	msg is an string STR0 , where STR1 is replaced with command , and elements of parse_until joined into a string , separated by string STR2 .	msg = STR0 % ( command , STR1 . join ( parse_until ) )
11541	raise an self.source_error exception with 2 arguments : source and msg .	raise self . source_error ( source , msg )
11542	define the method compile_filter_error with 3 arguments : self , token and e .	def compile_filter_error ( self , token , e ) :
11543	if e doesnt have an STR0 attribute ,	if not hasattr ( e , STR0 ) :
11544	substitute token.source for e.django_template_source .	e . django_template_source = token . source
11545	define the method compile_function_error with 3 arguments : self , token and e .	def compile_function_error ( self , token , e ) :
11546	if e doesnt have an STR0 attribute ,	if not hasattr ( e , STR0 ) :
11547	substitute token.source for e.django_template_source .	e . django_template_source = token . source
11548	derive the class DebugNodeList from the NodeList base class .	class DebugNodeList ( NodeList ) :
11549	define the method render_node with 3 arguments : self , node and context .	def render_node ( self , node , context ) :
11550	try ,	try :
11551	call the method node.render with an argument context , return the result .	return node . render ( context )
11552	if Exception , renamed to e , exception is caught ,	except Exception as e :
11553	if e doesnt have an STR0 attribute ,	if not hasattr ( e , STR0 ) :
11554	substitute node.source for e.django_template_source .	e . django_template_source = node . source
11555	raise an exception .	raise
11556	derive the class DebugVariableNode from the VariableNode base class .	class DebugVariableNode ( VariableNode ) :
11557	define the method render with 2 arguments : self and context .	def render ( self , context ) :
11558	try ,	try :
11559	call the method self.filter_expression.resolve with an argument context , substitute the result for output .	output = self . filter_expression . resolve ( context )
11560	call the function template_localtime with 2 arguments : output and use_tz set to context.use_tz , substitute the result for output .	output = template_localtime ( output , use_tz = context . use_tz )
11561	call the function localize with 2 arguments : output and use_l10n set to context.use_l10n , substitute the result for output .	output = localize ( output , use_l10n = context . use_l10n )
11562	call the function force_text with an argument output , substitute the result for output .	output = force_text ( output )
11563	if UnicodeDecodeError exception is caught ,	except UnicodeDecodeError :
11564	return an empty string .	return STR
11565	if Exception , renamed to e , exception is caught ,	except Exception as e :
11566	if e doesnt have an STR0 attribute ,	if not hasattr ( e , STR0 ) :
11567	substitute self.source for e.django_template_source .	e . django_template_source = self . source
11568	raise an exception .	raise
11569	if context.autoescape is true and output is not an instance of SafeData class or output is an instance of EscapeData class ,	if ( context . autoescape and not isinstance ( output , SafeData ) ) or isinstance ( output , EscapeData ) :
11570	call the function escape with an argument output .	return escape ( output )
11571	if not ,	else :
11572	return output .	return output
11573	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
11574	import module re .	import re
11575	import module random as random_module .	import random as random_module
11576	from decimal import Decimal , InvalidOperation , Context and ROUND_HALF_UP into default name space .	from decimal import Decimal , InvalidOperation , Context , ROUND_HALF_UP
11577	from functools import wraps into default name space .	from functools import wraps
11578	from pprint import pformat into default name space .	from pprint import pformat
11579	from django.template.base import Variable , Library and VariableDoesNotExist into default name space .	from django . template . base import Variable , Library , VariableDoesNotExist
11580	from django.conf import settings into default name space .	from django . conf import settings
11581	from django.utils import formats into default name space .	from django . utils import formats
11582	from django.utils.dateformat import format and time_format into default name space .	from django . utils . dateformat import format , time_format
11583	from django.utils.encoding import force_text and iri_to_uri into default name space .	from django . utils . encoding import force_text , iri_to_uri
11584	from django.utils.html import conditional_escape , escapejs , escape , urlize as _urlize , linebreaks , strip_tags , avoid_wrapping , and remove_tags .	from django . utils . html import ( conditional_escape , escapejs , escape , urlize as _urlize , linebreaks , strip_tags , avoid_wrapping , remove_tags )
11585	from django.utils.http import urlquote into default name space .	from django . utils . http import urlquote
11586	from django.utils.text import Truncator , wrap and phone2numeric into default name space .	from django . utils . text import Truncator , wrap , phone2numeric
11587	from django.utils.safestring import mark_safe , SafeData and mark_for_escaping into default name space .	from django . utils . safestring import mark_safe , SafeData , mark_for_escaping
11588	from django.utils import six into default name space .	from django . utils import six
11589	from django.utils.timesince import timesince and timeuntil into default name space .	from django . utils . timesince import timesince , timeuntil
11590	from django.utils.translation import ugettext and ungettext into default name space .	from django . utils . translation import ugettext , ungettext
11591	from django.utils.text import normalize_newlines and slugify as _slugify into default name space .	from django . utils . text import normalize_newlines , slugify as _slugify
11592	register is an instance of Library class .	register = Library ( )
11593	define the method stringfilter with an argument func .	def stringfilter ( func ) :
11594	define the method _dec with 2 arguments : unpacked list args and unpacked dictionary kwargs .	def _dec ( * args , ** kwargs ) :
11595	if args in true ,	if args :
11596	convert args into a list , substitute it for args .	args = list ( args )
11597	call the function force_text with an argument first element of args , substitute the result for first element of args .	args [ 0 ] = force_text ( args [ 0 ] )
11598	if first element of args is an instance of SafeData , and STR0 attribute of dec._decorated_function object is true ,	if ( isinstance ( args [ 0 ] , SafeData ) and getattr ( _dec . _decorated_function , STR0 , False ) ) :
11599	call the function func with 2 arguments : unpacked list args and unpacked dictionary kwargs , use the result as an argument for the call to the mark_safe function , return the result .	return mark_safe ( func ( * args , ** kwargs ) )
11600	call the function func with 2 arguments : unpacked list args and unpacked dictionary kwargs , return the result .	return func ( * args , ** kwargs )
11601	get STR0 attribute from the func object , substitute it for _dec._decorated_function , if it doesnt exist , substitute func for _dec._decorated_function .	_dec . _decorated_function = getattr ( func , STR0 , func )
11602	call the function wraps with an argument func , call the result with an argument _dec , return the result .	return wraps ( func ) ( _dec )
11603	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11604	decorator stringfilter ,	@ stringfilter
11605	define the function addslashes with an argument value .	def addslashes ( value ) :
11606	replace all occurrences of STRspecial with STR1 in value , replace all occurrences of STR with STR2 in the previous result , replace all occurrences of STR with STR0 in the previous result , return the result .	return value . replace ( STRspecial , STR1 ) . replace ( STR , STR2 ) . replace ( STR , STR0 )
11607	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11608	decorator stringfilter ,	@ stringfilter
11609	define the function capfirst with an argument value .	def capfirst ( value ) :
11610	if value is false , return it , if it is true convert first element of value to uppercase letter , return the value .	return value and value [ 0 ] . upper ( ) + value [ 1 : ]
11611	decorator function register.filter with an argument string STR0 .	@ register . filter ( STR0 )
11612	decorator stringfilter ,	@ stringfilter
11613	define the function escapejs_filter with an argument value .	def escapejs_filter ( value ) :
11614	call the function escapejs with an argument value , return the result .	return escapejs ( value )
11615	multiply 10 to the power of 200 , with itself , substitute the result for pos_inf .	pos_inf = 1e200 * 1e200
11616	multiply 10 to the power of 200 , with 10 to the power of 200 , negative , substitute the result for neg_inf .	neg_inf = - 1e200 * 1e200
11617	divide 10 to the power of 400 by 10 to the power of 400 , substitute the result for nan .	nan = ( 1e200 * 1e200 ) // ( 1e200 * 1e200 )
11618	special_floats is an list with 3 elements , pos_inf , neg_inf and nan , all converted to strings .	special_floats = [ str ( pos_inf ) , str ( neg_inf ) , str ( nan ) ]
11619	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11620	define the function floatformat with 2 arguments text and arg set to integer -1 .	def floatformat ( text , arg = - 1 ) :
11621	try ,	try :
11622	call the function force_text with an argument text , substitute the result for input_val .	input_val = force_text ( text )
11623	d is an instance of Decimal class created with an argument input_val .	d = Decimal ( input_val )
11624	if UnicodeEncodeError exception is caught ,	except UnicodeEncodeError :
11625	return an empty string .	return STR
11626	if InvalidOperation exception is caught ,	except InvalidOperation :
11627	if every input_val in special_floats ,	if input_val in special_floats :
11628	return input_val .	return input_val
11629	try ,	try :
11630	d is an instance of class Decimal , created with result of the function force_text , called with an argument text converted into a floating point number .	d = Decimal ( force_text ( float ( text ) ) )
11631	if ValueError , InvalidOperation , TypeError or UnicodeEncodeError exceptions are caught ,	except ( ValueError , InvalidOperation , TypeError , UnicodeEncodeError ) :
11632	return an empty string .	return STR
11633	try ,	try :
11634	convert arg to an integer , substitute it for p .	p = int ( arg )
11635	if ValueError exception is caught ,	except ValueError :
11636	return input_val .	return input_val
11637	try ,	try :
11638	convert d into a integer , subtract d from it , substitute the result for m .	m = int ( d ) - d
11639	if ValueError , OverflowError or InvalidOperation exceptions are caught ,	except ( ValueError , OverflowError , InvalidOperation ) :
11640	return input_val .	return input_val
11641	if m is false and p is lesser than integer 0 ,	if not m and p < 0 :
11642	call the method formats.number_format with 2 arguments , d converted to a integer and then to string , and integer 0 , use the result as an argument for the call to the function mark_safe , return the result .	return mark_safe ( formats . number_format ( STR0 % ( int ( d ) ) , 0 ) )
11643	if p equals integer 0 ,	if p == 0 :
11644	exp is an instance of Decimal , created with an argument integer 1 .	exp = Decimal ( 1 )
11645	if not ,	else :
11646	instantiate class Decimal with string STR0 as argument , divide it by product of instance of Decimal class created with integer 10 , and absolute value of p , substitute the result for exp .	exp = Decimal ( STR0 ) / ( Decimal ( 10 ) ** abs ( p ) )
11647	try ,	try :
11648	call the method d.as_tuple , substitute the result for tupl .	tupl = d . as_tuple ( )
11649	subtract third element of tupl from length of second element of tupl , substitute the result for units .	units = len ( tupl [ 1 ] ) - tupl [ 2 ]
11650	sum absolute p with units an integer 1 , substitute the result for prec .	prec = abs ( p ) + units + 1
11651	call the method d.quantize with 3 arguments : exp , ROUND_HALF_UP and instance of Context class created with prec as prec , call the method as_tuple on the result , substitute the result for sign , digits and exponent , respectively .	sign , digits , exponent = d . quantize ( exp , ROUND_HALF_UP , Context ( prec = prec ) ) . as_tuple ( )
11652	append result of method six.text_type called with an argument digit to an list , for every digit in reversed order of digits , substitute the resulting list for digits .	digits = [ six . text_type ( digit ) for digit in reversed ( digits ) ]
11653	while length of digits is smaller than or equal to absolute value of exponent ,	while len ( digits ) <= abs ( exponent ) :
11654	append STR0 to digits .	digits . append ( STR0 )
11655	insert STR0 to digits at negative exponent index .	digits . insert ( - exponent , STR0 )
11656	if sign is true ,	if sign :
11657	append STR0 to digits .	digits . append ( STR0 )
11658	reverse element order of dicts , join them in a string , substitute the result for number .	number = STR . join ( reversed ( digits ) )
11659	call the method formats.number_format with 2 arguments : number and absolute value of p , use the result as an argument for the call to the mark_safe function , return the result .	return mark_safe ( formats . number_format ( number , abs ( p ) ) )
11660	if InvalidOperation exception is caught ,	except InvalidOperation :
11661	return input_val .	return input_val
11662	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11663	decorator stringfilter ,	@ stringfilter
11664	define the function iriencode with an argument value .	def iriencode ( value ) :
11665	call the function iri_to_uri with an argument value , use the result as an argument for the call to the force_text function , return the result .	return force_text ( iri_to_uri ( value ) )
11666	decorator function register.filter with 2 arguments is_safe set to boolean True and needs_autoescape set to boolean True .	@ register . filter ( is_safe = True , needs_autoescape = True )
11667	decorator stringfilter ,	@ stringfilter
11668	define the function linenumbers with 2 arguments value and autoescape set to None .	def linenumbers ( value , autoescape = None ) :
11669	split value by newline characters , substitute the result for lines .	lines = value . split ( STR0 )
11670	call the function six.text_type with length of lines as an argument , use length of result as an argument for the call to the function six.text_type , substitute the result for width .	width = six . text_type ( len ( six . text_type ( len ( lines ) ) ) )
11671	if autoescape is false , if value is an instance of SafeData ,	if not autoescape or isinstance ( value , SafeData ) :
11672	for every i and line in enumerated iterable lines ,	for i , line in enumerate ( lines ) :
11673	concatenate string STR1 , width and string STR0 , format the previous string with i incremented by 1 and line , substitute the result for i-th element of lines .	lines [ i ] = ( STR0 + width + STR1 ) % ( i + 1 , line )
11674	if not ,	else :
11675	for every i and line in enumerated iterable lines ,	for i , line in enumerate ( lines ) :
11676	concatenate string STR1 , width and string STR0 , format the previous string with i incremented by 1 , and result of the function escape called with an argument line , substitute the result for i-th element of lines .	lines [ i ] = ( STR0 + width + STR1 ) % ( i + 1 , escape ( line ) )
11677	call the method mark_safe with lines joined into a string , separated by newlines as argument , return the result .	return mark_safe ( STR0 . join ( lines ) )
11678	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11679	decorator stringfilter ,	@ stringfilter
11680	define the function lower with an argument value .	def lower ( value ) :
11681	convert value to lowercase and return the result .	return value . lower ( )
11682	decorator function register.filter with an argument is_safe set to boolean False .	@ register . filter ( is_safe = False )
11683	decorator stringfilter ,	@ stringfilter
11684	define the function make_list with an argument value .	def make_list ( value ) :
11685	return value converted into a list .	return list ( value )
11686	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11687	decorator stringfilter ,	@ stringfilter
11688	define the function slugify with an argument value .	def slugify ( value ) :
11689	call the function _slugify with an argument value , return the result .	return _slugify ( value )
11690	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11691	define the function stringformat with 2 arguments value and arg .	def stringformat ( value , arg ) :
11692	try ,	try :
11693	call the function six.text_type with an argument arg , append the result to STR0 , format the previous with value , return the result .	return ( STR0 + six . text_type ( arg ) ) % value
11694	if TypeError or ValueError exceptions are caught ,	except ( ValueError , TypeError ) :
11695	return an empty string .	return STR
11696	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11697	decorator stringfilter ,	@ stringfilter
11698	define the function title with an argument value .	def title ( value ) :
11699	call the function re.sub with 3 arguments : string STR0 , lambda function with an argument m and return value , result of the m.group method called with an argument integer 0 converted into lowercase and result of the method value.title , substitute the result for t .	t = re . sub ( STR0 , lambda m : m . group ( 0 ) . lower ( ) , value . title ( ) )
11700	call the function re.sub with 3 arguments : string STR0 , lambda function with an argument m and return value , result of the m.group method called with an argument integer 0 converted into lowercase and t , return the result .	return re . sub ( STR0 , lambda m : m . group ( 0 ) . lower ( ) , t )
11701	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11702	decorator stringfilter ,	@ stringfilter
11703	define the function truncatechars with 2 arguments value and arg .	def truncatechars ( value , arg ) :
11704	try ,	try :
11705	substitute arg converted into a integer for length .	length = int ( arg )
11706	if ValueError exception is caught ,	except ValueError :
11707	return value .	return value
11708	instantiate class Truncator , with an argument value , call the method chars on the result with an argument length , return the result .	return Truncator ( value ) . chars ( length )
11709	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11710	decorator stringfilter ,	@ stringfilter
11711	define the function truncatechars_html with 2 arguments value and arg .	def truncatechars_html ( value , arg ) :
11712	try ,	try :
11713	substitute arg converted into an integer for length .	length = int ( arg )
11714	if ValueError exception is caught ,	except ValueError :
11715	return value .	return value
11716	instantiate class Truncator , with an argument value , call the method chars on the result with 2 arguments length , and html set to boolean True , return the result .	return Truncator ( value ) . chars ( length , html = True )
11717	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11718	decorator stringfilter ,	@ stringfilter
11719	define the function truncatewords with 2 arguments value and arg .	def truncatewords ( value , arg ) :
11720	try ,	try :
11721	substitute arg converted into an integer for length .	length = int ( arg )
11722	if ValueError exception is caught ,	except ValueError :
11723	return value .	return value
11724	instantiate class Truncator , with an argument value , call the method words on the result with 2 arguments length , and truncate set to string STR0 , return the result .	return Truncator ( value ) . words ( length , truncate = STR0 )
11725	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11726	decorator stringfilter ,	@ stringfilter
11727	define the function truncatewords_html with 2 arguments value and arg .	def truncatewords_html ( value , arg ) :
11728	try ,	try :
11729	substitute arg converted into an integer for length .	length = int ( arg )
11730	if ValueError exception is caught ,	except ValueError :
11731	return value .	return value
11732	instantiate class Truncator , with an argument value , call the method words on the result with 3 arguments length , html set to boolean True and truncate set to string STR0 , return the result .	return Truncator ( value ) . words ( length , html = True , truncate = STR0 )
11733	decorator function register.filter with an argument is_safe set to boolean False .	@ register . filter ( is_safe = False )
11734	decorator stringfilter ,	@ stringfilter
11735	define the function upper with an argument value .	def upper ( value ) :
11736	convert value to uppercase , return the result .	return value . upper ( )
11737	decorator function register.filter with an argument is_safe set to boolean False .	@ register . filter ( is_safe = False )
11738	decorator stringfilter ,	@ stringfilter
11739	define the function urlencode with 2 arguments value and safe set to None .	def urlencode ( value , safe = None ) :
11740	kwargs is an empty dictionary .	kwargs = { }
11741	if safe is not None ,	if safe is not None :
11742	substitute safe for value under the STR0 key of kwargs dictionary .	kwargs [ STR0 ] = safe
11743	call the function urlquote with 2 arguments value and unpacked dictionary kwargs , return the result .	return urlquote ( value , ** kwargs )
11744	decorator function register.filter with 2 arguments is_safe set to boolean True and needs_autoescape set to boolean True .	@ register . filter ( is_safe = True , needs_autoescape = True )
11745	decorator stringfilter ,	@ stringfilter
11746	define the function urlize with 2 arguments value and autoescape set to None .	def urlize ( value , autoescape = None ) :
11747	call the function _urlize with 3 arguments : value , nofollow set to boolean True , autoescape set to autoescape , use the result as an argument for the call to the function mark_safe , return the result .	return mark_safe ( _urlize ( value , nofollow = True , autoescape = autoescape ) )
11748	decorator function register.filter with 2 arguments is_safe set to boolean True and needs_autoescape set to boolean True .	@ register . filter ( is_safe = True , needs_autoescape = True )
11749	decorator stringfilter ,	@ stringfilter
11750	define the function urlizetrunc with 3 arguments value , limit and autoescape set to None .	def urlizetrunc ( value , limit , autoescape = None ) :
11751	call the function _urlize with 4 arguments : value , trim_url_limit as limit converted into an integer , nofollow as boolean True , and autoescape as autoescape , use the result as an argument for the call to the function mark_safe , return the result .	return mark_safe ( _urlize ( value , trim_url_limit = int ( limit ) , nofollow = True , autoescape = autoescape ) )
11752	decorator function register.filter with an argument is_safe set to boolean False .	@ register . filter ( is_safe = False )
11753	decorator stringfilter ,	@ stringfilter
11754	define the function wordcount with an argument value .	def wordcount ( value ) :
11755	split value into words , return the length of the result .	return len ( value . split ( ) )
11756	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11757	decorator stringfilter ,	@ stringfilter
11758	define the function wordwrap with 2 arguments value and arg .	def wordwrap ( value , arg ) :
11759	call the method wrap with 2 arguments , value and arg converted into a integer , return the result .	return wrap ( value , int ( arg ) )
11760	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11761	decorator stringfilter ,	@ stringfilter
11762	define the function ljust with 2 arguments value and arg .	def ljust ( value , arg ) :
11763	call the method value.ljust with an argument , arg converted into a integer , return the result .	return value . ljust ( int ( arg ) )
11764	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11765	decorator stringfilter ,	@ stringfilter
11766	define the function rjust with 2 arguments value and arg .	def rjust ( value , arg ) :
11767	call the method value.rjust with an argument , arg converted into a integer , return the result .	return value . rjust ( int ( arg ) )
11768	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11769	decorator stringfilter ,	@ stringfilter
11770	define the function center with 2 arguments value and arg .	def center ( value , arg ) :
11771	call the method value.center with an argument , arg converted into a integer , return the result .	return value . center ( int ( arg ) )
11772	decorator register.filter .	@ register . filter
11773	decorator stringfilter ,	@ stringfilter
11774	define the function cut with 2 arguments value and arg .	def cut ( value , arg ) :
11775	if value is an instance of SafeData , safe is boolean True , otherwise it is boolean False .	safe = isinstance ( value , SafeData )
11776	replace every occurrence of arg is value for an empty string , substitute the result for value .	value = value . replace ( arg , STR )
11777	if safe is true and arg is not equal to string STR0 ,	if safe and arg != STR0 :
11778	call the function mark_safe with an argument value , return the result .	return mark_safe ( value )
11779	return value .	return value
11780	decorator function register.filter with 2 arguments string STR0 and is_safe set to boolean True .	@ register . filter ( STR0 , is_safe = True )
11781	decorator stringfilter ,	@ stringfilter
11782	define the function escape_filter with an argument value .	def escape_filter ( value ) :
11783	call the function mark_for_escaping with an argument value , return the result .	return mark_for_escaping ( value )
11784	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11785	decorator stringfilter ,	@ stringfilter
11786	define the function force_escape with an argument value .	def force_escape ( value ) :
11787	call the function escape with an argument value , return the result .	return escape ( value )
11788	decorator function register.filter with 3 arguments string STR0 , is_safe set to boolean True and needs_autoescape set to True .	@ register . filter ( STR0 , is_safe = True , needs_autoescape = True )
11789	decorator stringfilter ,	@ stringfilter
11790	define the function linebreaks_filter with 2 arguments value and autoescape set to None .	def linebreaks_filter ( value , autoescape = None ) :
11791	if autoescape is true and value is not an instance of SafeData , autoescape is boolean True , otherwise it is boolean False .	autoescape = autoescape and not isinstance ( value , SafeData )
11792	call the function linebreaks with 2 arguments value and autoescape , use the result as an argument for the call to the mark_safe , return the result .	return mark_safe ( linebreaks ( value , autoescape ) )
11793	decorator function register.filter with 2 arguments is_safe set to boolean True and needs_autoescape set to boolean True .	@ register . filter ( is_safe = True , needs_autoescape = True )
11794	decorator stringfilter ,	@ stringfilter
11795	define the function linebreaksbr with 2 arguments value and autoescape set to None .	def linebreaksbr ( value , autoescape = None ) :
11796	if autoescape is true and value is not an instance of SafeData , autoescape is boolean True , otherwise it is boolean False .	autoescape = autoescape and not isinstance ( value , SafeData )
11797	call the function normalize_newlines with an argument value , substitute the result for value .	value = normalize_newlines ( value )
11798	if autoescape is true ,	if autoescape :
11799	call the function escape with an argument value , substitute it for value .	value = escape ( value )
11800	replace every occurrence of newline character in value with string STR0 , use it as an argument for the call to the mark_safe , return the result .	return mark_safe ( value . replace ( STR0 , STR1 ) )
11801	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11802	decorator stringfilter ,	@ stringfilter
11803	define the function safe with an argument value .	def safe ( value ) :
11804	call the function mark_safe with an argument value , return the result .	return mark_safe ( value )
11805	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11806	define the function safeseq with an argument value .	def safeseq ( value ) :
11807	for every obj in value call the function mark_safe with an argument result of the function force_text called with an argument obj , return all the results in a list .	return [ mark_safe ( force_text ( obj ) ) for obj in value ]
11808	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11809	decorator stringfilter ,	@ stringfilter
11810	define the function removetags with 2 arguments value and arg .	def removetags ( value , tags ) :
11811	call the function remove_tags with 2 arguments value and tags , return the result .	return remove_tags ( value , tags )
11812	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11813	decorator stringfilter ,	@ stringfilter
11814	define the function striptags with an argument value .	def striptags ( value ) :
11815	call the function strip_tags with an argument value , return the result .	return strip_tags ( value )
11816	decorator function register.filter with an argument is_safe set to boolean False .	@ register . filter ( is_safe = False )
11817	define the function dictsort with 2 arguments value and arg .	def dictsort ( value , arg ) :
11818	try ,	try :
11819	sort value with key set to filed resolve of instance of a class Variable , created with an argument arg , return the result .	return sorted ( value , key = Variable ( arg ) . resolve )
11820	if TypeError or VariableDoesNotExist exceptions are caught ,	except ( TypeError , VariableDoesNotExist ) :
11821	return an empty string .	return STR
11822	decorator function register.filter with an argument is_safe set to boolean False .	@ register . filter ( is_safe = False )
11823	define the function dictsortreversed with 2 arguments value and arg .	def dictsortreversed ( value , arg ) :
11824	try ,	try :
11825	sort value with key set to filed resolve of instance of a class Variable , created with an argument arg , reverse the sort and return the result .	return sorted ( value , key = Variable ( arg ) . resolve , reverse = True )
11826	if TypeError or VariableDoesNotExist exceptions are caught ,	except ( TypeError , VariableDoesNotExist ) :
11827	return an empty string .	return STR
11828	decorator function register.filter with an argument is_safe set to boolean False .	@ register . filter ( is_safe = False )
11829	define the function first with an argument value .	def first ( value ) :
11830	try ,	try :
11831	return first element of value .	return value [ 0 ]
11832	if IndexError exception is caught ,	except IndexError :
11833	return an empty string .	return STR
11834	decorator function register.filter with 2 arguments is_safe set to boolean True and needs_autoescape set to boolean True .	@ register . filter ( is_safe = True , needs_autoescape = True )
11835	define the function join with 3 arguments : value , arg and autoescape set to None .	def join ( value , arg , autoescape = None ) :
11836	map elements of value through mapping function force_text , substitute the result for value .	value = map ( force_text , value )
11837	if autoescape is true ,	if autoescape :
11838	for every v in value call the function conditional_escape with an argument v , append the result in a list , substitute the resulting list for value .	value = [ conditional_escape ( v ) for v in value ]
11839	try ,	try :
11840	call the function conditional_escape with an argument arg , call the method join on the result with an argument value , substitute the result for data .	data = conditional_escape ( arg ) . join ( value )
11841	if AttributeError exception is caught ,	except AttributeError :
11842	return value .	return value
11843	call the function mark_safe with an argument data , return the result .	return mark_safe ( data )
11844	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11845	define the function last with an argument value .	def last ( value ) :
11846	try ,	try :
11847	return last element of value .	return value [ - 1 ]
11848	if IndexError exception is caught ,	except IndexError :
11849	return an empty string .	return STR
11850	decorator function register.filter with an argument is_safe set to boolean False .	@ register . filter ( is_safe = False )
11851	define the function length with an argument value .	def length ( value ) :
11852	try ,	try :
11853	return length of value ,	return len ( value )
11854	if TypeError or ValueError exceptions are caught ,	except ( ValueError , TypeError ) :
11855	return integer 0 .	return 0
11856	decorator function register.filter with an argument is_safe set to boolean False .	@ register . filter ( is_safe = False )
11857	define the function length_is with 2 arguments value and arg .	def length_is ( value , arg ) :
11858	try ,	try :
11859	if lengths of value and arg are equal , return boolean True , otherwise return boolean False .	return len ( value ) == int ( arg )
11860	if TypeError or ValueError exceptions are caught ,	except ( ValueError , TypeError ) :
11861	return an empty string .	return STR
11862	decorator function register.filter with an argument is_safe set to boolean True .	@ register . filter ( is_safe = True )
11863	define the function random with an argument value .	def random ( value ) :
11864	call the function random_module.choice with an argument value , return the result .	return random_module . choice ( value )
11865	decorator function register.filter with 2 arguments string STR0 and is_safe set to boolean True .	@ register . filter ( STR0 , is_safe = True )
11866	define the function slice_filter with 2 arguments value and arg .	def slice_filter ( value , arg ) :
11867	try ,	try :
11868	bits is an empty list .	bits = [ ]
11869	split arg by STR0 , for every x in result ,	for x in arg . split ( STR0 ) :
11870	if length of x is equal to integer 0 ,	if len ( x ) == 0 :
11871	append None to bits .	bits . append ( None )
11872	if not ,	else :
11873	append x converted to an integer to bits .	bits . append ( int ( x ) )
11874	slice the list value with unpacked list bits as an argument , return the result .	return value [ slice ( * bits ) ]
11875	if TypeError or ValueError exceptions are caught ,	except ( ValueError , TypeError ) :
11876	return value .	return value
11877	decorator function register.filter with 2 arguments is_safe set to boolean True and needs_autoescape set to boolean True .	@ register . filter ( is_safe = True , needs_autoescape = True )
11878	define the function unordered_list with 2 arguments value and autoescape set to None .	def unordered_list ( value , autoescape = None ) :
11879	if autoescape is true ,	if autoescape :
11880	substitute conditional_escape for escaper .	escaper = conditional_escape
11881	if not ,	else :
11882	escaper is an identity lambda function .	escaper = lambda x : x
11883	define the function convert_old_style_list with an argument list_ .	def convert_old_style_list ( list_ ) :
11884	if list_ is not an instance of tuple or list types and length of list_ is not equal to integer 2 ,	if not isinstance ( list_ , ( tuple , list ) ) or len ( list_ ) != 2 :
11885	return list_ and boolean False .	return list_ , False
11886	substitute list_ for first_item and second_item , respectively .	first_item , second_item = list_
11887	if second_item is an empty list ,	if second_item == [ ] :
11888	return list with an element first_item , and boolean True .	return [ first_item ] , True
11889	try ,	try :
11890	convert second item to an iterable ,	iter ( second_item )
11891	if TypeError exception is caught ,	except TypeError :
11892	return list_ and boolean False .	return list_ , False
11893	old_style_list is boolean True .	old_style_list = True
11894	new_second_item is an empty list .	new_second_item = [ ]
11895	for every sublist in second_item ,	for sublist in second_item :
11896	call the function convert_old_style_list with an argument sublist , substitute the result for item and old_style_list .	item , old_style_list = convert_old_style_list ( sublist )
11897	if old_style_list is false ,	if not old_style_list :
11898	break from the loop execution ,	break
11899	extend new_second_item with item .	new_second_item . extend ( item )
11900	if old_style_list is true ,	if old_style_list :
11901	substitute new_second_item with second_item .	second_item = new_second_item
11902	return list with 2 elements : first_item and second_item , and old_style_list .	return [ first_item , second_item ] , old_style_list
11903	define the function _helper with 2 arguments list and tabs set to integer 1 .	def _helper ( list_ , tabs = 1 ) :
11904	indent contain tabs number of tab character .	indent = STR0 * tabs
11905	output is an empty list .	output = [ ]
11906	substitute length of list_ for list_length .	list_length = len ( list_ )
11907	i is integer 0 .	i = 0
11908	while i is smaller than list_length ,	while i < list_length :
11909	substitute i-th element of list for title .	title = list_ [ i ]
11910	sublist is an empty string .	sublist = STR
11911	sublist_item is None .	sublist_item = None
11912	if title is an instance of list or tuple ,	if isinstance ( title , ( list , tuple ) ) :
11913	substitute title for sublist_item .	sublist_item = title
11914	title is an empty string .	title = STR
11915	otherwise if i is smaller than list_length decremented by one ,	elif i < list_length - 1 :
11916	substitute ( i+1 ) -th element of list_ for next_item .	next_item = list_ [ i + 1 ]
11917	if next_item is true and next_item is an instance of list or tuple type ,	if next_item and isinstance ( next_item , ( list , tuple ) ) :
11918	substitute next_item for sublist_item .	sublist_item = next_item
11919	increment i by integer 1 .	i += 1
11920	if sublist_item is true ,	if sublist_item :
11921	call the function _helper with 2 arguments : sublist_item and tabs incremented by 1 , substitute the result for sublist .	sublist = _helper ( sublist_item , tabs + 1 )
11922	sublist is an string STR0 , where every STR1 is replaced with indent , sublist , indent and indent , respectively .	sublist = STR0 % ( indent , sublist , indent , indent )
11923	substitute every STR0 in string STR1 with indent , with result of the function escaper called with an argument : result of the function force_text called with an argument title , and with sublist , append the string to output .	output . append ( STR0 % ( indent , escaper ( force_text ( title ) ) , sublist ) )
11924	increment i by 1 .	i += 1
11925	join elements of output into a string , separated with newlines , return the result .	return STR0 . join ( output )
11926	call the function convert_old_style_list with an argument value , substitute the result for value and converted , respectively .	value , converted = convert_old_style_list ( value )
11927	call the function _helper with an argument value , use it as an argument for the call to the function mark_safe , return the result .	return mark_safe ( _helper ( value ) )
11928	decorator function register.filter with an argument is_safe set to boolean False .	@ register . filter ( is_safe = False )
11929	define the function add with 2 arguments value and arg .	def add ( value , arg ) :
11930	try ,	try :
11931	convert value and arg into a integers , return their sum .	return int ( value ) + int ( arg )
11932	if TypeError or ValueError exceptions are caught ,	except ( ValueError , TypeError ) :
11933	try ,	try :
11934	sum value and arg , return the result .	return value + arg
11935	if Exception exception is caught ,	except Exception :
11936	return an empty string .	return STR
11937	decorator function register.filter with an argument is_safe set to boolean False .	@ register . filter ( is_safe = False )
11938	define the function get_digit with 2 arguments value and arg .	def get_digit ( value , arg ) :
11939	try ,	try :
11940	convert arg to an integer .	arg = int ( arg )
11941	convert value to an integer .	value = int ( value )
11942	if ValueError exception is caught ,	except ValueError :
11943	return value .	return value
11944	if arg is smaller than integer 1 ,	if arg < 1 :
11945	return value .	return value
11946	try ,	try :
11947	convert value into a string , take character at the negative arg index , convert it into an integer , return it .	return int ( str ( value ) [ - arg ] )
11948	if IndexError exception is caught ,	except IndexError :
11949	return integer 0 .	return 0
11950	decorator function register.filter with 2 arguments expects_localtime set to boolean True and is_safe set to boolean False .	@ register . filter ( expects_localtime = True , is_safe = False )
11951	define the function date with 2 arguments value and arg set to None .	def date ( value , arg = None ) :
11952	if vale is None or an empty string ,	if value in ( None , STR ) :
11953	return an empty string .	return STR
11954	if arg is None ,	if arg is None :
11955	substitute settings.DATE_FORMAT for arg .	arg = settings . DATE_FORMAT
11956	try ,	try :
11957	call the method formats.time_format with 2 arguments : value and arg , return the result .	return formats . date_format ( value , arg )
11958	if AttributeError exception is caught ,	except AttributeError :
11959	try ,	try :
11960	format value into printable data representation with formating rules arg , return the result .	return format ( value , arg )
11961	if AttributeError exception is caught ,	except AttributeError :
11962	return an empty string .	return STR
11963	decorator function register.filter with 2 arguments expects_localtime set to boolean True and is_safe set to boolean False .	@ register . filter ( expects_localtime = True , is_safe = False )
11964	define the function time with 2 arguments value and arg set to None .	def time ( value , arg = None ) :
11965	if vale is None or an empty string ,	if value in ( None , STR ) :
11966	return an empty string .	return STR
11967	if arg is None	if arg is None :
11968	substitute settings.TIME_FORMAT for arg .	arg = settings . TIME_FORMAT
11969	try ,	try :
11970	call the method formats.time_format with 2 arguments : value and arg , return the result .	return formats . time_format ( value , arg )
11971	if AttributeError exception is caught ,	except AttributeError :
11972	try ,	try :
11973	call the function time_format with 2 arguments : value and arg , return the result .	return time_format ( value , arg )
11974	if AttributeError exception is caught ,	except AttributeError :
11975	return an empty string .	return STR
11976	decorator function register.filter with 2 arguments string STR0 and is_safe set to boolean False .	@ register . filter ( STR0 , is_safe = False )
11977	define the function timesince_filter with 2 arguments value and arg set to None .	def timesince_filter ( value , arg = None ) :
11978	if value is false ,	if not value :
11979	return an empty string .	return STR
11980	try ,	try :
11981	if arg is true ,	if arg :
11982	call the function timesince with 2 arguments : value and arg , return the result .	return timesince ( value , arg )
11983	call the function timesince with an argument value , return the result .	return timesince ( value )
11984	if TypeError or ValueError exceptions are caught ,	except ( ValueError , TypeError ) :
11985	return an empty string .	return STR
11986	decorator function register.filter with 2 arguments string STR0 and is_safe set to boolean False .	@ register . filter ( STR0 , is_safe = False )
11987	define the function timeuntil_filter with 2 arguments value and arg set to None .	def timeuntil_filter ( value , arg = None ) :
11988	if value is false ,	if not value :
11989	return an empty string .	return STR
11990	try ,	try :
11991	call the function timeuntil with 2 arguments value and arg , return the result .	return timeuntil ( value , arg )
11992	if TypeError or ValueError exceptions are caught ,	except ( ValueError , TypeError ) :
11993	return an empty string .	return STR
11994	decorator function register.filter with an argument is_safe set to boolean False .	@ register . filter ( is_safe = False )
11995	define the function default with 2 arguments value and arg .	def default ( value , arg ) :
11996	return value , if it is None return arg .	return value or arg
11997	decorator function register.filter with an argument is_safe set to boolean False .	@ register . filter ( is_safe = False )
11998	define the function default_if_none with 2 arguments value and arg .	def default_if_none ( value , arg ) :
11999	if value is None ,	if value is None :
12000	return arg .	return arg
12001	return value .	return value
12002	decorator function register.filter with an argument is_safe set to boolean False .	@ register . filter ( is_safe = False )
12003	define the function divisibleby with 2 arguments value and arg .	def divisibleby ( value , arg ) :
12004	convert value and arg to integers , if value is divisible by arg , return True , otherwise return boolean False .	return int ( value ) % int ( arg ) == 0
12005	decorator function register.filter with an argument is_safe set to boolean False .	@ register . filter ( is_safe = False )
16001	if not ,	else :
16002	call the method s.get_data , return the result .	return s . get_data ( )
16003	define the function strip_tags with an argument value .	def strip_tags ( value ) :
16004	while STR0 is contained in value and STR1 is contained in value ,	while STR0 in value and STR1 in value :
16005	call the function _strip_once with an argument value , substitute the result for new_value .	new_value = _strip_once ( value )
16006	if new_value equals value ,	if new_value == value :
16007	break from the loop execution .	break
16008	substitute new_value for value .	value = new_value
16009	return value .	return value
16010	call the function allow_lazy with an argument strip_tags , substitute the result for strip_tags .	strip_tags = allow_lazy ( strip_tags )
16011	define the function remove_tags with 2 arguments : html and tags .	def remove_tags ( html , tags ) :
16012	tags is a list containing results of the function re.escape with an argument tag , for every tag in tags split into words .	tags = [ re . escape ( tag ) for tag in tags . split ( ) ]
16013	join elements of tags into a string , separated with STR0 , format string STR1 with it , substitute the result for tags_re .	tags_re = STR0 % STR1 . join ( tags )
16014	call the function re.compile with 2 arguments : raw string STR0 formated with tags_re and re.U , substitute the result for starttag_re .	starttag_re = re . compile ( STR0 % tags_re , re . U )
16015	call the function re.compile with an argument string STR0 formated with tags_re , substitute the result for endtag_re .	endtag_re = re . compile ( STR0 % tags_re )
16016	call the function starttag_re.sub with 2 arguments : an empty string and html , substitute the result for html .	html = starttag_re . sub ( STR , html )
16017	call the function endtag_re.sub with 2 arguments : an empty string and html , substitute the result for html .	html = endtag_re . sub ( STR , html )
16018	return html .	return html
16019	call the function allow_lazy with 2 arguments : remove_tags , six.text_type , substitute the result for remove_tags .	remove_tags = allow_lazy ( remove_tags , six . text_type )
16020	define the function strip_spaces_between_tags with an argument value .	def strip_spaces_between_tags ( value ) :
16021	call the method re.sub with 3 arguments : raw string STR0 , string STR1 and result of the function force_text , called with an argument value , return the result .	return re . sub ( STR0 , STR1 , force_text ( value ) )
16022	call the function allow_lazy with 2 arguments : strip_spaces_between_tags , six.text_type , substitute the result for strip_spaces_between_tags .	strip_spaces_between_tags = allow_lazy ( strip_spaces_between_tags , six . text_type )
16023	define the function strip_entities with an argument value .	def strip_entities ( value ) :
16024	call the method re.sub with 3 arguments : raw string STR0 , empty string and result of the function force_text , called with an argument value , return the result .	return re . sub ( STR0 , STR , force_text ( value ) )
16025	call the function allow_lazy with 2 arguments : strip_entities , six.text_type , substitute the result for strip_entities .	strip_entities = allow_lazy ( strip_entities , six . text_type )
16026	define the function smart_urlquote with an argument url .	def smart_urlquote ( url ) :
16027	try ,	try :
16028	call the function urlsplit with an argument url , assign the result to scheme , netloc , path , query and fragment , respectively .	scheme , netloc , path , query , fragment = urlsplit ( url )
16029	try ,	try :
16030	call the method netloc.encode with an argument string STR0 , call the method decode on the result with an argument STR1 , substitute the result for netloc .	netloc = netloc . encode ( STR0 ) . decode ( STR1 )
16031	if UnicodeError exception is caught ,	except UnicodeError :
16032	do nothing .	pass
16033	if not ,	else :
16034	call the function urlunsplit with an argument tuple with 4 elements : scheme , netloc , path , query and fragment , substitute the result for url .	url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )
16035	if ValueError exception is caught ,	except ValueError :
16036	do nothing .	pass
16037	call the function force_str with an argument url , use the result as an argument for the call to the function unquote , substitute the result for url .	url = unquote ( force_str ( url ) )
16038	call the function quote with 2 arguments : url and safe as bytes string STR0 , substitute the result for url .	url = quote ( url , safe = STR0 )
16039	call the function force_text with an argument url , return the result .	return force_text ( url )
16040	define the function urlize with 4 arguments : text , trim_url_limit set to None , nofollow set to boolean False ,	def urlize ( text , trim_url_limit = None , nofollow = False , autoescape = False ) :
16041	define the function trim_url with 2 arguments : x and limit set to trim_url_limit .	def trim_url ( x , limit = trim_url_limit ) :
16042	if limit is None or length of x is lesser than or equal to limit ,	if limit is None or len ( x ) <= limit :
16043	return x .	return x
16044	return a string STR0 formated with elements of x up to the index equal to the maximum value between integer 0 and 3 subtracted from limit .	return STR0 % x [ : max ( 0 , limit - 3 ) ]
16045	if text is an instance of SafeData , safe_input is boolean True , otherwise is boolean False .	safe_input = isinstance ( text , SafeData )
16046	call the function force_text with an argument text , split by it word_split_re , substitute it for words .	words = word_split_re . split ( force_text ( text ) )
16047	for every i and word in enumerated iterable words ,	for i , word in enumerate ( words ) :
16048	if STR0 is contained in words or STR1 is contained in word or STR2 is contained in word ,	if STR0 in word or STR1 in word or STR2 in word :
16049	substitute empty string , word an empty string for lead , middle and trail , respectively .	lead , middle , trail = STR , word , STR
16050	for every punctuation in TRAILING_PUNCTUATION ,	for punctuation in TRAILING_PUNCTUATION :
16051	if middle ends with punctuation ,	if middle . endswith ( punctuation ) :
16052	substitute elements of middle from the beginning to the negative length of punctuation , for middle .	middle = middle [ : - len ( punctuation ) ]
16053	sum punctuation and trail , substitute the result for trail .	trail = punctuation + trail
16054	for every opening and closing in WRAPPING_PUNCTUATION ,	for opening , closing in WRAPPING_PUNCTUATION :
16055	if middle starts with opening ,	if middle . startswith ( opening ) :
16056	substitute elements of middle from length of opening index to the end , for middle .	middle = middle [ len ( opening ) : ]
16057	sum lead and opening , substitute the result for lead .	lead = lead + opening
16058	if middle ends with closing and count of occurrence of closing in middle equals count of occurrence of opening in middle incremented by one ,	if ( middle . endswith ( closing ) and middle . count ( closing ) == middle . count ( opening ) + 1 ) :
16059	substitute elements of middle from the beginning to the negative length of closing , for middle .	middle = middle [ : - len ( closing ) ]
16060	sum trail and closing , substitute the result for lead .	trail = closing + trail
16061	url is None .	url = None
16062	if nofollow is true nofollow_attr is a string STR1 , otherwise nofollow_attr is an empty string .	nofollow_attr = STR1 if nofollow else STR
16063	call the method simple_url_re.match with an argument middle , if it evaluates to true ,	if simple_url_re . match ( middle ) :
16064	call the function smart_urlquote with an argument middle , substitute the result for url .	url = smart_urlquote ( middle )
16065	otherwise if call the method simple_url_2_re.match with an argument middle evaluates to true ,	elif simple_url_2_re . match ( middle ) :
16066	call the function smart_urlquote with an argument string STR0 formated with an argument middle , substitute the result for url .	url = smart_urlquote ( STR0 % middle )
16067	otherwise if STR0 is not contained in middle and result of the function simple_email_re.match called with an argument middle ,	elif STR0 not in middle and simple_email_re . match ( middle ) :
16068	evaluates to true , split middle into two parts from the right by STR0 character , assign the resulting parts to local and domain .	local , domain = middle . rsplit ( STR0 , 1 )
16069	try ,	try :
16070	call the method domain.encode with an argument string STR0 , call the method decode on the result with an argument string STR1 , substitute the result for domain .	domain = domain . encode ( STR0 ) . decode ( STR1 )
16071	if UnicodeError exception is caught ,	except UnicodeError :
16072	skip this loop iteration .	continue
16073	url is a string STR0 formated with local and domain .	url = STR0 % ( local , domain )
16074	nofollow_attr is an empty string .	nofollow_attr = STR
16075	if url is true ,	if url :
16076	call the function trim_url with an argument middle , substitute the result for trimmed .	trimmed = trim_url ( middle )
16077	if autoescape is true and safe_input is false ,	if autoescape and not safe_input :
16078	call the function escape with an argument lead , substitute the result for lead , call the function escape with an argument trail , substitute the result for trail .	lead , trail = escape ( lead ) , escape ( trail )
16079	call the function escape with an argument url , substitute the result for url , call the function escape with an argument trimmed , substitute the result for trimmed .	url , trimmed = escape ( url ) , escape ( trimmed )
16080	middle is a string STR1 formated with url , nofollow_attr and trimmed .	middle = STR1 % ( url , nofollow_attr , trimmed )
16081	format string STR1 with lead , middle and trail , use it as an argument for the call to the function mark_safe , substitute the result for i-th element of words .	words [ i ] = mark_safe ( STR0 % ( lead , middle , trail ) )
16082	if not ,	else :
16083	if safe_input is true ,	if safe_input :
16084	call the function mark_safe with an argument word , substitute the result for i-th element of words .	words [ i ] = mark_safe ( word )
16085	otherwise if autoescape is true ,	elif autoescape :
16086	call the function escape with an argument word , substitute the result for i-th element of words .	words [ i ] = escape ( word )
16087	otherwise if safe_input is true ,	elif safe_input :
16088	call the function mark_safe with an argument word , substitute the result for i-th element of words .	words [ i ] = mark_safe ( word )
16089	otherwise if autoescape is true ,	elif autoescape :
16090	call the function escape with an argument word , substitute the result for i-th element of words .	words [ i ] = escape ( word )
16091	join elements of words into a string , return it .	return STR . join ( words )
16092	call the function allow_lazy with 2 arguments : urlize , six.text_type , substitute the result for urlize .	urlize = allow_lazy ( urlize , six . text_type )
16093	define the function avoid_wrapping with an argument value .	def avoid_wrapping ( value ) :
16094	replace every occurrence of STR in value for STR0 , return the result .	return value . replace ( STR , STR0 )
16095	from django.utils.six.moves import html_parser as _html_parse into default name space .	from django . utils . six . moves import html_parser as _html_parser
16096	import module re .	import re
16097	import module sys .	import sys
16098	substitute version_info from module sys for surrent_version .	current_version = sys . version_info
16099	set use_workaround to boolean True if current_version tuple elements are smaller than the tuple ( 2,7,3 ) , respectively , or if current_version is greater than ( 3,0 ) , but smaller than ( 3,2,3 ) , otherwise set use_workaround to boolean False .	use_workaround = ( ( current_version < ( 2 , 7 , 3 ) ) or ( current_version >= ( 3 , 0 ) and current_version < ( 3 , 2 , 3 ) ) )
16100	substitute HTMLParseError from the module _html_parser for HTMLParseError .	HTMLParseError = _html_parser . HTMLParseError
16101	if use_workaround is boolean False ,	if not use_workaround :
16102	if tuple current_version elements are greater or equal to ( 3 , 4 ) , respectively ,	if current_version >= ( 3 , 4 ) :
16103	derive the class HTMLParser from the base class HTMLParser located in the module _html_parser .	class HTMLParser ( _html_parser . HTMLParser ) :
16104	define the initialization method __init__ , with self instance of this class , convert_charrefs set to boolean False , and dictionary of arbitrary length **kwargs as arguments .	def __init__ ( self , convert_charrefs = False , ** kwargs ) :
16105	call the initialization method for the base class , _html_parser.HTMLParser.__init__ with self , convert_charrefs set to convert_charrefs and dictionary **kwargs as the arguments .	_html_parser . HTMLParser . __init__ ( self , convert_charrefs = convert_charrefs , ** kwargs )
16106	if not ,	else :
16107	substitute HTMLParser from the module _html_parser for HTMLParser .	HTMLParser = _html_parser . HTMLParser
16108	if not ,	else :
16109	compile a regular expression pattern string STR0 into a regular expression object and assign it to tagfind .	tagfind = re . compile ( STR0 )
16110	derive the class HTMLParser from the base class HTMLParser located in the module _html_parser .	class HTMLParser ( _html_parser . HTMLParser ) :
16111	define initialization method __init__ with self instance of the class as an argument .	def __init__ ( self ) :
16112	call the initialization method _html_parser.HTMLParser.__init__ ( self ) for the base class .	_html_parser . HTMLParser . __init__ ( self )
16113	set field cdata_tag for this class instance to None .	self . cdata_tag = None
16114	define method set_cdata_mode , with self class instance and tag as the arguments .	def set_cdata_mode ( self , tag ) :
16115	try ,	try :
16116	set field interesting for this class instance to interesting_cdata from module _html_parser .	self . interesting = _html_parser . interesting_cdata
16117	if AttributeError exception is caught ,	except AttributeError :
16118	replace STR0 in the string STR1 with the result of the function call tag.lower ( ) , use it and the re.I as the input arguments for function re.compile , put the result in the self.interesting .	self . interesting = re . compile ( STR0 % tag . lower ( ) , re . I )
16119	evaluate function tag.lower , without the arguments , put the result in the self.cdata_tag .	self . cdata_tag = tag . lower ( )
16120	define method clear_cdata_mode , with self class instance as an argument .	def clear_cdata_mode ( self ) :
16121	substitute _html_parser.interesting_normal for self.interesting .	self . interesting = _html_parser . interesting_normal
16122	set self.cdata_tag to None .	self . cdata_tag = None
16123	define method parse_starttag with self class instance and i as the arguments .	def parse_starttag ( self , i ) :
16124	set self.__starttag_text to None .	self . __starttag_text = None
16125	call the method self.check_for_whole_start_tag with i as an argument , substitute result for the endpos .	endpos = self . check_for_whole_start_tag ( i )
16126	if endpos is lesser than zero ,	if endpos < 0 :
16127	return endpos .	return endpos
16128	substitute self.rawdata for rawdata .	rawdata = self . rawdata
16129	slice the list from the i-th to the endpos-th element , substitute it for self.__starttag_text .	self . __starttag_text = rawdata [ i : endpos ]
16130	attrs is a empty list .	attrs = [ ]
16131	match the rawdata from the position i+1 , with tagfind pattern , assign the result to the match .	match = tagfind . match ( rawdata , i + 1 )
16132	if match evaluates to False throw an exception with the string message STR0 .	assert match , STR0
16133	find the ending position of the regular expression match of the object match , substitute the result for k .	k = match . end ( )
16134	find the first subgroup of the matched string from the match object , convert it to lowercase , substitute it for tag and self.lasttag .	self . lasttag = tag = match . group ( 1 ) . lower ( )
16135	as long k is smaller than endpos ,	while k < endpos :
16136	match the rawdata from the position k , with attrfind pattern , assign the result to the m .	m = _html_parser . attrfind . match ( rawdata , k )
16137	if m is not False , None is considered False ,	if not m :
16138	breaks from the smallest enclosing loop .	break
16139	find the first , second and third subgroup of the m regular expression match , assign the result to the attrname , rest and attrvalue , respectively .	attrname , rest , attrvalue = m . group ( 1 , 2 , 3 )
16140	if rest is not False , None is considered False ,	if not rest :
16141	set attrvalue to None .	attrvalue = None
16142	otherwise , if first and the last character of attrvalue are STRspecial charter or first and last character of attrvalue are STR character ,	elif ( attrvalue [ : 1 ] == STR == attrvalue [ - 1 : ] or attrvalue [ : 1 ] == STR == attrvalue [ - 1 : ] ) :
16143	remove first and last character from the attrvalue , substitute it for attrvalue .	attrvalue = attrvalue [ 1 : - 1 ]
16144	if attrvalue is not an empty string ,	if attrvalue :
16145	call the method unescape with attrvalue as the argument on the self class instance , substitute the result for attrvalue .	attrvalue = self . unescape ( attrvalue )
16146	form the tuple from the attrname converted to lowercase and attrvalue , append it to the end of attrs .	attrs . append ( ( attrname . lower ( ) , attrvalue ) )
16147	find the ending position of the regular expression match of the object match , substitute the result for k .	k = m . end ( )
16148	slice the rawdata string from the k-th to the endpos-th index , remove the whitespaces from the start and the end of the string , substitute it for end .	end = rawdata [ k : endpos ] . strip ( )
16149	if end is not a STR0 or STR1 character ,	if end not in ( STR0 , STR1 ) :
16150	evaluate the self.getpos ( ) and assign the result to the lineno and offset respectfully .	lineno , offset = self . getpos ( )
16151	if self.__stattag_text contains newline character ,	if STR0 in self . __starttag_text :
16152	increment the lineno by the count of the newlines in self.__starttag_text .	lineno = lineno + self . __starttag_text . count ( STR0 )
16153	find the last index of newline occurrence in self.__starttag_text , subtract it from total length of self.__starttag_text , substitute the result for offset .	offset = ( len ( self . __starttag_text ) - self . __starttag_text . rfind ( STR0 ) )
16154	if not ,	else :
16155	increment the offset by the length of self.__starttag_text .	offset = offset + len ( self . __starttag_text )
16156	slice the rawdata from k to endpos , then take the first 20 elements of the previous slice , with it replace % r in the string STR0 , call the method self.error with the resulting string as an argument .	self . error ( STR0 % ( rawdata [ k : endpos ] [ : 20 ] , ) )
16157	if string end ends with string STR0 ,	if end . endswith ( STR0 ) :
16158	call the method self.handle_startendtag with tag and attrs as the arguments .	self . handle_startendtag ( tag , attrs )
16159	if not ,	else :
16160	call the method self.handle_starttag , with tag and attrs as the arguments .	self . handle_starttag ( tag , attrs )
16161	if tag is contained in self.CDATA_CONTENT_ELEMENTS ,	if tag in self . CDATA_CONTENT_ELEMENTS :
16162	call the method self.set_cdata_mode with tag as the argument .	self . set_cdata_mode ( tag )
16163	return endpos .	return endpos
16164	define the method parse_endtag with self class instance and i as the arguments .	def parse_endtag ( self , i ) :
16165	substitute self.rawdata for rawdata .	rawdata = self . rawdata
16166	take two characters from the i-th element of rawdata , if they are not equal to the string STR1 , throw an exception with string STR0 as the message .	assert rawdata [ i : i + 2 ] == STR0 , STR1
16167	search anywhere in the rawdata string starting from the ( i+1 ) -th element for the _html_parser.endendeag , replace the result for match .	match = _html_parser . endendtag . search ( rawdata , i + 1 )
16168	if there is no match ,	if not match :
16169	return integer -1 .	return - 1
16170	find the ending position of the regular expression match of the object match , substitute the result for j .	j = match . end ( )
16171	match the rawdata from the position i , with _html_parser.endtagfind pattern , assign the result to the match .	match = _html_parser . endtagfind . match ( rawdata , i )
16172	if there is no match ,	if not match :
16173	if self.cdata_tag is not None ,	if self . cdata_tag is not None :
16174	slice the rawdata to obtain substring from i-th to j-th element , use it as the argument for the method call to the self.handle_data .	self . handle_data ( rawdata [ i : j ] )
16175	return j .	return j
16176	slice the rawdata from i-th to the j-th element , replace with it STR1 in the string STR0 , use it to call the method self.error .	self . error ( STR0 % ( rawdata [ i : j ] , ) )
16177	find the first subgroup of the matched string from the match object , strip the whitespaces from the begging and end , replace it for tag .	tag = match . group ( 1 ) . strip ( )
16178	if self.cdata_tag is not None ,	if self . cdata_tag is not None :
16179	convert tag to lowercase if it is not equal to self.cdata_tag ,	if tag . lower ( ) != self . cdata_tag :
16180	slice the rawdata to obtain substring from i-th to j-th element , use it as the argument for the method call to the self.handle_data .	self . handle_data ( rawdata [ i : j ] )
16181	return j .	return j
16182	convert tag to lowercase , use it as the argument for the call to the method self.handle_endtag .	self . handle_endtag ( tag . lower ( ) )
16183	call the method self.clear_cdata_mode .	self . clear_cdata_mode ( )
16184	return j .	return j
16185	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
16186	import module base64 .	import base64
16187	import module calendar .	import calendar
16188	import module datetime .	import datetime
16189	import module re .	import re
16190	import module sys .	import sys
16191	from binascii import Error as BinasciiError into default name space .	from binascii import Error as BinasciiError
16192	from email.utils import formatdate into default name space .	from email . utils import formatdate
16193	from django.utils.datastructures import MultiValueDict into default name space .	from django . utils . datastructures import MultiValueDict
16194	from django.utils.encoding import force_str and force_text into default name space .	from django . utils . encoding import force_str , force_text
16195	from django.utils.functional import allow_lazy into default name space .	from django . utils . functional import allow_lazy
16196	from django.utils import six into default name space .	from django . utils import six
16197	from django.utils.six.moves.urllib.parse import quote , quote_plus , unquote , unquote_plus , urlparse , urlencode as original_urlencode .	from django . utils . six . moves . urllib . parse import ( quote , quote_plus , unquote , unquote_plus , urlparse , urlencode as original_urlencode )
16198	call the function re.compile with an argument raw string STR1 , substitute the result for ETAG_MATCH .	ETAG_MATCH = re . compile ( STR1 )
16199	MONTHS is a list with 12 elements : strings STR0 , STR1 , STR2 , STR3 , STR4 , STR5 , STR6 , STR7 , STR8 , STR9 , STR10 , and STR11 .	MONTHS = STR0 . split ( )
16200	__D is a raw string STR0 .	__D = STR0
16201	__D2 is a raw string STR0 .	__D2 = STR0
16202	__M is a raw string STR0 .	__M = STR0
16203	__Y is a raw string STR0 .	__Y = STR0
16204	__Y2 is a raw string STR0 .	__Y2 = STR0
16205	__T is a raw string STR0 .	__T = STR0
16206	call the function re.compile with an argument raw string STR0 formated with __D , __M , __Y and __T , substitute the result for RFC1123_DATE .	RFC1123_DATE = re . compile ( STR0 % ( __D , __M , __Y , __T ) )
16207	call the function re.compile with an argument raw string STR0 formated with __D , __M , __Y2 and __T , substitute the result for RFC850_DATE .	RFC850_DATE = re . compile ( STR0 % ( __D , __M , __Y2 , __T ) )
16208	call the function re.compile with an argument raw string STR0 formated with __M , __D2 , __T and __Y , substitute the result for ASCTIME_DATE .	ASCTIME_DATE = re . compile ( STR0 % ( __M , __D2 , __T , __Y ) )
16209	define the function urlquote with 2 arguments : url and safe set to STR0 .	def urlquote ( url , safe = STR0 ) :
16210	call the function quote with 2 arguments : result of the function force_str called with an argument url , and result of the function force_str called with an argument safe , use the result as an argument for the call to the function force_text , return the result .	return force_text ( quote ( force_str ( url ) , force_str ( safe ) ) )
16211	call the function allow_lazy with 2 arguments : urlquote and six.text_type , substitute the result for urlquote .	urlquote = allow_lazy ( urlquote , six . text_type )
16212	define the function urlquote_plus with 2 arguments : url and safe set to an empty string .	def urlquote_plus ( url , safe = STR ) :
16213	call the function quote_plus with 2 arguments : result of the function force_str called with an argument url , and result of the function force_str called with an argument safe , use the result as an argument for the call to the function force_text , return the result .	return force_text ( quote_plus ( force_str ( url ) , force_str ( safe ) ) )
16214	call the function allow_lazy with 2 arguments : urlquote_plus and six.text_type , substitute the result for urlquote_plus .	urlquote_plus = allow_lazy ( urlquote_plus , six . text_type )
16215	define the function urlunquote with an argument quoted_url .	def urlunquote ( quoted_url ) :
16216	call the function force_str with an argument quoted_url , use the result as an argument for the call to the function unquote , use the result as an argument for the call to the function force_text , return the result .	return force_text ( unquote ( force_str ( quoted_url ) ) )
16217	call the function allow_lazy with 2 arguments : urlunquote and six.text_type , substitute the result for urlunquote .	urlunquote = allow_lazy ( urlunquote , six . text_type )
16218	define the function urlunquote with an argument quoted_url .	def urlunquote_plus ( quoted_url ) :
16219	call the function force_str with an argument quoted_url , use the result as an argument for the call to the function unquote_plus , use the result as an argument for the call to the function force_text , return the result .	return force_text ( unquote_plus ( force_str ( quoted_url ) ) )
16220	call the function allow_lazy with 2 arguments : urlunquote_plus and six.text_type , substitute the result for urlunquote_plus .	urlunquote_plus = allow_lazy ( urlunquote_plus , six . text_type )
16221	define the function urlencode with 2 arguments query and doseq set to integer 0 .	def urlencode ( query , doseq = 0 ) :
16222	if query is an instance of MultiValueDict class ,	if isinstance ( query , MultiValueDict ) :
16223	call the method query.lists , substitute the result for query .	query = query . lists ( )
16224	otherwise if query has an attribute STR0 ,	elif hasattr ( query , STR0 ) :
16225	call the method query.items , substitute the result for query .	query = query . items ( )
16226	call the function original_urlencode with 2 arguments : list with 2 elements : result of the function force_str with an argument k , and list with results of the function force_str with an argument i , for every i in v , only if v is a list or a tuple , otherwise second element is result of the function force_str with an argument v , for every k and v in query , and doseq , return the result .	return original_urlencode ( [ ( force_str ( k ) , [ force_str ( i ) for i in v ] if isinstance ( v , ( list , tuple ) ) else force_str ( v ) ) for k , v in query ] , doseq )
16227	define the function cookie_date with an argument epoch_seconds set to None .	def cookie_date ( epoch_seconds = None ) :
16228	call the function formatdate with an argument epoch_seconds , substitute the result for rfcdate .	rfcdate = formatdate ( epoch_seconds )
16229	return a string STR0 , formated with : first 7 elements of rfcdate , elements of rfcdate from 8-th to the 11-th index , and elements of rfcdate from 12-th to the 25-th index .	return STR0 % ( rfcdate [ : 7 ] , rfcdate [ 8 : 11 ] , rfcdate [ 12 : 25 ] )
16230	define the function http_date with an argument epoch_seconds set to None .	def http_date ( epoch_seconds = None ) :
16231	call the function formatdate with 2 arguments : epoch_seconds and usegmt set to boolean True , return the result .	return formatdate ( epoch_seconds , usegmt = True )
16232	define the function parse_http_date with an argument date .	def parse_http_date ( date ) :
16233	for every regex in tuple with 3 elements : RFC1123_DATE , RFC850_DATE and ASCTIME_DATE ,	for regex in RFC1123_DATE , RFC850_DATE , ASCTIME_DATE :
16234	call the method regex.match with an argument date , substitute the result for m .	m = regex . match ( date )
16235	if m is not None ,	if m is not None :
16236	break from the loop execution .	break
16237	if not ,	else :
16238	raise an ValueError exception with an argument string STR0 formated with date .	raise ValueError ( STR0 % date )
16239	try ,	try :
16240	call the method m.group with an argument string STR0 , convert the result into a string , substitute it for year .	year = int ( m . group ( STR0 ) )
16241	if year is lesser than integer 100 ,	if year < 100 :
16242	if year is lesser than integer 70 ,	if year < 70 :
16243	increment year by integer 2000 .	year += 2000
16244	if not ,	else :
16245	increment year by integer 1900 .	year += 1900
16246	call the method m.group with an argument string STR0 , convert the result to lowercase , use it as an argument for the call to the , method MONTHS.index , increment the result by integer 1 , substitute it for month .	month = MONTHS . index ( m . group ( STR0 ) . lower ( ) ) + 1
16247	call the method m.group with an argument string STR0 , convert the result into a string , substitute it for day .	day = int ( m . group ( STR0 ) )
16248	call the method m.group with an argument string STR0 , convert the result into a string , substitute it for hour .	hour = int ( m . group ( STR0 ) )
16249	call the method m.group with an argument string STR0 , convert the result into a string , substitute it for min .	min = int ( m . group ( STR0 ) )
16250	call the method m.group with an argument string STR0 , convert the result into a string , substitute it for sec .	sec = int ( m . group ( STR0 ) )
16251	call the method MONTHS.index with 6 arguments : year , month , day , hour , min and sec , substitute the result for result .	result = datetime . datetime ( year , month , day , hour , min , sec )
16252	call the method result.utctimetuple , use the result as an argument for the call to the method calendar.timegm , return the result .	return calendar . timegm ( result . utctimetuple ( ) )
16253	if Exception exception is caught .	except Exception :
16254	call the function six.reraise with 3 arguments : ValueError , instance of a class ValueError , created with an argument string , STR0 formated with date and third element of the result of the function sys.exc_info .	six . reraise ( ValueError , ValueError ( STR0 % date ) , sys . exc_info ( ) [ 2 ] )
16255	define the function parse_http_date_safe an argument date .	def parse_http_date_safe ( date ) :
16256	try ,	try :
16257	call the function parse_http_date with an argument date , return the result .	return parse_http_date ( date )
16258	if Exception exception is caught .	except Exception :
16259	do nothing .	pass
16260	define the functionbase36_to_int with an argument s .	def base36_to_int ( s ) :
16261	if length of s is greater than integer 13 ,	if len ( s ) > 13 :
16262	raise an ValueError exception with an argument string STR0 .	raise ValueError ( STR0 )
16263	convert s to integer of base 36 , substitute it for value .	value = int ( s , 36 )
16264	if six.PY2 is true and value is greater than sys.maxint ,	if six . PY2 and value > sys . maxint :
16265	raise an ValueError exception with an argument string STR0 .	raise ValueError ( STR0 )
16266	return value .	return value
16267	define the function int_to_base36 with an argument i .	def int_to_base36 ( i ) :
16268	digits is a string STR0 .	digits = STR0
16269	factor is integer 0 .	factor = 0
16270	if i is smaller than integer 0 ,	if i < 0 :
16271	raise an ValueError exception with an argument string STR0 .	raise ValueError ( STR0 )
16272	if six.PY2 is true ,	if six . PY2 :
16273	if i is not an instance of six.integer_types class ,	if not isinstance ( i , six . integer_types ) :
16274	raise an TypeError exception with an argument string STR0 .	raise TypeError ( STR0 )
16275	if i is greater than sys.maxint ,	if i > sys . maxint :
16276	raise an ValueError exception with an argument string STR0 .	raise ValueError ( STR0 )
16277	endless loop ,	while True :
16278	increment factor by one .	factor += 1
16279	bring integer 36 to the power of factor , if i is smaller than the result ,	if i < 36 ** factor :
16280	decrement factor by one .	factor -= 1
16281	break from the loop execution .	break
16282	base36 is an empty list .	base36 = [ ]
16283	while factor is greater or equal to integer 0 ,	while factor >= 0 :
16284	bring integer 36 to the power of factor , substitute the result for j .	j = 36 ** factor
16285	floor the division of i by j , use it an an index to get the element of the digits list , append the result for base36 .	base36 . append ( digits [ i // j ] )
16286	i is the reminder of the division of i by j .	i = i % j
16287	decrement factor by one .	factor -= 1
16288	join elements of base36 into a string , return it .	return STR . join ( base36 )
16289	define the function urlsafe_base64_encode with an argument s .	def urlsafe_base64_encode ( s ) :
16290	call the method base64.urlsafe_b64encode with an argument s , strip the result of the bytes string STR0 from the right , return it .	return base64 . urlsafe_b64encode ( s ) . rstrip ( STR0 )
16291	define the function urlsafe_base64_decode with an argument s .	def urlsafe_base64_decode ( s ) :
16292	call the method s.encode with an argument string STR0 , substitute the result for s .	s = s . encode ( STR0 )
16293	try ,	try :
16294	left justify string s in a field of width equal to the sum of length of s and reminder of the division of length of s by integer 4 , pad the rest of the field with bytes string STR0 , use the result as an argument for the call to the method base64.urlsafe_b64decode , return the result .	return base64 . urlsafe_b64decode ( s . ljust ( len ( s ) + len ( s ) % 4 , STR0 ) )
16295	if LookupError or BinasciiError , renamed to e , exceptions are caught .	except ( LookupError , BinasciiError ) as e :
16296	raise an ValueError exception with an argument e .	raise ValueError ( e )
16297	define the function parse_etags with an argument etag_str .	def parse_etags ( etag_str ) :
16298	call the method ETAG_MATCH.findall with an argument etag_str , substitute the result for etags .	etags = ETAG_MATCH . findall ( etag_str )
16299	if etags is false ,	if not etags :
16300	return a list with an element etag_str .	return [ etag_str ]
16301	for every e in etags call the method e.encode with an argument string STR0 , call the method decode on the result with an argument , string STR1 , substitute the list of results for etags .	etags = [ e . encode ( STR0 ) . decode ( STR1 ) for e in etags ]
16302	return etags .	return etags
16303	define the function quote_etag with an argument etag .	def quote_etag ( etag ) :
16304	return a string STR1 formated with etag , in which every occurrence of STRspecial is replaced with STR2 and every occurrence of STR , is replaced with STR3 .	return STR1 % etag . replace ( STRspecial , STR2 ) . replace ( STR , STR3 )
16305	define the function same_origin with 2 arguments url1 and url2 .	def same_origin ( url1 , url2 ) :
16306	substitute result of the function urlparse with an argument ur1 for p1 and result of the function urlparse with an argument ur2 for p2 .	p1 , p2 = urlparse ( url1 ) , urlparse ( url2 )
16307	try ,	try :
16308	if p2.scheme , p2.hostname and p2.port equals p1.scheme , p1.hostname and p1.port , respectively , return boolean True , otherwise return boolean False .	return ( p1 . scheme , p1 . hostname , p1 . port ) == ( p2 . scheme , p2 . hostname , p2 . port )
16309	if ValueError exception is caught .	except ValueError :
16310	return boolean False .	return False
16311	define the function is_safe_url with 2 arguments url and host set to None .	def is_safe_url ( url , host = None ) :
16312	if url is false ,	if not url :
16313	return boolean False .	return False
16314	replace every occurrence of STRspecial in url with STR0 .	url = url . replace ( STRspecial , STR0 )
16315	if url starts with STR0 ,	if url . startswith ( STR0 ) :
16316	return boolean False .	return False
16317	call the function urlparse with an argument url , substitute the result for url_info .	url_info = urlparse ( url )
16318	if url_info.netloc is false and url_info.scheme is true ,	if not url_info . netloc and url_info . scheme :
16319	return boolean False .	return False
16320	if url_info.netloc is false or url_info.netloc equals host , and if url_info.scheme is false or url_info.scheme equals ,	return ( ( not url_info . netloc or url_info . netloc == host ) and ( not url_info . scheme or url_info . scheme in [ STR0 , STR1 ] ) )
16321	import module warnings .	import warnings
16322	import module sys .	import sys
16323	from django.utils import six into default name space .	from django . utils import six
16324	from django.utils.deprecation import RemovedInDjango19Warning into default name space .	from django . utils . deprecation import RemovedInDjango19Warning
16325	call the function warnings.warn with 3 arguments : string STR0 , RemovedInDjango19Warning and stacklevel set to integer 2 .	warnings . warn ( STR0 , RemovedInDjango19Warning , stacklevel = 2 )
16326	define the function _resolve_name with 3 arguments : name , package and level .	def _resolve_name ( name , package , level ) :
16327	if package doesnt have an STR0 attribute ,	if not hasattr ( package , STR0 ) :
16328	raise an ValueError with an argument string STR0 .	raise ValueError ( STR0 )
16329	substitute length of package for dot .	dot = len ( package )
16330	for every x is the range of integers from level to the integer 2 , in the reversed order ,	for x in range ( level , 1 , - 1 ) :
16331	try ,	try :
16332	call the method package.rindex with 3 arguments : string STR0 , integer 0 and dot , substitute the result for dot .	dot = package . rindex ( STR0 , 0 , dot )
16333	if ValueError exception is caught ,	except ValueError :
16334	raise an ValueError with an argument string STR0 .	raise ValueError ( STR0 )
16335	return a string STR0 formated with first dot package elements and name .	return STR0 % ( package [ : dot ] , name )
16336	if six.PY3 is true ,	if six . PY3 :
16337	from importlib import import_module .	from importlib import import_module
16338	if not ,	else :
16339	define the function import_module with 3 arguments : name and package set to None .	def import_module ( name , package = None ) :
16340	if name starts with an string STR0 ,	if name . startswith ( STR0 ) :
16341	if package is false ,	if not package :
16342	raise an TypeError with an argument string STR0 .	raise TypeError ( STR0 )
16343	level is an integer 0 .	level = 0
16344	for every character in name ,	for character in name :
16345	if character is not equal to a string STR0 ,	if character != STR0 :
16346	break from the loop execution .	break
16347	increment level by one .	level += 1
16348	call the function _resolve_name with 3 arguments : name list elements from the level index to the end , package and level , substitute the result for name .	name = _resolve_name ( name [ level : ] , package , level )
16349	call the function __import__ with an argument name .	__import__ ( name )
16350	return sys.modules dictionary value under the name key .	return sys . modules [ name ]
16351	from django.core.exceptions import ValidationError into default name space .	from django . core . exceptions import ValidationError
16352	from django.utils.translation import ugettext_lazy as _ into default name space .	from django . utils . translation import ugettext_lazy as _
16353	from django.utils.six.moves import xrange into default name space .	from django . utils . six . moves import xrange
16354	define the function clean_ipv6_address with 3 arguments : ip_str , unpack_ipv4 set to boolean False and error_message ,	def clean_ipv6_address ( ip_str , unpack_ipv4 = False , error_message = _ ( STR0 ) ) :
16355	best_doublecolon_start is an integer -1 .	best_doublecolon_start = - 1
16356	best_doublecolon_len is an integer 0 .	best_doublecolon_len = 0
16357	doublecolon_start is an integer -1 .	doublecolon_start = - 1
16358	doublecolon_len is an integer 0 .	doublecolon_len = 0
16359	call he function is_valid_ipv6_address with an argument ip_str , if it evaluates to false ,	if not is_valid_ipv6_address ( ip_str ) :
16360	raise an ValidationError exception with 2 arguments : error_message and code as a string STR0 .	raise ValidationError ( error_message , code = STR0 )
16361	call the function _explode_shorthand_ip_string with an argument ip_str , substitute the result for ip_str .	ip_str = _explode_shorthand_ip_string ( ip_str )
16362	call the function _explode_shorthand_ip_string with an argument ip_str , substitute the result for ip_str .	ip_str = _sanitize_ipv4_mapping ( ip_str )
16363	if unpack_ipv4 is true ,	if unpack_ipv4 :
16364	call the function _unpack_ipv4 with an argument ip_str , substitute the result for ipv4_unpacked .	ipv4_unpacked = _unpack_ipv4 ( ip_str )
16365	if ipv4_unpacked is true ,	if ipv4_unpacked :
16366	return ipv4_unpacked .	return ipv4_unpacked
16367	split ip_str by STR0 , substitute the result for hextets .	hextets = ip_str . split ( STR0 )
16368	for every index in range of integers from 0 to length of hextets , not included ,	for index in range ( len ( hextets ) ) :
16369	get the value under the index key of the hextets dictionary , remove the leading STR0 characters , substitute the result for value under the index key of the hextets dictionary .	hextets [ index ] = hextets [ index ] . lstrip ( STR0 )
16370	get the value under the index key of the hextets dictionary , if it is false ,	if not hextets [ index ] :
16371	value under the index key of the hextets dictionary is a string STR0 .	hextets [ index ] = STR0
16372	if value under the index key of the hextets dictionary equals to string STR0 ,	if hextets [ index ] == STR0 :
16373	increment doublecolon_len by integer 1 ,	doublecolon_len += 1
16374	if doublecolon_start equals integer -1 ,	if doublecolon_start == - 1 :
16375	substitute index for doublecolon_start .	doublecolon_start = index
16376	if doublecolon_len is greater than best_doublecolon_len ,	if doublecolon_len > best_doublecolon_len :
16377	substitute doublecolon_len for best_doublecolon_len .	best_doublecolon_len = doublecolon_len
16378	substitute doublecolon_start for best_doublecolon_start .	best_doublecolon_start = doublecolon_start
16379	if not ,	else :
16380	doublecolon_len is integer 0 .	doublecolon_len = 0
16381	doublecolon_start is integer -1 .	doublecolon_start = - 1
16382	if best_doublecolon_len is greater than integer 1 ,	if best_doublecolon_len > 1 :
16383	sum best_doublecolon_start and best_doublecolon_len , substitute the result for best_doublecolon_end ,	best_doublecolon_end = ( best_doublecolon_start + best_doublecolon_len )
16384	if best_doublecolon_end equals length of hextets ,	if best_doublecolon_end == len ( hextets ) :
16385	append an empty string to list hextets .	hextets += [ STR ]
16386	replace hextets list from the best_doublecolon_start index to best_doublecolon_end index with an empty string .	hextets [ best_doublecolon_start : best_doublecolon_end ] = [ STR ]
16387	if best_doublecolon_start equals integer 0 ,	if best_doublecolon_start == 0 :
16388	prepend an empty string to hextets list .	hextets = [ STR ] + hextets
16389	join elements of hextets into a string , separated with STR0 , substitute it for result .	result = STR0 . join ( hextets )
16390	convert result to lowercase and return it .	return result . lower ( )
16391	define the function _sanitize_ipv4_mapping with an argument ip_str .	def _sanitize_ipv4_mapping ( ip_str ) :
16392	convert ip_str to lowercase , if it doesnt start with a string STR0 ,	if not ip_str . lower ( ) . startswith ( STR0 ) :
16393	return ip_str .	return ip_str
16394	split ip_str into parts by STR0 , substitute the result for hextets .	hextets = ip_str . split ( STR0 )
16395	if STR0 is contained in last elements of hextets ,	if STR0 in hextets [ - 1 ] :
16396	return ip_str .	return ip_str
16397	ipv4_address is a string STR0 formated with first 2 elements of seventh element of hextets converted into hexadecimal number , second 2 elements of seventh element of hextets converted into hexadecimal number , first 2 elements of eight element of hextets converted into hexadecimal number , second 2 elements of eight element of hextets converted into hexadecimal number .	ipv4_address = STR0 % ( int ( hextets [ 6 ] [ 0 : 2 ] , 16 ) , int ( hextets [ 6 ] [ 2 : 4 ] , 16 ) , int ( hextets [ 7 ] [ 0 : 2 ] , 16 ) , int ( hextets [ 7 ] [ 2 : 4 ] , 16 ) , )
16398	join first 5 elements of hextets into a string , separated by STR0 , substitute the result for result .	result = STR0 . join ( hextets [ 0 : 6 ] )
16399	append STR0 and ipv4_address to result .	result += STR0 + ipv4_address
16400	return result .	return result
16401	define the function _unpack_ipv4 with an argument ip_str .	def _unpack_ipv4 ( ip_str ) :
16402	convert ip_str to lowercase , if it doesnt start with a string STR0 ,	if not ip_str . lower ( ) . startswith ( STR0 ) :
16403	return None .	return None
16404	split ip_str into 2 parts from right , return second element of the result .	return ip_str . rsplit ( STR0 , 1 ) [ 1 ]
16405	define the function is_valid_ipv6_address with an argument ip_str .	def is_valid_ipv6_address ( ip_str ) :
16406	from django.core.validators import validate_ipv4_address .	from django . core . validators import validate_ipv4_address
16407	if STR0 is not contained in ip_str .	if STR0 not in ip_str :
16408	return boolean False .	return False
16409	if count of occurrence of STR0 in ip_str is greater than integer 1 ,	if ip_str . count ( STR0 ) > 1 :
16410	return boolean False .	return False
16411	if string STR0 is contained in ip_str ,	if STR0 in ip_str :
16412	return boolean False .	return False
16413	if ip_str starts with STR0 : : STR1 : , but it doesnt ends with STR2 ,	if ( ( ip_str . startswith ( STR0 ) and not ip_str . startswith ( STR1 ) ) or ( ip_str . endswith ( STR2 ) and not ip_str . endswith ( STR3 ) ) ) :
16414	return boolean False .	return False
16415	if count of occurrence of STR0 in ip_str is greater than integer 7 ,	if ip_str . count ( STR0 ) > 7 :
16416	return boolean False .	return False
16417	if STR0 is not contained in ip_str and number of occurrences of STR1 in ip_str is not equal to integer 7 ,	if STR0 not in ip_str and ip_str . count ( STR1 ) != 7 :
16418	if count of occurrence of STR0 in ip_str is not equal to integer 3 ,	if ip_str . count ( STR0 ) != 3 :
16419	return boolean False .	return False
16420	call the function _explode_shorthand_ip_string with an argument ip_str , substitute the result for ip_str .	ip_str = _explode_shorthand_ip_string ( ip_str )
16421	split ip_str into parts by STR0 , for every hextet in the result ,	for hextet in ip_str . split ( STR0 ) :
16422	if count of occurrence of STR0 in ip_str is equal to integer 3 ,	if hextet . count ( STR0 ) == 3 :
16423	split ip_str by STR0 , if last element of the result is not equal to hextet .	if not ip_str . split ( STR0 ) [ - 1 ] == hextet :
16424	return boolean False .	return False
16425	try ,	try :
16426	call the function validate_ipv4_address with an argument hextet .	validate_ipv4_address ( hextet )
16427	if ValidationError exception is caught ,	except ValidationError :
16428	return boolean False .	return False
16429	if not ,	else :
16430	try ,	try :
16431	if hextet converted to hexadecimal number is smaller than hexadecimal 0 , or hextet converted to hexadecimal number is smaller than hexadecimal FFFF ,	if int ( hextet , 16 ) < 0 or int ( hextet , 16 ) > FFFF :
16432	return boolean False .	return False
16433	if ValueError exception is caught .	except ValueError :
16434	return boolean False .	return False
16435	return boolean True .	return True
16436	define the function _explode_shorthand_ip_string with an argument ip_str .	def _explode_shorthand_ip_string ( ip_str ) :
16437	call the function _is_shorthand_ip with an argument ip_str , if it evaluates to false ,	if not _is_shorthand_ip ( ip_str ) :
16438	return ip_str .	return ip_str
16439	new_ip is an empty list ,	new_ip = [ ]
16440	split ip_str by STR0 , substitute it for hextet .	hextet = ip_str . split ( STR0 )
16441	split ip_str into parts by STR0 , if STR1 is contained in the last element of the result ,	if STR0 in ip_str . split ( STR1 ) [ - 1 ] :
16442	fill_to is an integer 7 .	fill_to = 7
16443	if not ,	else :
16444	fill_to is an integer 8 .	fill_to = 8
16445	if length of hextet is greater than integer 1 ,	if len ( hextet ) > 1 :
16446	split first and second element of hextet into parts by STR0 , sum their lengths , substitute the result for sep .	sep = len ( hextet [ 0 ] . split ( STR0 ) ) + len ( hextet [ 1 ] . split ( STR1 ) )
16447	split first element of hextet into parts by STR0 , append them to new_ip .	new_ip = hextet [ 0 ] . split ( STR0 )
16448	for every __ in range of integers from 0 up to sep subtracted from fill_to ,	for __ in xrange ( fill_to - sep ) :
16449	append string STR0 to new_ip .	new_ip . append ( STR0 )
16450	split second element of hextet into parts by STR0 , append them to new_ip .	new_ip += hextet [ 1 ] . split ( STR0 )
16451	if not ,	else :
16452	split ip_str into parts by STR0 , substitute the result for new_ip .	new_ip = ip_str . split ( STR0 )
16453	ret_ip is an empty list .	ret_ip = [ ]
16454	for every hextet in new_ip ,	for hextet in new_ip :
16455	subtract length of hextet from 4 , create a string with previous result number of character STR0 , append hextet to it , convert the result into a lowercase , append it to ret_ip .	ret_ip . append ( ( STR0 * ( 4 - len ( hextet ) ) + hextet ) . lower ( ) )
16456	join elements of ret_ip into a string separated with STR0 , return it .	return STR0 . join ( ret_ip )
16457	define the function _is_shorthand_ip with an argument ip_str .	def _is_shorthand_ip ( ip_str ) :
16458	if count of occurrence of STR0 in ip_str equals integer 1 ,	if ip_str . count ( STR0 ) == 1 :
16459	return boolean True .	return True
16460	split ip_str into parts by STR0 , for every x in the result , calculate length of x , if any is smaller than integer 4 ,	if any ( len ( x ) < 4 for x in ip_str . split ( STR0 ) ) :
16461	return boolean True .	return True
16462	return boolean False .	return False
16463	define the function is_iterable with an argument x .	def is_iterable ( x ) :
16464	try ,	try :
16465	create an iterator out of x .	iter ( x )
16466	if TypeError exception is caught ,	except TypeError :
16467	return boolean False .	return False
16468	if not ,	else :
16469	return boolean True .	return True
16470	import module re .	import re
16471	derive the class Tok from the object base class .	class Tok ( object ) :
16472	num is an integer 0 .	num = 0
16473	define the method __init__ with 4 arguments : self , name , regex and next set to None .	def __init__ ( self , name , regex , next = None ) :
16474	substitute Tok.num for self.id .	self . id = Tok . num
16475	increment Tok.num with an integer 1 .	Tok . num += 1
16476	substitute name for self.name .	self . name = name
16477	substitute regex for self.regex .	self . regex = regex
16478	substitute next for self.next .	self . next = next
16479	define the function literals with 3 arguments : choices , prefix set to an empty string and suffix set to an empty string .	def literals ( choices , prefix = STR , suffix = STR ) :
16480	for every c in choices split into words , concatenate prefix , result of the function re.escape with an argument c and suffix , and join the results into a string , separated with STR0 character , return the result .	return STR0 . join ( prefix + re . escape ( c ) + suffix for c in choices . split ( ) )
16481	derive the class Lexer from the object base class .	class Lexer ( object ) :
16482	define the method __init__ with 3 arguments self , states and first .	def __init__ ( self , states , first ) :
16483	self.regexes is an empty dictionary .	self . regexes = { }
16484	self.tokens is an empty dictionary .	self . toks = { }
16485	call the method states.items , for every state and rules in the result ,	for state , rules in states . items ( ) :
16486	parts is an empty list .	parts = [ ]
16487	for every tok in rules ,	for tok in rules :
16488	groupid is a string STR0 formated with tok.id .	groupid = STR0 % tok . id
16489	substitute tok for value under the groupid key of the self.toks dictionary .	self . toks [ groupid ] = tok
16490	format a string STR0 with groupid and tok.regex , append it to the parts .	parts . append ( STR0 % ( groupid , tok . regex ) )
16491	call the function re.compile with 2 arguments : elements of parts joined into a string , separated with STR0 , and result of bitwise OR performed on 2 operands : re.MULTILINE and re.VERBOSE , substitute the result for value under the state key of the self.regexes dictionary .	self . regexes [ state ] = re . compile ( STR0 . join ( parts ) , re . MULTILINE | re . VERBOSE )
16492	substitute first for self.state .	self . state = first
16493	define the method lex with 2 arguments self and text .	def lex ( self , text ) :
16494	substitute length of text for end .	end = len ( text )
16495	substitute self.state for state .	state = self . state
16496	substitute self.regexes for regexes .	regexes = self . regexes
16497	substitute self.toks for toks .	toks = self . toks
16498	start is an integer 0 .	start = 0
16499	while start is lesser than end .	while start < end :
16500	get the value under the state key of the regexes dictionary , call the method finditer on the result with 2 arguments : text and start ,	for match in regexes [ state ] . finditer ( text , start ) :
16501	for every match in the result , substitute match.lastgroup for name .	name = match . lastgroup
16502	substitute value under the name key of the toks dictionary for tok .	tok = toks [ name ]
16503	call the method match.group with an arugument name , substitute the result for toktext .	toktext = match . group ( name )
16504	increment start by length of toktext .	start += len ( toktext )
16505	yield a tuple with 2 elements : tok.name and toktext .	yield ( tok . name , toktext )
16506	if tok.next is true ,	if tok . next :
16507	substitute tok.next for state .	state = tok . next
16508	break from the loop execution .	break
16509	substitute state for self.state .	self . state = state
16510	derive the class JsLexer from the Lexer base class .	class JsLexer ( Lexer ) :
16511	both_before is a list containing 14 elements , all of them are instances of Tok class , created with 2 arguments , a string and a raw string .	both_before = [ Tok ( STR4 , STR5 ) , Tok ( STR6 , STR7 ) , Tok ( STR8 , STR9 ) , Tok ( STR10 , literals ( STR0 , suffix = STR11 ) , next = STR31 ) , Tok ( STR12 , literals ( STR13 , suffix = STR14 ) , next = STR32 ) , Tok ( STR15 , STR1 , next = STR33 ) , Tok ( STR16 , STR17 , next = STR34 ) , Tok ( STR18 , STR19 ) , Tok ( STR20 , STR2 , next = STR35 ) , Tok ( STR21 , literals ( STR3 ) , next = STR22 ) , Tok ( STR23 , literals ( STR24 ) , next = STR36 ) , Tok ( STR25 , literals ( STR26 ) , next = STR37 ) , Tok ( STR27 , literals ( STR39 ) , next = STR40 ) , ]
16512	both_after is an list with an element instance of Tok class , created with 2 arguments : string STR0 and raw string STR1 .	both_after = [ Tok ( STR0 , STR1 ) , ]
16513	states is a dictionary with 2 arguments : appended list with an element instance of a class Tok , created with 3 arguments : STR0 , result of the function literals called with an argument string STR1 and next as a string STR3 , to the both_before , appended both_after to the previous result , for STR4 and appended list with an element instance of a class Tok , created with 3 arguments : string STR2 , raw string STR5 , and next as a string STR6 , to the both_before , appended both_after to the previous result for STR7 .	states = { STR4 : both_before + [ Tok ( STR1 , literals ( STR2 ) , next = STR5 ) , ] + both_after , STR6 : both_before + [ Tok ( STR3 , STR0 , next = STR7 ) , ] + both_after , }
16514	define the method __init__ with an argument self .	def __init__ ( self ) :
16515	call the method __init__ with 2 arguments : self.states and string STR0 from the base class of the class JsLexer .	super ( JsLexer , self ) . __init__ ( self . states , STR0 )
16516	define the function prepare_js_for_gettext with an argument js .	def prepare_js_for_gettext ( js ) :
16517	define the function escape_quotes with an argument m .	def escape_quotes ( m ) :
16518	call the method m.group with an argument integer 0 , substitute the result for s .	s = m . group ( 0 )
16519	if s equals a string STR ,	if s == STR :
16520	return an raw string STR .	return STR 
16521	if not ,	else :
16522	return s .	return s
16523	lexer is an instance of JsLexer class .	lexer = JsLexer ( )
16524	c is an empty list .	c = [ ]
16525	call the method lexer.lex with an arguments js , for every name and tok in the result ,	for name , tok in lexer . lex ( js ) :
16526	if name equals a string STR0 ,	if name == STR0 :
16527	tok is a string STR1 ,	tok = STR1
16528	otherwise if name starts with a string STR0 ,	elif name == STR0 :
16529	if tok starts with STR ,	if tok . startswith ( STR ) :
16530	call the function re.sub with 3 arguments : raw string STR0 , escape_quotes and tok without the first and last element , substitute the result for guts .	guts = re . sub ( STR0 , escape_quotes , tok [ 1 : - 1 ] )
16531	concatenate string STR , guts and string STR , substitute the result for tok .	tok = STR + guts + STR
16532	otherwise if name equals a string STR0 .	elif name == STR0 :
16533	replace every occurrence of STRspecial in tok with STR0 , substitute the result for tok .	tok = tok . replace ( STR0 , STR1 )
16534	append tok to c .	c . append ( tok )
16535	join elements of c into a string , return it .	return STR . join ( c )
16536	import module logging .	import logging
16537	import module sys .	import sys
16538	import module warnings .	import warnings
16539	from django.conf import settings into default name space .	from django . conf import settings
16540	from django.core import mail into default name space .	from django . core import mail
16541	from django.core.mail import get_connection into default name space .	from django . core . mail import get_connection
16542	from django.utils.deprecation import RemovedInNextVersionWarning into default name space .	from django . utils . deprecation import RemovedInNextVersionWarning
16543	from django.utils.module_loading import import_string into default name space .	from django . utils . module_loading import import_string
16544	from django.views.debug import ExceptionReporter and get_exception_reporter_filter into default name space .	from django . views . debug import ExceptionReporter , get_exception_reporter_filter
16545	from logging import NullHandler .	from logging import NullHandler
16546	from logging.config import dictConfig .	from logging . config import dictConfig
16547	substitute logging.getLogger for getLogger .	getLogger = logging . getLogger
16548	DEFAULT_LOGGING is a dictionary with 5 initial entries : 1 for STR0 , False for STR1 , and 3 additional pairs of dictionaries for string .	DEFAULT_LOGGING = { STR0 : 1 , STR1 : False , STR2 : { STR3 : { STR4 : STR5 , } , STR6 : { STR7 : STR8 , } , } , STR9 : { STR10 : { STR11 : STR12 , STR13 : [ STR14 ] , STR15 : STR16 , } , STR17 : { STR18 : STR19 , } , STR20 : { STR21 : STR22 , STR23 : [ STR24 ] , STR25 : STR26 } } , STR27 : { STR28 : { STR29 : [ STR30 ] , } , STR31 : { STR32 : [ STR33 ] , STR34 : STR35 , STR36 : False , } , STR37 : { STR38 : [ STR39 ] , STR40 : STR41 , STR42 : False , } , STR43 : { STR44 : [ STR45 ] , } , } }
16549	define the function configure_logging with 2 arguments : logging_config and logging_settings .	def configure_logging ( logging_config , logging_settings ) :
16550	if sys.warnoptions is false ,	if not sys . warnoptions :
16551	call the method logging.captureWarnings with an argument boolean True .	logging . captureWarnings ( True )
16552	call the function warnings.simplefilter with 2 arguments : string STR0 and RemovedInNextVersionWarning .	warnings . simplefilter ( STR0 , RemovedInNextVersionWarning )
16553	if logging_config is true ,	if logging_config :
16554	call the function import_string with an argument logging_config , substitute the result for logging_config_func .	logging_config_func = import_string ( logging_config )
16555	call the function logging_config_func with an argument DEFAULT_LOGGING .	logging_config_func ( DEFAULT_LOGGING )
16556	if logging_settings is true ,	if logging_settings :
16557	call the function logging_config_func with an argument logging_settings .	logging_config_func ( logging_settings )
16558	derive the class AdminEmailHandler from logging.Handler base class .	class AdminEmailHandler ( logging . Handler ) :
16559	define the method __init__ with 3 arguments : self , include_html set to boolean False and email_backend set to None .	def __init__ ( self , include_html = False , email_backend = None ) :
16560	call the method logging.Handler.__init__ with an argument self .	logging . Handler . __init__ ( self )
16561	substitute include_html for self.include_html .	self . include_html = include_html
16562	substitute email_backend for self.email_backend .	self . email_backend = email_backend
16563	define the method emit with 2 arguments : self and record .	def emit ( self , record ) :
16564	try ,	try :
16565	substitute record.request for request .	request = record . request
16566	subject is an string STR0 , formated with record.levelname , string STR1 if value under the STR2 key , of the request.META dictionary is contained in settings.INTERNAL_IPS , otherwise use string STR3 , and result of the method record.getMessage .	subject = STR0 % ( record . levelname , ( STR1 if request . META . get ( STR2 ) in settings . INTERNAL_IPS else STR3 ) , record . getMessage ( ) )
16567	call the function get_exception_reporter_filter with an argument request , substitute the result for filter .	filter = get_exception_reporter_filter ( request )
16568	call the method filter.get_request_repr with an argument request , format string STR0 with the result , substitute the result for request_repr .	request_repr = STR0 . format ( filter . get_request_repr ( request ) )
16569	if Exception exception is caught ,	except Exception :
16570	subject is an string STR0 formated with record.levelname and result of the method record.getMessage , respectively .	subject = STR0 % ( record . levelname , record . getMessage ( ) )
16571	request is None .	request = None
16572	request_repr is a string STR0 .	request_repr = STR0
16573	call the function self.format_subject with an argument subject , substitute the result for subject .	subject = self . format_subject ( subject )
16574	if record.exc_info is true ,	if record . exc_info :
16575	substitute record.exc_info for exc_info .	exc_info = record . exc_info
16576	if not ,	else :
16577	exc_info is an tuple with 3 elements : None , result of method record.getMessage and None .	exc_info = ( None , record . getMessage ( ) , None )
16578	message is an string STR0 formated with the result of the metod self.format with an argument record , and request_repr , respectively .	message = STR0 % ( self . format ( record ) , request_repr )
16579	reporter is an instance of ExceptionReporter class , created with 3 arguments : request , is_email as boolean True , unpacked list exc_info .	reporter = ExceptionReporter ( request , is_email = True , * exc_info )
16580	if self.include_html is true , call the method reporter.get_traceback_html and substitute the result for html_message , otherwise html_message is None .	html_message = reporter . get_traceback_html ( ) if self . include_html else None
16581	call the method mail.mail_admins with 5 arguments : subject , message , fail_silently as boolean True , tml_message as html_message , and connection as the result of the method self.connection .	mail . mail_admins ( subject , message , fail_silently = True , html_message = html_message , connection = self . connection ( ) )
16582	define the connection with an argument self .	def connection ( self ) :
16583	call the function get_connection with 2 arguments : backend set to self.email_backend and fail_silently set to boolean True .	return get_connection ( backend = self . email_backend , fail_silently = True )
16584	define the method format_subject with 2 arguments : self and subject .	def format_subject ( self , subject ) :
16585	replace every occurrence of STR0 in subject with STR1 and replace every occurrence of STRspecial in subject with STR2 , substitute the result for formatted_subject .	formatted_subject = subject . replace ( STR0 , STR1 ) . replace ( STRspecial , STR2 )
16586	return first 989 elements of formatted_subject .	return formatted_subject [ : 989 ]
16587	derive the class CallbackFilter from logging.Filter base class .	class CallbackFilter ( logging . Filter ) :
16588	define the method __init__ with 2 arguments : self and callback .	def __init__ ( self , callback ) :
16589	substitute callback for self.callback .	self . callback = callback
16590	define the method filter with 2 arguments : self and record .	def filter ( self , record ) :
16591	call the method self.callback with an argument record , if the result evaluates to true ,	if self . callback ( record ) :
16592	return integer 1 .	return 1
16593	return integer 0 .	return 0
16594	derive the class RequireDebugFalse from logging.Filter base class .	class RequireDebugFalse ( logging . Filter ) :
16595	define the method filter with 2 arguments : self and record .	def filter ( self , record ) :
16596	if settings.DEBUG is true , return boolean False , otherwise return boolean True .	return not settings . DEBUG
16597	derive the class RequireDebugTrue from logging.Filter base class .	class RequireDebugTrue ( logging . Filter ) :
16598	define the method filter with 2 arguments : self and record .	def filter ( self , record ) :
16599	return settings.DEBUG .	return settings . DEBUG
16600	try ,	try :
16601	from functools import lru_cache .	from functools import lru_cache
16602	if ImportError exception is caught .	except ImportError :
16603	from collections import namedtuple .	from collections import namedtuple
16604	from functools import update_wrapper .	from functools import update_wrapper
16605	from threading import RLock .	from threading import RLock
16606	_CacheInfo is an instance of namedtuple class created with 2 arguments : string STR0 and a list with 4 elements : string STR4 , STR1 , STR2 and STR3 .	_CacheInfo = namedtuple ( STR0 , [ STR1 , STR2 , STR3 , STR4 ] )
16607	derive class _HashedSeq from list base class .	class _HashedSeq ( list ) :
16608	__slots__ is a string STR0 .	__slots__ = STR0
16609	define the method __init__ with 3 arguments : self , tup and hash set to hash .	def __init__ ( self , tup , hash = hash ) :
16610	substitute tup for elements of self .	self [ : ] = tup
16611	get the hash value of the tup , substitute it for self.hashvalue .	self . hashvalue = hash ( tup )
16612	define the method __hash__ with an argument self .	def __hash__ ( self ) :
16613	return self.hashvalue .	return self . hashvalue
16614	define the function _make_key with 9 arguments : args , kwds , typed , kwd_mark as a tuple with an element result of the function object ,	def _make_key ( args , kwds , typed , kwd_mark = ( object ( ) , ) , fasttypes = { int , str , frozenset , type ( None ) } , sorted = sorted , tuple = tuple , type = type , len = len ) :
16615	substitute args for key .	key = args
16616	if kwds is true ,	if kwds :
16617	sort elements of kwds , substitute the result for sorted_items .	sorted_items = sorted ( kwds . items ( ) )
16618	increment key by kwd_mark .	key += kwd_mark
16619	for every item in sorted_items ,	for item in sorted_items :
16620	increment key by item .	key += item
16621	if typed is true ,	if typed :
16622	create a tuple out of types of v , for every v in args , extend key tuple with the result .	key += tuple ( type ( v ) for v in args )
16623	if kwds is true ,	if kwds :
16624	create a tuple out of types of v , for every k and v in sorted_items , extend key tuple with the result .	key += tuple ( type ( v ) for k , v in sorted_items )
16625	otherwise if length of key equals integer 1 and type of first element of key is contained in fasttypes ,	elif len ( key ) == 1 and type ( key [ 0 ] ) in fasttypes :
16626	return first element of key .	return key [ 0 ]
16627	return instance of _HashedSeq class , created with an argument key .	return _HashedSeq ( key )
16628	define the function lru_cache with 2 arguments maxsize set to integer 100 and typed set to boolean False .	def lru_cache ( maxsize = 100 , typed = False ) :
16629	define the function decorating_function with an argument user_function .	def decorating_function ( user_function ) :
16630	cache is an empty dictionary .	cache = dict ( )
16631	stats is an list with 2 elements : 2 integers 0 .	stats = [ 0 , 0 ]
16632	HITS and MISSES are integer 0 and 1 , respectively .	HITS , MISSES = 0 , 1
16633	substitute _make_key for make_key .	make_key = _make_key
16634	substitute cache.get for cache_get .	cache_get = cache . get
16635	substitute len for _len .	_len = len
16636	lock is an instance of RLock class .	lock = RLock ( )
16637	root is an empty list .	root = [ ]
16638	root is a list with elements : root , root , None and None .	root [ : ] = [ root , root , None , None ]
16639	nonlocal_root is an list with an element root .	nonlocal_root = [ root ]
16640	substitute integers 0 , 1 , 2 and 3 for PREV , NEXT , KEY and RESULT , respectivley .	PREV , NEXT , KEY , RESULT = 0 , 1 , 2 , 3
16641	if maxsize equals integer 0 ,	if maxsize == 0 :
16642	define the function wrapper with 2 arguments : unpacked list args and unpacked dictionary kwds .	def wrapper ( * args , ** kwds ) :
16643	call the function user_function with 2 arguments : unpacked list args and unpacked dictionary kwds , substitute the result for result .	result = user_function ( * args , ** kwds )
16644	increment stats dictionary value under the MISSES key by integer 1 .	stats [ MISSES ] += 1
16645	return result .	return result
16646	otherwise if maxsize is None ,	elif maxsize is None :
16647	define the function wrapper with 2 arguments : unpacked list args and unpacked dictionary kwds .	def wrapper ( * args , ** kwds ) :
16648	call the function make_key with 3 arguments : args , kwds and typed , substitute the result for key .	key = make_key ( args , kwds , typed )
16649	call the function cache_get with 2 arguments : key and root , substitute the result for result .	result = cache_get ( key , root )
16650	if result is not root ,	if result is not root :
16651	increment stats dictionary value under the HITS key by integer 1 .	stats [ HITS ] += 1
16652	return result .	return result
16653	call the function user_function with 2 arguments unpacked list args and unpacked dictionary kwds , substitute the result for result .	result = user_function ( * args , ** kwds )
16654	substitute result for cache dictionary value under the key key .	cache [ key ] = result
16655	increment stats dictionary value under the MISSES key by integer 1 .	stats [ MISSES ] += 1
16656	return result .	return result
16657	if not ,	else :
16658	define the function wrapper with 2 arguments : unpacked list args and unpacked dictionary kwds .	def wrapper ( * args , ** kwds ) :
16659	if kwds is true or typed is true , call the function make_key with 3 arguments : args , kwds and typed , substitute the result for key , otherwise substitute args for key .	key = make_key ( args , kwds , typed ) if kwds or typed else args
16660	with lock ,	with lock :
16661	call the function cache_get with an argument key , substitute the result for link .	link = cache_get ( key )
16662	if link is not None ,	if link is not None :
16663	substitute nonlocal_root for a tuple with an element root .	root , = nonlocal_root
16664	substitute link for link_prev , link_next , key and result , respectively .	link_prev , link_next , key , result = link
16665	substitute link_next for value under the NEXT key of the link_prev dictionary .	link_prev [ NEXT ] = link_next
16666	substitute link_prev for value under the PREV key of the link_next dictionary .	link_next [ PREV ] = link_prev
16667	substitute value under the PREV key of the root dictionary for last .	last = root [ PREV ]
16668	substitute link for values under the NEXT key of the last dictionary and PREV key of the root dictionary .	last [ NEXT ] = root [ PREV ] = link
16669	substitute last for value under the PREV key of the link dictionary .	link [ PREV ] = last
16670	substitute root for value under the NEXT key of the link dictionary .	link [ NEXT ] = root
16671	increment stats dictionary value under the HITS key by integer 1 .	stats [ HITS ] += 1
16672	return result .	return result
16673	call the function user_function with 2 arguments : unpacked list args and unpacked dictionary kwds , substitute the result for result .	result = user_function ( * args , ** kwds )
16674	with lock ,	with lock :
16675	substitute nonlocal_root for tuple root .	root , = nonlocal_root
16676	if key is contained in cache ,	if key in cache :
16677	do nothing .	pass
16678	otherwise if result of the call to the function _len with an argument cache is greater than or equal to maxsize ,	elif _len ( cache ) >= maxsize :
16679	substitute root for oldroot .	oldroot = root
16680	substitute key for value under the KEY key of the oldroot dictionary .	oldroot [ KEY ] = key
16681	substitute result for value under the RESULT key of the oldroot dictionary .	oldroot [ RESULT ] = result
16682	substitute value under the NEXT key of the oldroot dictionary for root and first element of nonlocal_root .	root = nonlocal_root [ 0 ] = oldroot [ NEXT ]
16683	substitute value under the KEY key of the root dictionary for oldkey .	oldkey = root [ KEY ]
16684	substitute value under the RESULT key of the root dictionary for oldvalue .	oldvalue = root [ RESULT ]
16685	root dictionary values under the KEY and RESULT keys are both None .	root [ KEY ] = root [ RESULT ] = None
16686	delete entry under the oldkey key of the cache dictionary .	del cache [ oldkey ]
16687	substitute oldroot for value under the key key of the cache dictionary .	cache [ key ] = oldroot
16688	if not ,	else :
16689	substitute value under the PREV key of the root dictionary for last .	last = root [ PREV ]
16690	link is a list with 4 elements : last , root , key and result .	link = [ last , root , key , result ]
16691	substitute link for value under the NEXT key of the last dictionary , for value under the PREV key of the root dictionary , for value under the key key of the cache dictionary .	last [ NEXT ] = root [ PREV ] = cache [ key ] = link
16692	increment stats dictionary value under the MISSES key by integer 1 .	stats [ MISSES ] += 1
16693	return result .	return result
16694	define the function cache_info .	def cache_info ( ) :
16695	with lock ,	with lock :
16696	return an instance of _CacheInfo class , created with 4 arguments : value under the HITS key of the stats dictionary , value under the MISSES key of the stats dictionary , maxsize and length of cache .	return _CacheInfo ( stats [ HITS ] , stats [ MISSES ] , maxsize , len ( cache ) )
16697	define the function cache_clear .	def cache_clear ( ) :
16698	with lock ,	with lock :
16699	call the method cache.clear .	cache . clear ( )
16700	substitute first element of nonlocal_root for root .	root = nonlocal_root [ 0 ]
16701	root is an list with 4 elements : root , root , None and None .	root [ : ] = [ root , root , None , None ]
16702	stats is a list with 2 elements : 2 integers 0 .	stats [ : ] = [ 0 , 0 ]
16703	substitute user_function for wrapper.__wrapped__ .	wrapper . __wrapped__ = user_function
16704	substitute cache_info for wrapper.cache_info .	wrapper . cache_info = cache_info
16705	substitute cache_clear for wrapper.cache_clear .	wrapper . cache_clear = cache_clear
16706	call the function update_wrapper with 2 arguments : wrapper and user_function , return the result .	return update_wrapper ( wrapper , user_function )
16707	return decorating_function .	return decorating_function
16708	from __future__ import absolute_import into default name space .	from __future__ import absolute_import
16709	import module copy .	import copy
16710	from importlib import import_module into default name space .	from importlib import import_module
16711	import module os .	import os
16712	import module sys .	import sys
16713	import module warnings .	import warnings
16714	from django.core.exceptions import ImproperlyConfigured into default name space .	from django . core . exceptions import ImproperlyConfigured
16715	from django.utils import six into default name space .	from django . utils import six
16716	from django.utils.deprecation import RemovedInDjango19Warning into default name space .	from django . utils . deprecation import RemovedInDjango19Warning
16717	define the function import_string with an argument dotted_path .	def import_string ( dotted_path ) :
16718	try ,	try :
16719	split dotted_path into two parts from the right at the STR0 character , assign the result to module_path and class_name , respectively .	module_path , class_name = dotted_path . rsplit ( STR0 , 1 )
16720	if ValueError exception is caught ,	except ValueError :
16721	msg is a string STR0 formated with dotted_path .	msg = STR0 % dotted_path
16722	call the function six.reraise with 3 arguments : ImportError , instance of ImportError class created with an argument msg , and third element of result of the function sys.exc_info .	six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )
16723	call the function import_module with an argument module_path , substitute the result for module .	module = import_module ( module_path )
16724	try ,	try :
16725	get attribute class_name form the module object , return it .	return getattr ( module , class_name )
16726	if AttributeError exception is caught ,	except AttributeError :
16727	msg is a string STR2 formated with dotted_path and class_name , respectively .	msg = STR2 % ( dotted_path , class_name )
16728	call the function six.reraise with 3 arguments : ImportError , instance of ImportError class created with an argument msg , and third element of result of the function sys.exc_info .	six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )
16729	define the function import_by_path with 2 arguments dotted_path and error_prefix set to an empty string..	def import_by_path ( dotted_path , error_prefix = STR ) :
16730	call the function warnings.warn with 3 arguments : string STR0 , RemovedInDjango19Warning and stacklevel as integer 2 .	warnings . warn ( STR0 , RemovedInDjango19Warning , stacklevel = 2 )
16731	try ,	try :
16732	call the function import_string with an argument dotted_path , substitute the result for attr .	attr = import_string ( dotted_path )
16733	if ImportError , renamed to e , exception is caught ,	except ImportError as e :
16734	msg is a string STR1 , where STR2 is replaced with error_prefix , dotted_path and e , respectively .	msg = STR1 % ( error_prefix , dotted_path , e )
16735	call the function six.reraise with 3 arguments : ImproperlyConfigured , instance of ImproperlyConfigured class created with msg , and third element of the function sys.exc_info result .	six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) , sys . exc_info ( ) [ 2 ] )
16736	return attr .	return attr
16737	define the function autodiscover_modules with 2 arguments unpacked list args and unpacked dictionary kwargs .	def autodiscover_modules ( * args , ** kwargs ) :
16738	from django.apps import apps .	from django . apps import apps
16739	get value under the STR0 key of the kwargs dictionary , substitute it for register_to .	register_to = kwargs . get ( STR0 )
16740	call the method apps.get_app_configs , for every app_config in the result ,	for app_config in apps . get_app_configs ( ) :
16741	try ,	try :
16742	if register_to is true ,	if register_to :
16743	call the method copy.copy with an argument register_to._registry , substitute the result for before_import_registry .	before_import_registry = copy . copy ( register_to . _registry )
16744	for every module_to_search in args ,	for module_to_search in args :
16745	call the function import_module with an argument string STR0 , where STR1 is replaced with app_config.name and module_to_search .	import_module ( STR0 % ( app_config . name , module_to_search ) )
16746	is exception is caught ,	except :
16747	if register_to is true ,	if register_to :
16748	substitute before_import_registry for register_to._registry .	register_to . _registry = before_import_registry
16749	if call to the function module_has_submodule with 2 arguments : app_config.module and module_to_search evaluates to true ,	if module_has_submodule ( app_config . module , module_to_search ) :
16750	raise an exception ,	raise
16751	if first and second element of sys.version_info are both equal to integer 3 ,	if sys . version_info [ : 2 ] >= ( 3 , 3 ) :
16752	if first and second element of sys.version_info are equal to integers 3 and 4 , respectively ,	if sys . version_info [ : 2 ] >= ( 3 , 4 ) :
16753	from importlib.util import find_spec as importlib_find .	from importlib . util import find_spec as importlib_find
16754	if not ,	else :
16755	from importlib import find_loader as importlib_find .	from importlib import find_loader as importlib_find
16756	define the function module_has_submodule with 2 arguments : package and module_name .	def module_has_submodule ( package , module_name ) :
16757	try ,	try :
16758	substitute package.__name__ for package_name .	package_name = package . __name__
16759	substitute package.__path__ for package_path .	package_path = package . __path__
16760	if AttributeError exception is caught ,	except AttributeError :
16761	return boolean False .	return False
16762	concatenate package_name , string STR0 and module_name , substitute it for full_module_name .	full_module_name = package_name + STR0 + module_name
16763	call the function importlib_find with 2 arguments : full_module_name and package_path , if the result is not None , return boolean True , otherwise return boolean False .	return importlib_find ( full_module_name , package_path ) is not None
16764	if not ,	else :
16765	import imp .	import imp
16766	define the function module_has_submodule with 2 arguments : package and module_name .	def module_has_submodule ( package , module_name ) :
16767	join package.__name__ and module_name into a string separated with STR0 , substitute it for name .	name = STR0 . join ( [ package . __name__ , module_name ] )
16768	try ,	try :
16769	if value under the name key of the sys.modules dictionary is not None , return boolean True , otherwise return boolean False .	return sys . modules [ name ] is not None
16770	if KeyError exception is caught ,	except KeyError :
16771	do nothing .	pass
16772	try ,	try :
16773	substitute package.__path__ for package_path .	package_path = package . __path__
16774	if AttributeError exception is caught ,	except AttributeError :
16775	return boolean False .	return False
16776	for every finder in sys.meta_path ,	for finder in sys . meta_path :
16777	if call to the method finder.find_module with 2 arguments : name and package_path evaluates to true ,	if finder . find_module ( name , package_path ) :
16778	return boolean True .	return True
16779	for every entry in package_path ,	for entry in package_path :
16780	try ,	try :
16781	substitute the value under the entry key of the sys.path_importer_cache dictionary for finder .	finder = sys . path_importer_cache [ entry ]
16782	if finder is None ,	if finder is None :
16783	try ,	try :
16784	call the method imp.find_module with 2 arguments : module_name and list containing element entry , assign the result to file_ , _ , and _ , respectively .	file_ , _ , _ = imp . find_module ( module_name , [ entry ] )
16785	if file_ is true ,	if file_ :
16786	close file_ file descriptor .	file_ . close ( )
16787	return boolean True .	return True
16788	if ImportError exception is caught ,	except ImportError :
16789	skip this loop iteration ,	continue
16790	otherwise if call to the method finder.find_module with an argument name evaluates to true ,	elif finder . find_module ( name ) :
16791	return boolean True .	return True
16792	if not ,	else :
16793	skip this loop iteration ,	continue
16794	if KeyError exception is caught ,	except KeyError :
16795	for every hook in sys.path_hooks ,	for hook in sys . path_hooks :
16796	try ,	try :
16797	call the function hook with an argument entry , substitute the result for finder .	finder = hook ( entry )
16798	if call to the method finder.find_module with an argument name evaluates to true ,	if finder . find_module ( name ) :
16799	return boolean True .	return True
16800	if not ,	else :
16801	break from the loop execution ,	break
16802	if ImportError exception is caught ,	except ImportError :
16803	skip this loop iteration ,	continue
16804	if not ,	else :
16805	if entry is a directory ,	if os . path . isdir ( entry ) :
16806	try ,	try :
16807	call the method imp.find_module with 2 arguments : module_name and list containing element entry , assign the result to file_ , _ , and _ , respectively	file_ , _ , _ = imp . find_module ( module_name , [ entry ] )
16808	if file_ is true ,	if file_ :
16809	close file_ file descriptor .	file_ . close ( )
16810	return boolean True .	return True
16811	if ImportError exception is caught ,	except ImportError :
16812	do nothing .	pass
16813	if not ,	else :
16814	return boolean False .	return False
16815	from django.conf import settings into default name space .	from django . conf import settings
16816	from django.utils.safestring import mark_safe into default name space .	from django . utils . safestring import mark_safe
16817	from django.utils import six into default name space .	from django . utils import six
16818	define the function format with 6 arguments : number , decimal_sep , decimal_pos set to None , grouping set to integer 0 ,	def format ( number , decimal_sep , decimal_pos = None , grouping = 0 , thousand_sep = STR , force_grouping = False ) :
16819	if settings.USE_L10N is true , substitute settings.USE_THOUSAND_SEPARATOR for use_grouping , otherwise substitute settings.USE_L10N for use_grouping .	use_grouping = settings . USE_L10N and settings . USE_THOUSAND_SEPARATOR
16820	if use_grouping is true substitute it for use_grouping , otherwise substitute force_grouping for use_grouping .	use_grouping = use_grouping or force_grouping
16821	if use_grouping is true and grouping is greater than integer 0 , use_grouping is boolean True , otherwise it is boolean False .	use_grouping = use_grouping and grouping > 0
16822	if number is an integer and use_grouping is false and decimal_pos is false ,	if isinstance ( number , int ) and not use_grouping and not decimal_pos :
16823	call the function six.text_type with an argument number , use the result as an argument for the call to the function mark_safe , return the result .	return mark_safe ( six . text_type ( number ) )
16824	sign is an empty string .	sign = STR
16825	call the function six.text_type with an argument number , substitute the result for str_number .	str_number = six . text_type ( number )
16826	if first element of str_number equals a string STR0 .	if str_number [ 0 ] == STR0 :
16827	sign is a string STR0 .	sign = STR0
16828	remove the first element from str_number .	str_number = str_number [ 1 : ]
16829	if STR0 is not contained in str_number ,	if STR0 in str_number :
16830	split str_number by STR0 , substitute the result for int_part and dec_part , respectively .	int_part , dec_part = str_number . split ( STR0 )
16831	if decimal_pos is not None ,	if decimal_pos is not None :
16832	substitute first decimal_pos elements of dec_part for dec_part .	dec_part = dec_part [ : decimal_pos ]
16833	if not ,	else :
16834	substitute str_number and an empty string for int_part and dec_part .	int_part , dec_part = str_number , STR
16835	if decimal_pos is not None	if decimal_pos is not None :
16836	subtract length of dec_part from decimal_pos , multiply the number of character STR0 by the result , append the resulting string to dec_part , substitute it for dec_part .	dec_part = dec_part + ( STR0 * ( decimal_pos - len ( dec_part ) ) )
16837	if dec_part is true ,	if dec_part :
16838	add decimal_sep and dec_part , substitute the result for dec_part .	dec_part = decimal_sep + dec_part
16839	if use_grouping is true ,	if use_grouping :
16840	int_part_gd is an empty string .	int_part_gd = STR
16841	for every cnt and digit in enumerated list int_part with reversed ordering of elements ,	for cnt , digit in enumerate ( int_part [ : : - 1 ] ) :
16842	if cnt is true and remained of dividing cnt with grouping is zero ,	if cnt and not cnt % grouping :
16843	increment int_part_gd by thousand_sep .	int_part_gd += thousand_sep
16844	append digit to int_part_gd .	int_part_gd += digit
16845	invert the ordering of elements of int_part_gd , substitute it for int_part .	int_part = int_part_gd [ : : - 1 ]
16846	sum sign , int_part and dec_part , return the result .	return sign + int_part + dec_part
16847	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
16848	from django.utils import six into default name space .	from django . utils import six
16849	from django.utils.six.moves import zip into default name space .	from django . utils . six . moves import zip
16850	ESCAPE_MAPPINGS is an dictionary with 10 initial entries : None for STR0 , None for STR , None for STR1 , STR2 for STR3 , STR4 for STR5 , STR for STR6 , STR7 for STR8 , STR9 for STR10 , STR11 for STR12 and None for STR13 .	ESCAPE_MAPPINGS = { STR0 : None , STR : None , STR1 : None , STR2 : STR3 , STR4 : STR5 , STR6 : STR , STR7 : STR8 , STR9 : STR10 , STR11 : STR12 , STR13 : None , }
16851	derive the class Choice from list base class .	class Choice ( list ) :
16852	derive the class Group from list base class .	class Group ( list ) :
16853	derive the class NonCapture from list base class .	class NonCapture ( list ) :
16854	define the function normalize with an argument pattern .	def normalize ( pattern ) :
16855	result is an empty list .	result = [ ]
16856	non_capturing_groups is an empty list .	non_capturing_groups = [ ]
16857	consume_next is boolean True .	consume_next = True
16858	call the function next_char with an argument iterator pattern , substitute the result for pattern_iter .	pattern_iter = next_char ( iter ( pattern ) )
16859	num_args is an integer 0 .	num_args = 0
16860	try ,	try :
16861	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16862	if StopIteration exception ,	except StopIteration :
16863	return a list with an element tuple with 2 elements : an empty string and an empty list .	return [ ( STR , [ ] ) ]
16864	try ,	try :
16865	endless loop ,	while True :
16866	if escaped is true ,	if escaped :
16867	append ch to result .	result . append ( ch )
16868	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16869	append string STR0 to result .	result . append ( STR0 )
16870	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16871	raise an NotImplementedError exception with an argument string STR0 .	raise NotImplementedError ( STR0 )
16872	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16873	do nothing .	pass
16874	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16875	skip this loop iteration .	break
16876	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16877	remove first element from non_capturing_groups , substitute it for start .	start = non_capturing_groups . pop ( )
16878	inner is an instance of NonCapture , created with elements of result from start index to the end .	inner = NonCapture ( result [ start : ] )
16879	append list with element inner to list containing first start elements of result , substitute it for result .	result = result [ : start ] + [ inner ]
16880	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16881	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16882	append ch to result .	result . append ( ch )
16883	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16884	while escaped is true or ch is not equal to a string STR0 ,	while escaped or ch != STR0 :
16885	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16886	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16887	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16888	if ch is not equal to a sring STR0 or escaped is true ,	if ch != STR0 or escaped :
16889	name is a string STR0 formated with num_args .	name = STR0 % num_args
16890	increment num_args by one .	num_args += 1
16891	instantiate a class Group with 2 arguments : string STR0 formated with name , and name , append it to result .	result . append ( Group ( ( ( STR0 % name ) , name ) ) )
16892	call the function walk_to_end with 2 arguments : ch and pattern_iter .	walk_to_end ( ch , pattern_iter )
16893	if not ,	else :
16894	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16895	if ch is contained in string STR0 ,	if ch in STR0 :
16896	call the function walk_to_end with 2 arguments : ch and pattern_iter .	walk_to_end ( ch , pattern_iter )
16897	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16898	append length of result to non_capturing_groups .	non_capturing_groups . append ( len ( result ) )
16899	otherwise if ch equals a string STR0 ,	elif ch != STR0 :
16900	raise an ValueError with an argument string STR0 formated with ch .	raise ValueError ( STR0 % ch )
16901	if not ,	else :
16902	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16903	if ch is not equal to string STR0 or string STR1 ,	if ch not in ( STR0 , STR1 ) :
16904	raise an ValueError with an argument string STR0 formated with ch .	raise ValueError ( STR0 % ch )
16905	if ch equals a string STR0 ,	if ch == STR0 :
16906	terminal_char is an string STR0 .	terminal_char = STR0
16907	if not ,	else :
16908	terminal_char is an string STR0 .	terminal_char = STR0
16909	name is an empty list .	name = [ ]
16910	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16911	while ch is not equal to terminal_char ,	while ch != terminal_char :
16912	append ch to result .	name . append ( ch )
16913	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16914	join elements of name into a string , substitute it for param .	param = STR . join ( name )
16915	if terminal_char is not equal to string STR0 ,	if terminal_char != STR0 :
16916	instantiate a class Group with 2 arguments : string STR0 formated with param , and param , append it to result .	result . append ( Group ( ( ( STR0 % param ) , param ) ) )
16917	call the function walk_to_end with 2 arguments : ch and pattern_iter .	walk_to_end ( ch , pattern_iter )
16918	if not ,	else :
16919	instantiate a class Group with 2 arguments : string STR0 formated with param , and None , append it to result .	result . append ( Group ( ( ( STR0 % param ) , None ) ) )
16920	otherwise if ch is contained in string STR0 ,	elif ch in STR0 :
16921	call the function get_quantifier with 2 arguments : ch and pattern_iter , substitute the result for count and ch , respectively .	count , ch = get_quantifier ( ch , pattern_iter )
16922	if ch is true ,	if ch :
16923	consume_next is boolean False .	consume_next = False
16924	if count is equal to integer 0 .	if count == 0 :
16925	if call to the function contains with 2 arguments : last element of result and Group , evaluates to true ,	if contains ( result [ - 1 ] , Group ) :
16926	last element of result is an instance of Choice class , created with an argument list with 2 elements : None and last element of result .	result [ - 1 ] = Choice ( [ None , result [ - 1 ] ] )
16927	if not ,	else :
16928	remove the first element from result .	result . pop ( )
16929	otherwise if count is greater than integer 1 ,	elif count > 1 :
16930	create a list with count decremented by 1 number of last element of result elements , extend list result with it .	result . extend ( [ result [ - 1 ] ] * ( count - 1 ) )
16931	if not ,	else :
16932	append ch to result .	result . append ( ch )
16933	if consume_next is true ,	if consume_next :
16934	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( pattern_iter )
16935	if not ,	else :
16936	consume_next is boolean True .	consume_next = True
16937	if StopIteration exception ,	except StopIteration :
16938	do nothing .	pass
16939	if NotImplementedError exception ,	except NotImplementedError :
16940	return a list with an element tuple with 2 elements : an empty string and an empty list .	return [ ( STR , [ ] ) ]
16941	call the function flatten_result with an argument result , unpack the resulting list and zip it in the list of tuples , return the result .	return list ( zip ( * flatten_result ( result ) ) )
16942	define the function next_char with an argument input_iter .	def next_char ( input_iter ) :
16943	for every ch in input_iter ,	for ch in input_iter :
16944	if ch is not equal to string '\STR .	if ch != STRspecial :
16945	yield ch and boolean False .	yield ch , False
16946	skip this loop iteration .	continue
16947	get the next element of the iterable pattern_iter , assign the result for ch .	ch = next ( input_iter )
16948	get the value under ch key of the ESCAPE_MAPPINGS dictionary , if it exists substitute it for representative , if not substitute ch for representative .	representative = ESCAPE_MAPPINGS . get ( ch , ch )
16949	if representative is None ,	if representative is None :
16950	skip this loop iteration .	continue
16951	yield representative and boolean True .	yield representative , True
16952	define the function walk_to_end with 2 arguments ch and input_iter .	def walk_to_end ( ch , input_iter ) :
16953	if ch equal a string STR0 ,	if ch == STR0 :
16954	nesting is integer 1 .	nesting = 1
16955	if not ,	else :
16956	nesting is integer 0 .	nesting = 0
16957	for every ch and escaped in input_iter ,	for ch , escaped in input_iter :
16958	if escaped is true ,	if escaped :
16959	skip this loop iteration .	continue
16960	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16961	increment nesting by one .	nesting += 1
16962	otherwise if ch equals a string STR0 ,	elif ch == STR0 :
16963	if nesting is false ,	if not nesting :
16964	return nothing .	return
16965	decrement nesting by one .	nesting -= 1
16966	define the function get_quantifier with 2 arguments ch and input_iter .	def get_quantifier ( ch , input_iter ) :
16967	if ch is contained in string STR0 ,	if ch in STR0 :
16968	try ,	try :
16969	get the next element of the iterable pattern_iter , assign the result for ch2 and escaped , respectively .	ch2 , escaped = next ( input_iter )
16970	if StopIteration exception ,	except StopIteration :
16971	ch2 is None .	ch2 = None
16972	if ch2 equals string STR0 ,	if ch2 == STR0 :
16973	ch2 is None .	ch2 = None
16974	if ch equals string STR0 ,	if ch == STR0 :
16975	return integer 1 and ch2 .	return 1 , ch2
16976	return integer 0 and ch2 .	return 0 , ch2
16977	quant is an empty list .	quant = [ ]
16978	while ch is not equal to a string STR0 ,	while ch != STR0 :
16979	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( input_iter )
16980	append ch to quant .	quant . append ( ch )
16981	remove last element for quant .	quant = quant [ : - 1 ]
16982	join elements of quant into a string , split it by string STR0 , substitute the result for values .	values = STR . join ( quant ) . split ( STR0 )
16983	try ,	try :
16984	get the next element of the iterable pattern_iter , assign the result for ch and escaped , respectively .	ch , escaped = next ( input_iter )
16985	if StopIteration exception ,	except StopIteration :
16986	ch is None .	ch = None
16987	if ch equals a string STR0 ,	if ch == STR0 :
16988	ch is None .	ch = None
16989	convert first element of values into a integer , return the result and ch .	return int ( values [ 0 ] ) , ch
16990	define the function contains with 2 arguments source and inst .	def contains ( source , inst ) :
16991	if source is an instance of inst class ,	if isinstance ( source , inst ) :
16992	return boolean True .	return True
16993	if source is an instance of NonCapture class ,	if isinstance ( source , NonCapture ) :
16994	for every elt in source ,	for elt in source :
16995	call the function contains with 2 arguments : elt and inst , if it evaluates to true ,	if contains ( elt , inst ) :
16996	return boolean True .	return True
16997	return boolean False .	return False
16998	define the function flatten_result with an argument source .	def flatten_result ( source ) :
16999	if source is None ,	if source is None :
17000	return a list containing an empty string and a list containing an empty list .	return [ STR ] , [ [ ] ]
17001	if source is an instance of Group class ,	if isinstance ( source , Group ) :
17002	if second element of source is None ,	if source [ 1 ] is None :
17003	params is an empty list ,	params = [ ]
17004	if not ,	else :
17005	params is a list with second element of source as a element .	params = [ source [ 1 ] ]
17006	return a list containing first element of source and a list containing params .	return [ source [ 0 ] ] , [ params ]
17007	result is a list containing an empty string .	result = [ STR ]
17008	result_args is a list containing an empty list .	result_args = [ [ ] ]
17009	pos and last are integer 0 .	pos = last = 0
17010	for every pos and elt in enumerated iterable source ,	for pos , elt in enumerate ( source ) :
17011	if elt is an instance of six.string_types class ,	if isinstance ( elt , six . string_types ) :
17012	skip this loop iteration .	continue
17013	join source list elements from last till pos indexes into a string , substitute the result for piece .	piece = STR . join ( source [ last : pos ] )
17014	if elt is an instance of Group class ,	if isinstance ( elt , Group ) :
17015	increment piece by firs element of elt .	piece += elt [ 0 ]
17016	substitute second element of elt for param .	param = elt [ 1 ]
17017	if not ,	else :
17018	param is None .	param = None
17019	increment pos by one , substitute the result for last .	last = pos + 1
17020	for every i in range of integers from 0 to length of result , not included ,	for i in range ( len ( result ) ) :
17021	increment i-th element of result by piece .	result [ i ] += piece
17022	if param is true ,	if param :
17023	append param to i-th element of result_args .	result_args [ i ] . append ( param )
17024	if elt is an instance of Choice or NonCapture classes ,	if isinstance ( elt , ( Choice , NonCapture ) ) :
17025	if elt is an instance of NonCapture class ,	if isinstance ( elt , NonCapture ) :
17026	elt is an list with an element elt .	elt = [ elt ]
17027	inner_result and inner_args are empty lists .	inner_result , inner_args = [ ] , [ ]
17028	for every item in elt ,	for item in elt :
17029	call the function flatten_result with an argument item , assign the result to res and args , respectively .	res , args = flatten_result ( item )
17030	extend list inner_result with res .	inner_result . extend ( res )
17031	extend list inner_args with args .	inner_args . extend ( args )
17032	new_result is an empty list .	new_result = [ ]
17033	new_args is an empty list .	new_args = [ ]
17034	zip elements of result and result_args into a list of tuples , for every item and args in the result ,	for item , args in zip ( result , result_args ) :
17035	zip elements of inner_result and inner_args into a list of tuples , for every i_item and i_args in the result ,	for i_item , i_args in zip ( inner_result , inner_args ) :
17036	sum item and i_item together , append the result to new_result .	new_result . append ( item + i_item )
17037	append i_args to args , append new_args with the result .	new_args . append ( args [ : ] + i_args )
17038	substitute new_result for result .	result = new_result
17039	substitute new_args for result_args .	result_args = new_args
17040	if pos is greater than or equal to last ,	if pos >= last :
17041	join elements of list source from index last to the end into a string , substitute it for piece .	piece = STR . join ( source [ last : ] )
17042	for every i in range of integers from 0 to length of result , not included ,	for i in range ( len ( result ) ) :
17043	increment i-th element of result by piece .	result [ i ] += piece
17044	return result and result_args .	return result , result_args
17045	from django.utils.functional import curry and Promise into default name space .	from django . utils . functional import curry , Promise
17046	from django.utils import six into default name space .	from django . utils import six
17047	derive the class EscapeData from object base class .	class EscapeData ( object ) :
17048	do nothing .	pass
17049	derive the class EscapeBytes from bytes and EscapeData base classes .	class EscapeBytes ( bytes , EscapeData ) :
17050	do nothing .	pass
17051	derive the class EscapeText from six.text_type and EscapeData base classes .	class EscapeText ( six . text_type , EscapeData ) :
17052	do nothing .	pass
17053	if six.PY3 is true ,	if six . PY3 :
17054	substitute EscapeText for EscapeString .	EscapeString = EscapeText
17055	if not ,	else :
17056	substitute EscapeBytes for EscapeString .	EscapeString = EscapeBytes
17057	substitute EscapeText for EscapeUnicode .	EscapeUnicode = EscapeText
17058	derive the class SafeData from object base class .	class SafeData ( object ) :
17059	define the method __html__ with an argument self .	def __html__ ( self ) :
17060	return self .	return self
17061	derive the class SafeBytes from bytes and SafeData base classes .	class SafeBytes ( bytes , SafeData ) :
17062	define the method __add__ with 2 arguments self and rhs .	def __add__ ( self , rhs ) :
17063	call the __add__ method with an arguments rhs from the base class of the class SafeBytes , substitute the result for t .	t = super ( SafeBytes , self ) . __add__ ( rhs )
17064	if rhs is an instance of SafeText ,	if isinstance ( rhs , SafeText ) :
17065	return an instance of SafeText , created with an argument t .	return SafeText ( t )
17066	otherwise if rhs is an instance of SafeBytes ,	elif isinstance ( rhs , SafeBytes ) :
17067	return an instance of SafeBytes , created with an argument t .	return SafeBytes ( t )
17068	return t .	return t
17069	define the method _proxy_method with 3 arguments self , unpacked list args and unpacked dictionary kwargs .	def _proxy_method ( self , * args , ** kwargs ) :
17070	remove kwargs dictionary element under the STR0 key , substitute it for method .	method = kwargs . pop ( STR0 )
17071	call the function method with 3 arguments : self , unpacked list args and unpacked dictionary kwargs , substitute the result for data .	data = method ( self , * args , ** kwargs )
17072	if data is an instance of bytes ,	if isinstance ( data , bytes ) :
17073	return an instance of SafeBytes , created with an argument data .	return SafeBytes ( data )
17074	if not ,	else :
17075	return an instance of SafeText , created with an argument data .	return SafeText ( data )
17076	call the function curry with 2 arguments : _proxy_method and method set to bytes.decode , substitute the result for decode .	decode = curry ( _proxy_method , method = bytes . decode )
17077	derive the class SafeText from six.text_type and SafeData base classes .	class SafeText ( six . text_type , SafeData ) :
17078	define the method __add__ with 2 arguments self and rhs .	def __add__ ( self , rhs ) :
17079	call the __add__ method with an arguments rhs from the base class of the class SafeText , substitute the result for t .	t = super ( SafeText , self ) . __add__ ( rhs )
17080	if rhs is an instance of SafeData .	if isinstance ( rhs , SafeData ) :
17081	return an instance of SafeText , created with an argument t .	return SafeText ( t )
17082	return t .	return t
17083	define the method _proxy_method with 3 arguments self , unpacked list args and unpacked dictionary kwargs .	def _proxy_method ( self , * args , ** kwargs ) :
17084	remove kwargs dictionary element under the STR0 key , substitute it for method .	method = kwargs . pop ( STR0 )
17085	call the function method with 3 arguments : self , unpacked list args and unpacked dictionary kwargs , substitute the result for data .	data = method ( self , * args , ** kwargs )
17086	if data is an instance of bytes .	if isinstance ( data , bytes ) :
17087	return an instance of SafeBytes , created with an argument data .	return SafeBytes ( data )
17088	if not ,	else :
17089	return an instance of SafeText , created with an argument data .	return SafeText ( data )
17090	call the function curry with 2 arguments : _proxy_method and method set to six.text_type.encode , substitute the result for encode .	encode = curry ( _proxy_method , method = six . text_type . encode )
17091	if six.PY3 is true ,	if six . PY3 :
17092	substitute SafeText for SafeString .	SafeString = SafeText
17093	if not ,	else :
17094	substitute SafeBytes for SafeString .	SafeString = SafeBytes
17095	substitute SafeText for SafeUnicode .	SafeUnicode = SafeText
17096	define the function mark_safe with an argument s .	def mark_safe ( s ) :
17097	if s is an instance of SafeData .	if isinstance ( s , SafeData ) :
17098	return s .	return s
17099	if s is an instance of bytes or Promise and s._delegate_bytes is true ,	if isinstance ( s , bytes ) or ( isinstance ( s , Promise ) and s . _delegate_bytes ) :
17100	return an instance of SafeBytes , created with an argument s .	return SafeBytes ( s )
17101	if s is an instance of six.text_type or Promise ,	if isinstance ( s , ( six . text_type , Promise ) ) :
17102	return an instance of SafeText , created with an argument s .	return SafeText ( s )
17103	return an instance of SafeText , created with an argument s converted into a string .	return SafeString ( str ( s ) )
17104	define the function mark_for_escaping with an argument s .	def mark_for_escaping ( s ) :
17105	if s is an instance of SafeData or EscapeData ,	if isinstance ( s , ( SafeData , EscapeData ) ) :
17106	return s .	return s
17107	if s is an instance of bytes or Promise and s._delegate_bytes is true ,	if isinstance ( s , bytes ) or ( isinstance ( s , Promise ) and s . _delegate_bytes ) :
17108	return an instance of EscapeBytes , created with an argument s .	return EscapeBytes ( s )
17109	if s is an instance of six.text_type or Promise ,	if isinstance ( s , ( six . text_type , Promise ) ) :
17110	return an instance of EscapeText , created with an argument s .	return EscapeText ( s )
17111	return an instance of EscapeBytes , created with an argument , reuslt of the call to the function bytes with an argument s .	return EscapeBytes ( bytes ( s ) )
17112	import module opera .	import operator
17113	import module sys .	import sys
17114	import module types .	import types
17115	__author__ is a string STR0 .	__author__ = STR0
17116	__version__ is a string STR0 .	__version__ = STR0
17117	if first element of sys.version_info equals integer 2 , PY2 is boolean True , otherwise it is boolean False .	PY2 = sys . version_info [ 0 ] == 2
17118	if first element of sys.version_info equals integer 3 , PY3 is boolean True , otherwise it is boolean False .	PY3 = sys . version_info [ 0 ] == 3
17119	if PY3 is true ,	if PY3 :
17120	substitute str for string_types .	string_types = str ,
17121	substitute int for integer_types .	integer_types = int ,
17122	substitute type for class_types .	class_types = type ,
17123	substitute str for text_type .	text_type = str
17124	substitute bytes for binary_type .	binary_type = bytes
17125	substitute sys.maxsize for MAXSIZE .	MAXSIZE = sys . maxsize
17126	if not ,	else :
17127	substitute basestring for string_types .	string_types = basestring ,
17128	integer_types is a tuple with 2 elements int and long .	integer_types = ( int , long )
17129	class_types is a tuple with 2 elements : type and types.ClassType .	class_types = ( type , types . ClassType )
17130	substitute unicode for text_type .	text_type = unicode
17131	substitute str for binary_type .	binary_type = str
17132	if sys.platform starts with string STR0 ,	if sys . platform . startswith ( STR0 ) :
17133	bitwise shift integer 1 to the left by 31 spaces , substitute integer 1 from the result , convert the result to a integer , substitute it for MAXSIZE .	MAXSIZE = int ( ( 1 << 31 ) - 1 )
17134	if not ,	else :
17135	derive class X from the object base class .	class X ( object ) :
17136	define the method __len__ with an argument self .	def __len__ ( self ) :
17137	bitwise shift integer 1 to the left by 31 spaces , return the result .	return 1 << 31
17138	try	try :
17139	instantiate class X , get its length .	len ( X ( ) )
17140	if OverflowError exception is caught ,	except OverflowError :
17141	bitwise shift integer 1 to the left by 31 spaces , substitute integer 1 from the result , convert the result to a integer , substitute it for MAXSIZE .	MAXSIZE = int ( ( 1 << 31 ) - 1 )
17142	if not ,	else :
17143	bitwise shift integer 1 to the left by 63 spaces , substitute integer 1 from the result , convert the result to a integer , substitute it for MAXSIZE .	MAXSIZE = int ( ( 1 << 63 ) - 1 )
17144	delete X .	del X
17145	define the function _add_doc with 2 arguments : func and doc .	def _add_doc ( func , doc ) :
17146	substitute doc for func.__doc__ .	func . __doc__ = doc
17147	define the function _import_module with an argument name .	def _import_module ( name ) :
17148	call the function __import__ with an argument name .	__import__ ( name )
17149	return value under the name key of the sys.modules dictionary .	return sys . modules [ name ]
17150	derive class _LazyDescr from the object base class .	class _LazyDescr ( object ) :
17151	define the method __init__ with 2 arguments : self and name .	def __init__ ( self , name ) :
17152	substitute name for self.name .	self . name = name
17153	define the method __get__ with 3 arguments : self , obj and tp .	def __get__ ( self , obj , tp ) :
17154	try ,	try :
17155	call the method self._resolve , substitute the result for result .	result = self . _resolve ( )
17156	if ImportError exception is caught ,	except ImportError :
17157	raise an AttributeError with an argument string STR0 , formated with self.name .	raise AttributeError ( STR0 % self . name )
17158	set self.name attribute of the obj object to result .	setattr ( obj , self . name , result )
17159	delete self.name attribute from the obj.__class__ object .	delattr ( obj . __class__ , self . name )
17160	return result .	return resultf
17161	derive class MovedModule from the _LazyDescr base class .	class MovedModule ( _LazyDescr ) :
17162	define the method __init__ with 4 arguments : self , name , old and new set to None .	def __init__ ( self , name , old , new = None ) :
17163	call the __init__ method with an argument name from the base class of the MovedModule class .	super ( MovedModule , self ) . __init__ ( name )
17164	if PY3 is true ,	if PY3 :
17165	if new is None ,	if new is None :
17166	substitute name for new .	new = name
17167	substitute new for self.mod .	self . mod = new
17168	if not ,	else :
17169	substitute old for self.mod .	self . mod = old
17170	define the method _resolve with an argument self .	def _resolve ( self ) :
17171	call the function _import_module with an argument self.mod , return the result .	return _import_module ( self . mod )
17172	define the method __getattr__ with 2 arguments : self and attr set to None .	def __getattr__ ( self , attr ) :
17173	if attr equals any of the strings STR0 , STR1 or STR2 and self.mod is not contained in sys.modules ,	if ( attr in ( STR0 , STR1 , STR2 ) and self . mod not in sys . modules ) :
17174	raise an AttributeError with an argument attr .	raise AttributeError ( attr )
17175	try ,	try :
17176	call the method self._resolve , substitute the result for _module .	_module = self . _resolve ( )
17177	if ImportError exception is caught ,	except ImportError :
17178	raise an AttributeError with an argument attr .	raise AttributeError ( attr )
17179	get attr attribute from the _module object , substitute it for value .	value = getattr ( _module , attr )
17180	set attr attribute of the self object to value .	setattr ( self , attr , value )
17181	return value .	return value
17182	derive class _LazyModule from the types.ModuleType base class .	class _LazyModule ( types . ModuleType ) :
17183	define the method __init__ with 2 arguments : self and name .	def __init__ ( self , name ) :
17184	call the method __init__ with an argument name form the base class of the class _LazyModule .	super ( _LazyModule , self ) . __init__ ( name )
17185	substitute self.__class__.__doc__ for self.__doc__ .	self . __doc__ = self . __class__ . __doc__
17186	define the method __dir__ with an argument self .	def __dir__ ( self ) :
17187	attrs is a list with 2 elements : strings STR0 and STR1 .	attrs = [ STR0 , STR1 ]
17188	append attr.name to attrs for every attr in self._moved_attributes .	attrs += [ attr . name for attr in self . _moved_attributes ]
17189	return attrs .	return attrs
17190	_moved_attributes is an empty list .	_moved_attributes = [ ]
17191	derive class MovedAttribute from the _LazyDescr base class .	class MovedAttribute ( _LazyDescr ) :
17192	define the method __init__ with 6 arguments : self , name , old_mod , new_mod , old_attr set to None , new_attr set to None .	def __init__ ( self , name , old_mod , new_mod , old_attr = None , new_attr = None ) :
17193	call the method __init__ with an argument name form the base class of the class MovedAttribute .	super ( MovedAttribute , self ) . __init__ ( name )
17194	if PY3 is true ,	if PY3 :
17195	if new_mod is None ,	if new_mod is None :
17196	substitute name for new_mod .	new_mod = name
17197	substitute new_mod for self.mod .	self . mod = new_mod
17198	if new_attr is None ,	if new_attr is None :
17199	if old_attr is None ,	if old_attr is None :
17200	substitute name for new_attr .	new_attr = name
17201	if not ,	else :
17202	substitute old_attr for new_attr .	new_attr = old_attr
17203	substitute new_attr for self.attr .	self . attr = new_attr
17204	if not ,	else :
17205	substitute old_mod for self.mod .	self . mod = old_mod
17206	if old_attr is None ,	if old_attr is None :
17207	substitute name for old_attr .	old_attr = name
17208	substitute old_attr for self.attr .	self . attr = old_attr
17209	define the method _resolve with an argument self .	def _resolve ( self ) :
17210	call the function _import_module with an argument self.mod , substitute the result for module .	module = _import_module ( self . mod )
17211	gett self.attr from the module object , return it .	return getattr ( module , self . attr )
17212	derive class _MovedItems from the _LazyModule base class .	class _MovedItems ( _LazyModule ) :
17213	_moved_attributes is a list with 55 initial elements , 13 of them are the results of the call to the function MovedAttribute , with different 3 string arguments , the others are results of the call to the function MovedModule called with 3 string arguments .	_moved_attributes = [ MovedAttribute ( STR0 , STR1 , STR2 , STR3 ) , MovedAttribute ( STR4 , STR5 , STR6 , STR7 , STR8 ) , MovedAttribute ( STR9 , STR10 , STR11 , STR12 , STR13 ) , MovedAttribute ( STR14 , STR15 , STR16 , STR17 , STR18 ) , MovedAttribute ( STR19 , STR20 , STR21 , STR22 , STR23 ) , MovedAttribute ( STR24 , STR25 , STR26 , STR27 , STR28 ) , MovedAttribute ( STR29 , STR30 , STR31 , STR32 ) , MovedAttribute ( STR33 , STR34 , STR35 ) , MovedAttribute ( STR36 , STR37 , STR38 ) , MovedAttribute ( STR39 , STR40 , STR41 ) , MovedAttribute ( STR42 , STR43 , STR44 , STR45 , STR46 ) , MovedAttribute ( STR47 , STR48 , STR49 , STR50 , STR51 ) , MovedAttribute ( STR52 , STR53 , STR54 , STR55 , STR56 ) , MovedModule ( STR57 , STR58 ) , MovedModule ( STR59 , STR60 ) , MovedModule ( STR61 , STR62 ) , MovedModule ( STR63 , STR64 , STR65 ) , MovedModule ( STR66 , STR67 , STR68 ) , MovedModule ( STR69 , STR70 , STR71 ) , MovedModule ( STR72 , STR73 , STR74 ) , MovedModule ( STR75 , STR76 , STR77 ) , MovedModule ( STR78 , STR79 , STR80 ) , MovedModule ( STR81 , STR82 , STR83 ) , MovedModule ( STR84 , STR85 , STR86 ) , MovedModule ( STR87 , STR88 , STR89 ) , MovedModule ( STR90 , STR91 , STR92 ) , MovedModule ( STR93 , STR94 , STR95 ) , MovedModule ( STR96 , STR97 , STR98 ) , MovedModule ( STR99 , STR100 , STR101 ) , MovedModule ( STR102 , STR103 ) , MovedModule ( STR104 , STR105 ) , MovedModule ( STR106 , STR107 ) , MovedModule ( STR108 , STR109 , STR110 ) , MovedModule ( STR111 , STR112 ) , MovedModule ( STR113 , STR114 , STR115 ) , MovedModule ( STR116 , STR117 , STR118 ) , MovedModule ( STR119 , STR120 , STR121 ) , MovedModule ( STR122 , STR123 , STR124 ) , MovedModule ( STR125 , STR126 , STR127 ) , MovedModule ( STR128 , STR129 , STR130 ) , MovedModule ( STR131 , STR132 , STR133 ) , MovedModule ( STR134 , STR135 , STR136 ) , MovedModule ( STR137 , STR138 , STR139 ) , MovedModule ( STR140 , STR141 , STR142 ) , MovedModule ( STR143 , STR144 , STR145 ) , MovedModule ( STR146 , STR147 , STR148 ) , MovedModule ( STR149 , STR150 , STR151 ) , MovedModule ( STR152 , STR153 , STR154 ) , MovedModule ( STR155 , __name__ + STR156 , STR157 ) , MovedModule ( STR158 , __name__ + STR159 , STR160 ) , MovedModule ( STR161 , __name__ + STR162 , __name__ + STR163 ) , MovedModule ( STR164 , STR165 , STR166 ) , MovedModule ( STR167 , STR168 , STR169 ) , MovedModule ( STR170 , STR171 , STR172 ) , MovedModule ( STR173 , STR174 ) , ]
17214	for every attr in _moved_attributes ,	for attr in _moved_attributes :
17215	set attr.name attribute of the _MovedItemst object to attr .	setattr ( _MovedItems , attr . name , attr )
17216	if attr is an instance of MovedModule .	if isinstance ( attr , MovedModule ) :
17217	concatenate __name__ , string STR0 and attr.name together , use it as an key to get the value from the sys.modules dictionary , substitute attr for the obtained value .	sys . modules [ __name__ + STR0 + attr . name ] = attr
17218	delete attr .	del attr
17219	substitute _moved_attributes for _MovedItems._moved_attributes .	_MovedItems . _moved_attributes = _moved_attributes
17220	append string STR0 to __name__ , use it as an argument to instantiate _MovedItems class , assign it to moves , and to value under the STR1 appended to __name__ key of the sys.modules dictionary .	moves = sys . modules [ __name__ + STR0 ] = _MovedItems ( __name__ + STR1 )
17221	derive class Module_six_moves_urllib_parse from the _LazyModule base class .	class Module_six_moves_urllib_parse ( _LazyModule ) :
17222	_urllib_parse_moved_attributes is a list with 16 elemetns , all of them are the results of the call to the function MovedAttribute with different 3 string arguments .	_urllib_parse_moved_attributes = [ MovedAttribute ( STR0 , STR1 , STR2 ) , MovedAttribute ( STR3 , STR4 , STR5 ) , MovedAttribute ( STR6 , STR7 , STR8 ) , MovedAttribute ( STR9 , STR10 , STR11 ) , MovedAttribute ( STR12 , STR13 , STR14 ) , MovedAttribute ( STR15 , STR16 , STR17 ) , MovedAttribute ( STR18 , STR19 , STR20 ) , MovedAttribute ( STR21 , STR22 , STR23 ) , MovedAttribute ( STR24 , STR25 , STR26 ) , MovedAttribute ( STR27 , STR28 , STR29 ) , MovedAttribute ( STR30 , STR31 , STR32 ) , MovedAttribute ( STR33 , STR34 , STR35 ) , MovedAttribute ( STR36 , STR37 , STR38 ) , MovedAttribute ( STR39 , STR40 , STR41 ) , MovedAttribute ( STR42 , STR43 , STR44 ) , MovedAttribute ( STR45 , STR46 , STR47 ) , ]
17223	for every attr in _urllib_parse_moved_attributes ,	for attr in _urllib_parse_moved_attributes :
17224	set attr.name attribute of the Module_six_moves_urllib_parse object to attr .	setattr ( Module_six_moves_urllib_parse , attr . name , attr )
17225	delete attr .	del attr
17226	substitute _urllib_parse_moved_attributes for Module_six_moves_urllib_parse._moved_attributes .	Module_six_moves_urllib_parse . _moved_attributes = _urllib_parse_moved_attributes
17227	call the method Module_six_moves_urllib_request with an argument : string STR0 appended to __name__ , assign the result to the value under the string STR1 appended to __name__ key of the sys.modules dictionary , and to the value under the string STR2 appended to __name__ key of the sys.modules dictionary .	sys . modules [ __name__ + STR0 ] = sys . modules [ __name__ + STR1 ] = Module_six_moves_urllib_parse ( __name__ + STR2 )
17228	derive class Module_six_moves_urllib_error from the _LazyModule base class .	class Module_six_moves_urllib_error ( _LazyModule ) :
17229	_urllib_error_moved_attributes is a list with 3 elements : result of the call to the function MovedAttribute with 3 arguments : strings STR0 , STR1 , STR2 , result of the call to the function MovedAttribute with 3 arguments : strings STR3 , STR4 , STR5 and result of the call to the function MovedAttribute with 3 arguments : strings STR6 , STR7 , STR8 .	_urllib_error_moved_attributes = [ MovedAttribute ( STR0 , STR1 , STR2 ) , MovedAttribute ( STR3 , STR4 , STR5 ) , MovedAttribute ( STR6 , STR7 , STR8 ) , ]
17230	for every attr in _urllib_error_moved_attributes ,	for attr in _urllib_error_moved_attributes :
17231	set attr.name attribute of the Module_six_moves_urllib_error object to attr .	setattr ( Module_six_moves_urllib_error , attr . name , attr )
17232	delete attr .	del attr
17233	substitute _urllib_error_moved_attributes for Module_six_moves_urllib_error._moved_attributes .	Module_six_moves_urllib_error . _moved_attributes = _urllib_error_moved_attributes
17234	call the method Module_six_moves_urllib_request with an argument : string STR0 appended to __name__ , assign the result to the value under the string STR1 appended to __name__ key of the sys.modules dictionary , and to the value under the string STR2 appended to __name__ key of the sys.modules dictionary .	sys . modules [ __name__ + STR0 ] = sys . modules [ __name__ + STR1 ] = Module_six_moves_urllib_error ( __name__ + STR2 )
17235	derive class Module_six_moves_urllib_request from the _LazyModule base class .	class Module_six_moves_urllib_request ( _LazyModule ) :
17236	_urllib_request_moved_attributes is an list with 33 elements , all of them are the results of the call to the function MovedAttribute with 3 different string arguments .	_urllib_request_moved_attributes = [ MovedAttribute ( STR0 , STR1 , STR2 ) , MovedAttribute ( STR3 , STR4 , STR5 ) , MovedAttribute ( STR6 , STR7 , STR8 ) , MovedAttribute ( STR9 , STR10 , STR11 ) , MovedAttribute ( STR12 , STR13 , STR14 ) , MovedAttribute ( STR15 , STR16 , STR17 ) , MovedAttribute ( STR18 , STR19 , STR20 ) , MovedAttribute ( STR21 , STR22 , STR23 ) , MovedAttribute ( STR24 , STR25 , STR26 ) , MovedAttribute ( STR27 , STR28 , STR29 ) , MovedAttribute ( STR30 , STR31 , STR32 ) , MovedAttribute ( STR33 , STR34 , STR35 ) , MovedAttribute ( STR36 , STR37 , STR38 ) , MovedAttribute ( STR39 , STR40 , STR41 ) , MovedAttribute ( STR42 , STR43 , STR44 ) , MovedAttribute ( STR45 , STR46 , STR47 ) , MovedAttribute ( STR48 , STR49 , STR50 ) , MovedAttribute ( STR51 , STR52 , STR53 ) , MovedAttribute ( STR54 , STR55 , STR56 ) , MovedAttribute ( STR57 , STR58 , STR59 ) , MovedAttribute ( STR60 , STR61 , STR62 ) , MovedAttribute ( STR63 , STR64 , STR65 ) , MovedAttribute ( STR66 , STR67 , STR68 ) , MovedAttribute ( STR69 , STR70 , STR71 ) , MovedAttribute ( STR72 , STR73 , STR74 ) , MovedAttribute ( STR75 , STR76 , STR77 ) , MovedAttribute ( STR78 , STR79 , STR80 ) , MovedAttribute ( STR81 , STR82 , STR83 ) , MovedAttribute ( STR84 , STR85 , STR86 ) , MovedAttribute ( STR87 , STR88 , STR89 ) , MovedAttribute ( STR90 , STR91 , STR92 ) , MovedAttribute ( STR93 , STR94 , STR95 ) , MovedAttribute ( STR96 , STR97 , STR98 ) , ]
17237	for every attr in _urllib_request_moved_attributes ,	for attr in _urllib_request_moved_attributes :
17238	set attr.name attribute of the Module_six_moves_urllib_request object to attr .	setattr ( Module_six_moves_urllib_request , attr . name , attr )
17239	delete attr .	del attr
17240	substitute _urllib_request_moved_attributes for Module_six_moves_urllib_request._moved_attributes .	Module_six_moves_urllib_request . _moved_attributes = _urllib_request_moved_attributes
17241	call the method Module_six_moves_urllib_request with an argument : string STR0 appended to __name__ , assign the result to the value under the string STR1 appended to __name__ key of the sys.modules dictionary , and to the value under the string STR2 appended to __name__ key of the sys.modules dictionary .	sys . modules [ __name__ + STR0 ] = sys . modules [ __name__ + STR1 ] = Module_six_moves_urllib_request ( __name__ + STR2 )
17242	derive class Module_six_moves_urllib_response from the _LazyModule base class .	class Module_six_moves_urllib_response ( _LazyModule ) :
17243	_urllib_response_moved_attributes is a list with 4 elements : result of the function MovedAttribute , called with 3 arguments : strings STR0 , STR1 and STR2 , result of the function MovedAttribute , called with 3 arguments : strings STR3 , STR4 , STR5 , result of the function MovedAttribute , called with 3 arguments : strings STR6 , STR7 , STR8 and result of the function MovedAttribute , called with 3 arguments : strings STR9 , STR10 , STR11 .	_urllib_response_moved_attributes = [ MovedAttribute ( STR0 , STR1 , STR2 ) , MovedAttribute ( STR3 , STR4 , STR5 ) , MovedAttribute ( STR6 , STR7 , STR8 ) , MovedAttribute ( STR9 , STR10 , STR11 ) , ]
17244	for every attr in _urllib_response_moved_attributes ,	for attr in _urllib_response_moved_attributes :
17245	set attr.name attribute of Module_six_moves_urllib_response object to attr .	setattr ( Module_six_moves_urllib_response , attr . name , attr )
17246	delete attr .	del attr
17247	substitute _urllib_response_moved_attributes for Module_six_moves_urllib_response._moved_attributes .	Module_six_moves_urllib_response . _moved_attributes = _urllib_response_moved_attributes
17248	instantiate class Module_six_moves_urllib_response with an argument , string STR0 appended to __name__ , assign it to value under the string STR1 appended to __name__ key of the sys.modules dictionary , and to value under the string STR2 appended to __name__ key of the sys.modules dictionary .	sys . modules [ __name__ + STR0 ] = sys . modules [ __name__ + STR1 ] = Module_six_moves_urllib_response ( __name__ + STR2 )
17249	derive class Module_six_moves_urllib_robotparser from the _LazyModule base class .	class Module_six_moves_urllib_robotparser ( _LazyModule ) :
17250	_urllib_robotparser_moved_attributes is a list containing an instance of MovedAttribute class , created with 3 argument : strings , STR0 , STR1 , STR2 .	_urllib_robotparser_moved_attributes = [ MovedAttribute ( STR0 , STR1 , STR2 ) , ]
17251	for every attr in _urllib_robotparser_moved_attributes ,	for attr in _urllib_robotparser_moved_attributes :
17252	set attr.name attribute of Module_six_moves_urllib_robotparser object to attr .	setattr ( Module_six_moves_urllib_robotparser , attr . name , attr )
17253	delete attr .	del attr
17254	substitute _urllib_robotparser_moved_attributes for Module_six_moves_urllib_robotparser._moved_attributes .	Module_six_moves_urllib_robotparser . _moved_attributes = _urllib_robotparser_moved_attributes
17255	instantiate class Module_six_moves_urllib_robotparser with an argument , string STR0 appended to __name__ , assign it to value under the string STR1 appended to __name__ key of the sys.modules dictionary , and to value under the string STR2 appended to __name__ key of the sys.modules dictionary .	sys . modules [ __name__ + STR0 ] = sys . modules [ __name__ + STR1 ] = Module_six_moves_urllib_robotparser ( __name__ + STR2 )
17256	derive class Module_six_moves_urllib from the types.ModuleType base class .	class Module_six_moves_urllib ( types . ModuleType ) :
17257	append string STR0 to __name__ , use it as an key to get the value from the sys.modules dictionary , substitute it for parse .	parse = sys . modules [ __name__ + STR0 ]
17258	append string STR0 to __name__ , use it as an key to get the value from the sys.modules dictionary , substitute it for error .	error = sys . modules [ __name__ + STR0 ]
17259	append string STR0 to __name__ , use it as an key to get the value from the sys.modules dictionary , substitute it for request .	request = sys . modules [ __name__ + STR0 ]
17260	append string STR0 to __name__ , use it as an key to get the value from the sys.modules dictionary , substitute it for response .	response = sys . modules [ __name__ + STR0 ]
17261	append string STR0 to __name__ , use it as an key to get the value from the sys.modules dictionary , substitute it for robotparser .	robotparser = sys . modules [ __name__ + STR0 ]
17262	define the method __dir__ with an argument self .	def __dir__ ( self ) :
17263	return a list with 5 elements : strings STR0 , STR1 , STR2 , STR3 and STR4 .	return [ STR0 , STR1 , STR2 , STR3 , STR4 ]
17264	instantiate class Module_six_moves_urllib with an argument , string STR0 appended to __name__ , substitute it for value under the string STR1 appended to __name__ key of the sys.modules dictionary .	sys . modules [ __name__ + STR0 ] = Module_six_moves_urllib ( __name__ + STR1 )
17265	define the function add_move with an argument move .	def add_move ( move ) :
17266	set move.name attribute of the _MovedItems to move .	setattr ( _MovedItems , move . name , move )
17267	define the function remove_move with an argument name .	def remove_move ( name ) :
17268	try ,	try :
17269	delete name attribute of the _MovedItems object .	delattr ( _MovedItems , name )
17270	if AttributeError exception is caught ,	except AttributeError :
17271	try ,	try :
17272	delete entry under the name key of the moves.__dict__ dictionary .	del moves . __dict__ [ name ]
17273	if NameError exception is caught ,	except KeyError :
17274	raise an AttributeError with an argument string STR0 , formated with a tuple with an element name .	raise AttributeError ( STR0 % ( name , ) )
17275	if PY3 is true ,	if PY3 :
17276	_meth_func is a string STR0 .	_meth_func = STR0
17277	_meth_self is a string STR0 .	_meth_self = STR0
17278	_func_closure is a string STR0 .	_func_closure = STR0
17279	_func_code is a string STR0 .	_func_code = STR0
17280	_func_defaults is a string STR0 .	_func_defaults = STR0
17281	_func_globals is a string STR0 .	_func_globals = STR0
17282	_iterkeys is a string STR0 .	_iterkeys = STR0
17283	_itervalues is a string STR0 .	_itervalues = STR0
17284	_iteritems is a string STR0 .	_iteritems = STR0
17285	_iterlists is a string STR0 .	_iterlists = STR0
17286	if not ,	else :
17287	_meth_func is a string STR0 .	_meth_func = STR0
17288	_meth_self is a string STR0 .	_meth_self = STR0
17289	_func_closure is a string STR0 .	_func_closure = STR0
17290	_func_code is a string STR0 .	_func_code = STR0
17291	_func_defaults is a string STR0 .	_func_defaults = STR0
17292	_func_globals is a string STR0 .	_func_globals = STR0
17293	_iterkeys is a string STR0 .	_iterkeys = STR0
17294	_iterkeys is a string STR0 .	_itervalues = STR0
17295	_iteritems is a string STR0 .	_iteritems = STR0
17296	_iterlists is a string STR0 .	_iterlists = STR0
17297	try ,	try :
17298	substitute next for advance_iterator .	advance_iterator = next
17299	if NameError exception is caught ,	except NameError :
17300	define the function advance_iterator with an argument it .	def advance_iterator ( it ) :
17301	return next element of the iterable it .	return it . next ( )
17302	substitute klass.__dict__ for next .	next = advance_iterator
17303	try ,	try :
17304	substitute callable for callable .	callable = callable
17305	if NameError exception is caught ,	except NameError :
17306	define the function callable with an argument obj .	def callable ( obj ) :
17307	if STR0 is contained in klass.__dict__ for any klass in __mro__ field of the obj class , return boolean True , otherwise return False .	return any ( STR0 in klass . __dict__ for klass in type ( obj ) . __mro__ )
17308	if PY3 is true ,	if PY3 :
17309	define the function get_unbound_function with an argument unbound .	def get_unbound_function ( unbound ) :
17310	return unbound .	return unbound
17311	substitute Iterator for create_bound_method .	create_bound_method = types . MethodType
17312	substitute object for Iterator .	Iterator = object
17313	if not ,	else :
17314	define the function get_unbound_function with an argument unbound .	def get_unbound_function ( unbound ) :
17315	return unbound.im_func .	return unbound . im_func
17316	define the function create_bound_function with 2 arguments : func and obj .	def create_bound_method ( func , obj ) :
17317	call the method types.MethodType with 3 arguments : func , obj and obj.__class__ , return the result .	return types . MethodType ( func , obj , obj . __class__ )
17318	derive the class Iterator from the base class object .	class Iterator ( object ) :
17319	define the method next with an argument self .	def next ( self ) :
17320	call the function type with an argument self , on the result call the method __next__ with an argument self , return the result .	return type ( self ) . __next__ ( self )
17321	substitute callable for callable .	callable = callable
17322	call the function _add_doc with 2 arguments : get_unbound_function and string STR0 .	_add_doc ( get_unbound_function , STR0 )
17323	call the method operator.attrgetter with an argument _meth_func , substitute the result for get_method_function .	get_method_function = operator . attrgetter ( _meth_func )
17324	call the method operator.attrgetter with an argument _meth_self , substitute the result for get_method_self .	get_method_self = operator . attrgetter ( _meth_self )
17325	call the method operator.attrgetter with an argument _func_closure , substitute the result for get_method_closure .	get_function_closure = operator . attrgetter ( _func_closure )
17326	call the method operator.attrgetter with an argument _func_code , substitute the result for get_method_code .	get_function_code = operator . attrgetter ( _func_code )
17327	call the method operator.attrgetter with an argument _func_defaults , substitute the result for get_method_defaults .	get_function_defaults = operator . attrgetter ( _func_defaults )
17328	call the method operator.attrgetter with an argument _func_globals , substitute the result for get_method_globals .	get_function_globals = operator . attrgetter ( _func_globals )
17329	define the function iterkeys with 2 arguments : d and unpacked dictionary kw .	def iterkeys ( d , ** kw ) :
17330	get _iterkeys attribute of the class d , call the result with an argument unpacked dictionary kw , convert the result to a iterable , return it .	return iter ( getattr ( d , _iterkeys ) ( ** kw ) )
17331	define the function itervalues with 2 arguments : d and unpacked dictionary kw .	def itervalues ( d , ** kw ) :
17332	get _itervalues attribute of the class d , call the result with an argument unpacked dictionary kw , convert the result to a iterable , return it .	return iter ( getattr ( d , _itervalues ) ( ** kw ) )
17333	define the function iteritems with 2 arguments : d and unpacked dictionary kw .	def iteritems ( d , ** kw ) :
17334	get _iteritems attribute of the class d , call the result with an argument unpacked dictionary kw , convert the result to a iterable , return it .	return iter ( getattr ( d , _iteritems ) ( ** kw ) )
17335	define the function iterlists with 2 arguments : d and unpacked dictionary kw .	def iterlists ( d , ** kw ) :
17336	get _iterlists attribute of the class d , call the result with an argument unpacked dictionary kw , convert the result to a iterable , return it .	return iter ( getattr ( d , _iterlists ) ( ** kw ) )
17337	if PY3 is true ,	if PY3 :
17338	define the function b with an argument s .	def b ( s ) :
17339	call the method e.encode with an argument string STR0 .	return s . encode ( STR0 )
17340	define the function u with an argument s .	def u ( s ) :
17341	return s .	return s
17342	substitute chr for unichr .	unichr = chr
17343	if second element of sys.version_info is smaller than or equal to integer 1 ,	if sys . version_info [ 1 ] <= 1 :
17344	define the function int2byte with an argument i .	def int2byte ( i ) :
17345	call the function bytes with an argument tuple with an element i , return the result .	return bytes ( ( i , ) )
17346	if not ,	else :
17347	call the method operator.methodcaller with 3 arguments : string STR0 , integer 1 and string STR1 , substitute the result for int2byte .	int2byte = operator . methodcaller ( STR0 , 1 , STR1 )
17348	call te method operator.itemgetter with an argument integer 0 , substitute the result for byte2int .	byte2int = operator . itemgetter ( 0 )
17349	substitute operator.getitem for indexbytes .	indexbytes = operator . getitem
17350	substitute iter for iterbytes .	iterbytes = iter
17351	import io .	import io
17352	substitute io.StringIO for StringIO .	StringIO = io . StringIO
17353	substitute io.BytesIO for BytesIO .	BytesIO = io . BytesIO
17354	if not ,	else :
17355	define the function b with an argument s .	def b ( s ) :
17356	return s .	return s
17357	define the function u with an argument s .	def u ( s ) :
17358	replace every occurrence of raw string STRspecial in s with a raw string '\\\STR , use the result and string STR0 , as arguments for the call to the unicode function , return the result .	return unicode ( s . replace ( STRspecial , STR1 ) , STR0 )
17359	substitute unichr for unichr .	unichr = unichr
17360	substitute chr for int2byte .	int2byte = chr
17361	define the function byte2int with an argument bs .	def byte2int ( bs ) :
17362	get the integer representation of the first element of bs , return it .	return ord ( bs [ 0 ] )
17363	define the function indexbytes with 2 arguments buf and i .	def indexbytes ( buf , i ) :
17364	get the integer representation of the i-th element of buf , return it .	return ord ( buf [ i ] )
17365	define the function iterbytes with an argument buf .	def iterbytes ( buf ) :
17366	convert byte to its integer representation , return all of the results for every byte in buf .	return ( ord ( byte ) for byte in buf )
17367	import StringIO .	import StringIO
17368	assign StringIO.StringIO to StringIO and BytesIO .	StringIO = BytesIO = StringIO . StringIO
17369	call the function _add_doc with 2 arguments : b and string STR0 .	_add_doc ( b , STR0 )
17370	call the function _add_doc with 2 arguments : u and string STR0 .	_add_doc ( u , STR0 )
17371	if PY3 is true ,	if PY3 :
17372	get STR0 attribute from the moves.builtins object , substitute it for exec_ .	exec_ = getattr ( moves . builtins , STR0 )
17373	define the function reraise with 3 arguments : tp , value and tb set to None .	def reraise ( tp , value , tb = None ) :
17374	if value.__traceback__ is not tb ,	if value . __traceback__ is not tb :
17375	raise an value.with_traceback exception with an argument tb .	raise value . with_traceback ( tb )
17376	raise an exception value .	raise value
17377	if not ,	else :
17378	define the function exec with 3 arguments : _code_ , _globs_ set to None and _locs_ set to None .	def exec_ ( _code_ , _globs_ = None , _locs_ = None ) :
17379	if _globs_ is None ,	if _globs_ is None :
17380	call the method sys._getframe with an argument 1 , substitute the result for frame .	frame = sys . _getframe ( 1 )
17381	substitute frame.f_globals for _globs_ .	_globs_ = frame . f_globals
17382	if _locs_ is None ,	if _locs_ is None :
17383	substitute if _locs_ is None for _locs_ .	_locs_ = frame . f_locals
17384	delete frame .	del frame
17385	otherwise if _locs_ is None ,	elif _locs_ is None :
17386	substitute _globs_ with an argument _locs_ .	_locs_ = _globs_
17387	execute code statement STR0 .	exec ( STR0 )
17388	call the function exec_ with an argument string STR0 .	exec_ ( STR0 )
17389	get attribute STR0 from the moves.builtins object , if it exists substitute it for print_ , if not print_ is None .	print_ = getattr ( moves . builtins , STR0 , None )
17390	if print_ is None ,	if print_ is None :
17391	define the function print_ with 2 arguments : unpacked list args and unpacked dictionary kwargs .	def print_ ( * args , ** kwargs ) :
17392	remover STR0 key from the kwargs dictionary , if it exists substitute it for fp , if not substitute sys.stdout for fp .	fp = kwargs . pop ( STR0 , sys . stdout )
17393	if fp is None ,	if fp is None :
17394	return nothing .	return
17395	define the function write with an argument data .	def write ( data ) :
17396	if data is not an instance of basestring ,	if not isinstance ( data , basestring ) :
17397	convert data to string , substitute it for data .	data = str ( data )
17398	if fp is an instance of file and data is an instance of unicode and fp.encoding is not None ,	if ( isinstance ( fp , file ) and isinstance ( data , unicode ) and fp . encoding is not None ) :
17399	get STR0 attribute from fp object , substitute it for errors if it exists , if not errors is None .	errors = getattr ( fp , STR0 , None )
17400	if errors is None ,	if errors is None :
17401	errors is a string STR0 .	errors = STR0
17402	call the method data.encode with 2 arguments : fp.encoding and errors , substitute the result for data .	data = data . encode ( fp . encoding , errors )
17403	write data to fp .	fp . write ( data )
17404	want_unicode is boolean False .	want_unicode = False
17405	remove STR0 key from the kwargs dictionary , if it exists substitute it for sep , if not sep is None .	sep = kwargs . pop ( STR0 , None )
17406	if sep is not None ,	if sep is not None :
17407	if sep is an instance of unicode ,	if isinstance ( sep , unicode ) :
17408	want_unicode is boolean True .	want_unicode = True
17409	otherwise if sep is not an instance of string type ,	elif not isinstance ( sep , str ) :
17410	raise an TypeError exception with an argument string STR0 .	raise TypeError ( STR0 )
17411	remove STR0 key from the kwargs dictionary , if it exists substitute it for end , if not end is None .	end = kwargs . pop ( STR0 , None )
17412	if end is not None ,	if end is not None :
17413	if end is an instance of unicode ,	if isinstance ( end , unicode ) :
17414	want_unicode is boolean True .	want_unicode = True
17415	otherwise if end is not an instance of string type ,	elif not isinstance ( end , str ) :
17416	raise an TypeError exception with an argument string STR0 .	raise TypeError ( STR0 )
17417	if kwargs is true ,	if kwargs :
17418	raise an TypeError exception with an argument string STR0 .	raise TypeError ( STR0 )
17419	if want_unicode is false ,	if not want_unicode :
17420	for every arg in args ,	for arg in args :
17421	if arg is an instance of unicode ,	if isinstance ( arg , unicode ) :
17422	want_unicode is boolean True .	want_unicode = True
17423	break from the loop execution .	break
17424	if want_unicode is true ,	if want_unicode :
17425	convert newline character to unicode and substitute the result for newline .	newline = unicode ( STR0 )
17426	convert whitespace character to unicode and substitute the result for space .	space = unicode ( STR )
17427	if not ,	else :
17428	substitute newline character for newline .	newline = STR0
17429	substitute string STR for space .	space = STR
17430	if sep is None ,	if sep is None :
17431	substitute space for sep .	sep = space
17432	if end is None	if end is None :
17433	substitute space for end .	end = newline
17434	for every i and arg in enumerated iterable args ,	for i , arg in enumerate ( args ) :
17435	if i is true ,	if i :
17436	call the function write with an argument sep .	write ( sep )
17437	call the function write with an argument arg .	write ( arg )
17438	call the function write with an argument end .	write ( end )
17439	call the function _add_doc with 2 arguments : reraise and string STR0 .	_add_doc ( reraise , STR0 )
17440	define the function with_metaclass with 2 arguments meta and unpacked list bases .	def with_metaclass ( meta , * bases ) :
17441	derive the class metaclass form the meta base class .	class metaclass ( meta ) :
17442	substitute type.__call__ for __call__ .	__call__ = type . __call__
17443	substitute type.__init__ for __init__ .	__init__ = type . __init__
17444	define the method __new__ with 4 arguments : cls , name , this_bases and d .	def __new__ ( cls , name , this_bases , d ) :
17445	if this_bases is None ,	if this_bases is None :
17446	call the method type.__new__ with 4 arguments : cls , name , empty tuple and d , return the result .	return type . __new__ ( cls , name , ( ) , d )
17447	call the function meta with 3 arguments : name , base and d .	return meta ( name , bases , d )
17448	return an instance of metaclass class , created with 3 arguments : string STR0 , None and an empty dictionary .	return metaclass ( STR0 , None , { } )
17449	define the function add_metaclass with an argument metaclass .	def add_metaclass ( metaclass ) :
17450	define the function wrapper with an argument cls .	def wrapper ( cls ) :
17451	call the method cls.__dict__.copy substitute the result for orig_vars .	orig_vars = cls . __dict__ . copy ( )
17452	remove STR0 key from the orig_vars dictionary .	orig_vars . pop ( STR0 , None )
17453	remove STR0 key from the orig_vars dictionary .	orig_vars . pop ( STR0 , None )
17454	get the value under the STR0 key of the orig_vars dictionary , substitute it for slots .	slots = orig_vars . get ( STR0 )
17455	if slots is not None ,	if slots is not None :
17456	if slots is an instance of str ,	if isinstance ( slots , str ) :
17457	slots is a list with an element , slots .	slots = [ slots ]
17458	for every slots_var in slots ,	for slots_var in slots :
17459	remove slots_var key from the orig_vars dictionary .	orig_vars . pop ( slots_var )
17460	return an instance of metaclass class , created with 3 arguments : cls.__name__ , cls.__bases__ and orig_vars .	return metaclass ( cls . __name__ , cls . __bases__ , orig_vars )
17461	return wrapper .	return wrapper
17462	if PY3 is true ,	if PY3 :
17463	_assertCountEqual is a strnig STR0 .	_assertCountEqual = STR0
17464	_assertRaisesRegex is a strnig STR0 .	_assertRaisesRegex = STR0
17465	_assertRegex is a strnig STR0 .	_assertRegex = STR0
17466	substitute memoryview for memoryview .	memoryview = memoryview
17467	buffer_types is a tuple with 3 elements : bytes , bytearray and memoryview .	buffer_types = ( bytes , bytearray , memoryview )
17468	if not ,	else :
17469	_assertCountEqual is a strnig STR0 .	_assertCountEqual = STR0
17470	_assertRaisesRegex is a strnig STR0 .	_assertRaisesRegex = STR0
17471	_assertRegex is a strnig STR0 .	_assertRegex = STR0
17472	if sys.platform starts with a string STR0 ,	if sys . platform . startswith ( STR0 ) :
17473	substitute memoryview for memoryview .	memoryview = memoryview
17474	if not ,	else :
17475	substitute buffer for memoryview .	memoryview = buffer
17476	buffer_types is a tuple with 2 elements bytearray and memoryview .	buffer_types = ( bytearray , memoryview )
17477	define the function assertCountEqual with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .	def assertCountEqual ( self , * args , ** kwargs ) :
17478	get _assertCountEqual attribute of the self object , call the result with 2 arguments : unpacked list args , and unpacked dictionary kwargs , return the result .	return getattr ( self , _assertCountEqual ) ( * args , ** kwargs )
17479	define the function assertRaisesRegex with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .	def assertRaisesRegex ( self , * args , ** kwargs ) :
17480	get _assertRaisesRegex attribute of the self object , call the result with 2 arguments : unpacked list args , and unpacked dictionary kwargs , return the result .	return getattr ( self , _assertRaisesRegex ) ( * args , ** kwargs )
17481	define the function assertRegex with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .	def assertRegex ( self , * args , ** kwargs ) :
17482	get _assertRegex attribute of the self object , call the result with 2 arguments : unpacked list args , and unpacked dictionary kwargs , return the result .	return getattr ( self , _assertRegex ) ( * args , ** kwargs )
17483	call the function MovedModule with 2 arguments : strings STR0 and STR1 , use the result as an argument for the call to the add_move function .	add_move ( MovedModule ( STR0 , STR1 ) )
17484	call the function MovedModule with 2 arguments : strings STR0 and STR1 ,	add_move ( MovedModule ( STR0 , STR1 ) )
17485	import module contextlib .	import contextlib
17486	try ,	try :
17487	import threading .	import threading
17488	except ImportError .	except ImportError :
17489	import dummy_threading as threading .	import dummy_threading as threading
17490	derive the class RWLock from the object base class .	class RWLock ( object ) :
17491	define the method __init__ with an argument self .	def __init__ ( self ) :
17492	call the method threading.RLock , substitute the result for self.mutex .	self . mutex = threading . RLock ( )
17493	call the method threading.Semaphore with an argument integer 0 , substitute the result for self.can_read .	self . can_read = threading . Semaphore ( 0 )
17494	call the method threading.Semaphore with an argument integer 0 , substitute the result for self.can_write .	self . can_write = threading . Semaphore ( 0 )
17495	self.active_readers is an integer 0 .	self . active_readers = 0
17496	self.active_writers is an integer 0 .	self . active_writers = 0
17497	self.waiting_readers is an integer 0 .	self . waiting_readers = 0
17498	self.waiting_writers is an integer 0 .	self . waiting_writers = 0
17499	define the method reader_enters with an argument self .	def reader_enters ( self ) :
17500	with self.mutex perform ,	with self . mutex :
17501	if self.active_writers and self.waiting_writers both equal to integer 0 ,	if self . active_writers == 0 and self . waiting_writers == 0 :
17502	increment self.active_readers by 1 .	self . active_readers += 1
17503	call the method self.can_read.release .	self . can_read . release ( )
17504	if not ,	else :
17505	increment self.waiting_readers by 1 .	self . waiting_readers += 1
17506	call the method self.can_read.acquire .	self . can_read . acquire ( )
17507	define the method reader_leaves with an argument self .	def reader_leaves ( self ) :
17508	with self.mutex perform ,	with self . mutex :
17509	decrement self.active_readers by integer 1 ,	self . active_readers -= 1
17510	if self.active_readers equals integer 0 and self.waiting_writers is not equal to integer 0 ,	if self . active_readers == 0 and self . waiting_writers != 0 :
17511	increment self.active_writers by 1 .	self . active_writers += 1
17512	decrement self.waiting_writers by integer 1 ,	self . waiting_writers -= 1
17513	call the method self.can_write.release .	self . can_write . release ( )
17514	contextlib.contextmanager decorator ,	@ contextlib . contextmanager
17515	define the method reader with an argument self .	def reader ( self ) :
17516	call the method self.reader_enters .	self . reader_enters ( )
17517	try ,	try :
17518	yield nothing .	yield
17519	finally perform ,	finally :
17520	call the method self.reader_leaves .	self . reader_leaves ( )
17521	define the method writer_enters with an argument self .	def writer_enters ( self ) :
17522	with self.mutex perform ,	with self . mutex :
17523	if self.active_writers equals integer 0 and self.waiting_writers equals integer 0 and self.active_readers equals integer 0 ,	if self . active_writers == 0 and self . waiting_writers == 0 and self . active_readers == 0 :
17524	increment self.active_writers by integer 1 ,	self . active_writers += 1
17525	call the method self.can_write.release .	self . can_write . release ( )
17526	if not ,	else :
17527	increment self.waiting_writers by integer 1 ,	self . waiting_writers += 1
17528	call the method self.can_write.acquire .	self . can_write . acquire ( )
17529	define the method writer_leaves with an argument self .	def writer_leaves ( self ) :
17530	with self.mutex perform ,	with self . mutex :
17531	decrement self.active_writers by integer 1 ,	self . active_writers -= 1
17532	if self.waiting_writers is not equal to integer 0 ,	if self . waiting_writers != 0 :
17533	increment self.active_writers by integer 1 ,	self . active_writers += 1
17534	decrement self.waiting_writers by integer 1 ,	self . waiting_writers -= 1
17535	call the method self.can_write.release .	self . can_write . release ( )
17536	otherwise if self.waiting_readers is not equal to integer 0 ,	elif self . waiting_readers != 0 :
17537	substitute self.waiting_readers for t .	t = self . waiting_readers
17538	self.waiting_readers is integer 0 .	self . waiting_readers = 0
17539	increment self.active_readers by t .	self . active_readers += t
17540	while t is greater than integer 0 ,	while t > 0 :
17541	call the method self.can_read.release .	self . can_read . release ( )
17542	decrement t by integer 1 ,	t -= 1
17543	contextlib.contextmanager decorator ,	@ contextlib . contextmanager
17544	define the method writer with an argument self .	def writer ( self ) :
17545	call the method self.writer_enters .	self . writer_enters ( )
17546	try ,	try :
17547	yield nothing .	yield
17548	finally perform ,	finally :
17549	call the method self.writer_leaves .	self . writer_leaves ( )
17550	from django.utils import six into default name space .	from django . utils import six
17551	color_names is a tuple with 8 elements : strings STR0 , STR1 , STR2 , STR3 , STR4 , STR5 , STR6 and STR7 .	color_names = ( STR0 , STR1 , STR2 , STR3 , STR4 , STR5 , STR6 , STR7 )
17552	foreground is a dictionary created with elements : x appended to a string STR0 for value under the key x of color_names dictionary , for every x in sequence of integers from 0 to 7 .	foreground = dict ( ( color_names [ x ] , STR0 % x ) for x in range ( 8 ) )
17553	background is a dictionary created with elements : x appended to a string STR0 for value under the key x of color_names dictionary , for every x in sequence of integers from 0 to 7 .	background = dict ( ( color_names [ x ] , STR0 % x ) for x in range ( 8 ) )
17554	RESET is a string STR0 .	RESET = STR0
17555	opt_dict is an dictionary with 5 elements : STR0 for STR1 , STR2 for STR3 , STR4 for STR5 , STR6 for STR7 , and STR8 for STR9 .	opt_dict = { STR0 : STR1 , STR2 : STR3 , STR4 : STR5 , STR6 : STR7 , STR8 : STR9 }
17556	define the method colorize with 3 arguments : text set to an empty string , opts set to an empty tuple and unpacked dictionary kwargs .	def colorize ( text = STR , opts = ( ) , ** kwargs ) :
17557	code_list is an empty list .	code_list = [ ]
17558	if text is an empty string and length of opts equals integer 1 and first element of opts equals string STR0 ,	if text == STR and len ( opts ) == 1 and opts [ 0 ] == STR0 :
17559	format string STR0 with RESET , return the result .	return STR0 % RESET
17560	call the function six.iteritems with an argument kwargs , for every k and v in the result ,	for k , v in six . iteritems ( kwargs ) :
17561	if k equals a string STR0 ,	if k == STR0 :
17562	append value under the key v of foreground dictionary to code_list .	code_list . append ( foreground [ v ] )
17563	otherwise if k equals a string STR0 ,	elif k == STR0 :
17564	append value under the key v of background dictionary to code_list .	code_list . append ( background [ v ] )
17565	for every o in opts ,	for o in opts :
17566	if o is contained in opt_dict ,	if o in opt_dict :
17567	append value under the 0 key of the opt_dict dictionary to code_list .	code_list . append ( opt_dict [ o ] )
17568	if string STR0 is not contained in opts ,	if STR0 not in opts :
17569	if text is true format with it and RESET a string STR0 , if not format it with an empty string and RESET , substitute the result for text .	text = STR0 % ( text or STR , RESET )
17570	join elements of code_list in a string , separated by STR0 , format string STR1 with it , append text to the result if exists , return the string .	return STR0 % ( ( STR1 % STR2 . join ( code_list ) ) , text or STR )
17571	define the function make_style with 2 arguments : opts set to an empty tuple and unpacked dictionary kwargs .	def make_style ( opts = ( ) , ** kwargs ) :
17572	return lambda function with text as argument and return value being result of the function colorize , called with 3 arguments : text , opts and unpacked dictionary kwargs .	return lambda text : colorize ( text , opts , ** kwargs )
17573	NOCOLOR_PALETTE is a string STR0 .	NOCOLOR_PALETTE = STR0
17574	DARK_PALETTE is a string STR0 .	DARK_PALETTE = STR0
17575	LIGHT_PALETTE is a string STR0 .	LIGHT_PALETTE = STR0
17576	PALETTES is a dictionary containing 3 elements , a dictionary with 18 pairs of dictionary value and string keys for NOCOLOR_PALETTE ,	PALETTES = { NOCOLOR_PALETTE : { STR0 : { } , STR1 : { } , STR2 : { } , STR3 : { } , STR4 : { } , STR5 : { } , STR6 : { } , STR7 : { } , STR8 : { } , STR9 : { } , STR10 : { } , STR11 : { } , STR12 : { } , STR13 : { } , STR14 : { } , STR15 : { } , STR16 : { } , STR17 : { } , } , DARK_PALETTE : { STR18 : { STR19 : STR20 , STR21 : ( STR22 , ) } , STR23 : { STR24 : STR25 , STR26 : ( STR27 , ) } , STR28 : { STR29 : STR30 } , STR31 : { STR32 : STR33 , STR34 : ( STR35 , ) } , STR36 : { STR37 : STR38 } , STR39 : { STR40 : STR41 } , STR42 : { STR43 : ( STR44 , ) } , STR45 : { STR46 : ( STR47 , ) } , STR48 : { } , STR49 : { STR50 : STR51 } , STR52 : { STR53 : STR54 } , STR55 : { STR56 : STR57 , STR58 : ( STR59 , ) } , STR60 : { STR61 : STR62 } , STR63 : { STR64 : STR65 , STR66 : ( STR67 , ) } , STR68 : { STR69 : STR70 , STR71 : ( STR72 , ) } , STR73 : { STR74 : ( STR75 , ) } , STR76 : { STR77 : STR78 , STR79 : ( STR80 , ) } , STR81 : { STR82 : STR83 , STR84 : ( STR85 , ) } , } , LIGHT_PALETTE : { STR86 : { STR87 : STR88 , STR89 : ( STR90 , ) } , STR91 : { STR92 : STR93 , STR94 : ( STR95 , ) } , STR96 : { STR97 : STR98 } , STR99 : { STR100 : STR101 , STR102 : ( STR103 , ) } , STR104 : { STR105 : STR106 } , STR107 : { STR108 : STR109 } , STR110 : { STR111 : ( STR112 , ) } , STR113 : { STR114 : ( STR115 , ) } , STR116 : { } , STR117 : { STR118 : STR119 , STR120 : ( STR121 , ) } , STR122 : { STR123 : STR124 } , STR125 : { STR126 : STR127 , STR128 : ( STR129 , ) } , STR130 : { STR131 : STR132 } , STR133 : { STR134 : STR135 , STR136 : ( STR137 , ) } , STR138 : { STR139 : STR140 , STR141 : ( STR142 , ) } , STR143 : { STR144 : ( STR145 , ) } , STR146 : { STR147 : STR148 , STR149 : ( STR150 , ) } , STR151 : { STR152 : STR153 , STR154 : ( STR155 , ) } , } }
17577	a dictionary with 18 pairs of dictionary value and string keys for DARK_PALETTE , and a dictionary with 18 pairs of dictionary value and string keys for LIGHT_PALETTE . substitute DARK_PALETTE for DEFAULT_PALETTE .	DEFAULT_PALETTE = DARK_PALETTE
17578	define the function parse_color_setting with an argument config_string .	def parse_color_setting ( config_string ) :
17579	if config_string is false ,	if not config_string :
17580	return value under the DEFAULT_PALETTE key of the PALETTES dictionary .	return PALETTES [ DEFAULT_PALETTE ]
17581	convert config_string to lowercase and split it by STR0 character , substitute the result for parts .	parts = config_string . lower ( ) . split ( STR0 )
17582	get value under the config_string key of the PALETTES dictionary , call the copy method on the result and substitute it for palette .	palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )
17583	for every part in parts ,	for part in parts :
17584	if part is contained in PALETTES ,	if part in PALETTES :
17585	get the value under the part key of the PALETTES dictionary , update with it palette dictionary .	palette . update ( PALETTES [ part ] )
17586	otherwise if STR0 is contained in part ,	elif STR0 in part :
17587	definition is an empty dictionary ,	definition = { }
17588	split part by STR0 character , substitute the result for role and instructions , respectively .	role , instructions = part . split ( STR0 )
17589	convert role to uppercase .	role = role . upper ( )
17590	split instructions by STR0 character , substitute the result for styles .	styles = instructions . split ( STR0 )
17591	reverse the order of elements of styles .	styles . reverse ( )
17592	remove first element from styles , split it by the STR0 character , substitute the result for colors .	colors = styles . pop ( ) . split ( STR0 )
17593	reverse the order of colors elements ,	colors . reverse ( )
17594	remove the first element from colors , substitute it for fg .	fg = colors . pop ( )
17595	if fg is contained in color_names ,	if fg in color_names :
17596	substitute fg for value under the STR0 key of definition dictionary .	definition [ STR0 ] = fg
17597	if colors is true and last element of colors is contained in color_names ,	if colors and colors [ - 1 ] in color_names :
17598	substitute last element of colors for value under the STR0 key of definition dictionary .	definition [ STR0 ] = colors [ - 1 ]
17599	opts is a tuple created out of elements s , for every s in styles is s is in the keys of the opt_dict dictionary .	opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )
17600	if opts is true ,	if opts :
17601	substitute opts for value under the STR0 key of definition dictionary .	definition [ STR0 ] = opts
17602	if role is contained in value under the NOCOLOR_PALETTE key of the PALETTES dictionary and definition is true ,	if role in PALETTES [ NOCOLOR_PALETTE ] and definition :
17603	substitute definition for value under the role key of palette dictionary .	palette [ role ] = definition
17604	if palette equals value under the NOCOLOR_PALETTE key of the PALETTES dictionary ,	if palette == PALETTES [ NOCOLOR_PALETTE ] :
17605	return None .	return None
17606	return palette .	return palette
17607	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
17608	import module re .	import re
17609	import module unicodedata .	import unicodedata
17610	from gzip import GzipFile into default name space .	from gzip import GzipFile
17611	from io import BytesIO into default name space .	from io import BytesIO
17612	import module warnings .	import warnings
17613	from django.utils.deprecation import RemovedInDjango19Warning into default name space .	from django . utils . deprecation import RemovedInDjango19Warning
17614	from django.utils.encoding import force_text into default name space .	from django . utils . encoding import force_text
17615	from django.utils.functional import allow_lazy and SimpleLazyObject into default name space .	from django . utils . functional import allow_lazy , SimpleLazyObject
17616	from django.utils import six into default name space .	from django . utils import six
17617	from django.utils.six.moves import html_entities into default name space .	from django . utils . six . moves import html_entities
17618	from django.utils.translation import ugettext_lazy , ugettext as _ and pgettext into default name space .	from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext
17619	from django.utils.safestring import mark_safe into default name space .	from django . utils . safestring import mark_safe
17620	if six.PY2 is true ,	if six . PY2 :
17621	from django.utils.encoding import force_unicode .	from django . utils . encoding import force_unicode
17622	if identity lambda function returns false , substitute the x for capfirst , if not call the function force_text with an argument x , convert the first element of the result to uppercase , append to it the rest of the result , substitute it for capfirst .	capfirst = lambda x : x and force_text ( x ) [ 0 ] . upper ( ) + force_text ( x ) [ 1 : ]
17623	call the function allow_lazy with 3 arguments : capfirst and six.text_type .	capfirst = allow_lazy ( capfirst , six . text_type )
17624	call the function re.compile with 2 arguments : raw string STR0 and bitwise OR performed with 2 operands , re.U and re.S , substitute the result for re_words .	re_words = re . compile ( STR0 , re . U | re . S )
17625	call the function re.compile with 2 arguments : raw string STR0 and bitwise OR performed with 2 operands , re.U and re.S , substitute the result for re_chars .	re_chars = re . compile ( STR0 , re . U | re . S )
17626	call the function re.compile with 2 arguments : raw string STR0 and bitwise OR performed with 2 operands , re.U and re.S , substitute the result for re_chars .	re_tag = re . compile ( STR0 , re . S )
17627	call the function re.compile with an argument raw string STR0 , substitute the result for re_newlines .	re_newlines = re . compile ( STR0 )
17628	call the function re.compile with an argument raw string STR0 , substitute the result for re_camel_case .	re_camel_case = re . compile ( STR0 )
17629	define the function wrap with 2 arguments text and width .	def wrap ( text , width ) :
17630	call the function force_text with an argument text , substitute the result for text .	text = force_text ( text )
17631	define the function _generator .	def _generator ( ) :
17632	call the method text.splitlines with an argument boolean True , for every line in the result ,	for line in text . splitlines ( True ) :
17633	if line ends with a new line character substitute width incremented by integer 1 for max_width , if not substitute width for max_width .	max_width = min ( ( line . endswith ( STR0 ) and width + 1 or width ) , width )
17634	while length of line is grater than max_width ,	while len ( line ) > max_width :
17635	get fist max_width incremented by 1 elements from line , find index of the first occurrenece of whitespace from the right side , add integer 1 to it , substitute the result for space .	space = line [ : max_width + 1 ] . rfind ( STR ) + 1
17636	if space equals integer 0 ,	if space == 0 :
17637	find first index of whitespace occurrence in line , add integer 1 to it , substitute the result for space .	space = line . find ( STR ) + 1
17638	if space equals integer 0 ,	if space == 0 :
17639	yield line .	yield line
17640	line is an empty string .	line = STR
17641	break from the loop execution	break
17642	get the first space decremented with integer 1 elements from string line , append newline character to it , and yield the result .	yield STR0 % line [ : space - 1 ]
17643	remove all the elements from space index of line .	line = line [ space : ]
17644	if line ends with a new line character substitute width incremented by integer 1 for max_width , if not substitute width for max_width .	max_width = min ( ( line . endswith ( STR0 ) and width + 1 or width ) , width )
17645	if line is true ,	if line :
17646	yield line .	yield line
17647	call the function _generator , join the result into a string , return the result .	return STR . join ( _generator ( ) )
17648	call the function allow_lazy with 2 arguments : wrap and six.text_type , substitute the result for wrap .	wrap = allow_lazy ( wrap , six . text_type )
17649	derive the class Truncator form the SimpleLazyObject class .	class Truncator ( SimpleLazyObject ) :
17650	define the method __init__ with 2 arguments : self and text .	def __init__ ( self , text ) :
17651	call the method __init__ from the base class of the class Truncator , called with with an argument lambda function which returns result of the force_text function called with an argument text .	super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )
17652	define the method add_truncation_text with 3 arguments : self , text and truncate set to None .	def add_truncation_text ( self , text , truncate = None ) :
17653	if truncate is None ,	if truncate is None :
17654	call the function pgettext with an argument STR0 , STR1 , substitute the result for truncate .	truncate = pgettext ( STR0 , STR1 )
17655	call the function force_text with an argument truncate , substitute the result for truncate .	truncate = force_text ( truncate )
17656	if string STR0 is contained in truncate ,	if STR0 in truncate :
17657	format truncate with a dictionary with an element : text for STR0 , return the result .	return truncate % { STR0 : text }
17658	if text ends with truncate ,	if text . endswith ( truncate ) :
17659	return text .	return text
17660	append truncate to text , return the result .	return STR0 % ( text , truncate )
17661	define the method chars with 4 arguments : self , num , truncate set to None , html set to boolean False .	def chars ( self , num , truncate = None , html = False ) :
17662	convert num to an integer , substitute it for length .	length = int ( num )
17663	call the function unicodedata.normalize with 2 arguments : string STR0 and self._wrapped , substitute the result for text .	text = unicodedata . normalize ( STR0 , self . _wrapped )
17664	substitute length for truncate_len .	truncate_len = length
17665	for every char in result of the self.add_truncation_text , called with 2 arguments : an empty string and truncate .	for char in self . add_truncation_text ( STR , truncate ) :
17666	call the method unicodedata.combining with an argument char , if it evaluates to false ,	if not unicodedata . combining ( char ) :
17667	decrement truncate_len by integer 1 .	truncate_len -= 1
17668	if truncate_len equals integer 0 .	if truncate_len == 0 :
17669	break from the loop execution .	break
17670	if html is true ,	if html :
17671	call the function self._truncate_html with 5 arguments : length , truncate , text , truncate_len and boolean False , return the result .	return self . _truncate_html ( length , truncate , text , truncate_len , False )
17672	call the method self._text_chars with 4 arguments : length , truncate , text and truncate_len , return the result .	return self . _text_chars ( length , truncate , text , truncate_len )
17673	call the function allow_lazy with an argument chars , substitute the result for chars .	chars = allow_lazy ( chars )
17674	define the method _text_chars with 5 arguments : self , length , truncate , text and truncate_len .	def _text_chars ( self , length , truncate , text , truncate_len ) :
17675	s_len is integer 0 .	s_len = 0
17676	end_index is None .	end_index = None
17677	for every i and char in enumerated text ,	for i , char in enumerate ( text ) :
17678	call the function unicodedata.combining with an argument char , if it evaluates to true ,	if unicodedata . combining ( char ) :
17679	skip this loop iteration , s	continue
17680	increment s_len by integer 1 ,	s_len += 1
17681	if end_index is None and s_len is greater than truncate_len ,	if end_index is None and s_len > truncate_len :
17682	substitute i for end_index .	end_index = i
17683	if s_len is greater than length ,	if s_len > length :
17684	call the method self.add_truncation_text with 2 arguments : if end_index is greater than zero , first end_index elements of text , if not an empty string , and truncate , return the result .	return self . add_truncation_text ( text [ : end_index or 0 ] , truncate )
17685	return text .	return text
17686	define the method words with 4 arguments : self , num , truncate set to None , html set to boolean False .	def words ( self , num , truncate = None , html = False ) :
17687	convert num to an integer , substitute the result for length .	length = int ( num )
17688	if html is true ,	if html :
17689	call the method self._truncate_html with 5 arguments : length , truncate , self._wrapped , length and boolean True , return the result .	return self . _truncate_html ( length , truncate , self . _wrapped , length , True )
17690	call the method self._text_words with 2 arguments length and truncate , return the result .	return self . _text_words ( length , truncate )
17691	call the function allow_lazy with an argument words , substitute the result for words .	words = allow_lazy ( words )
17692	define the method _text_words with 3 arguments : self , length and truncate .	def _text_words ( self , length , truncate ) :
17693	split self._wrapped into words , substitute the result for words .	words = self . _wrapped . split ( )
17694	if length of words is greater than length ,	if len ( words ) > length :
17695	substitute first length elements of words for words .	words = words [ : length ]
17696	call the method self.add_truncation_text with 2 arguments : elements of words joined in a string , separated with whitespaces , and truncate , return the result .	return self . add_truncation_text ( STR . join ( words ) , truncate )
17697	return elements of words joined in a string , separated with whitespaces .	return STR . join ( words )
17698	define the method _truncate_html with 6 arguments : self , length , truncate , text , truncate_len and words .	def _truncate_html ( self , length , truncate , text , truncate_len , words ) :
17699	if words is not empty and length is smaller than or equal to integer 0 ,	if words and length <= 0 :
17700	return an empty string .	return STR
17701	html4_singlets is a tuple with 9 elements : strings STR , STR0 , STR1 , STR2 , STR3 , STR4 , STR5 , STR6 and STR7 .	html4_singlets = ( STR , STR0 , STR1 , STR2 , STR3 , STR4 , STR5 , STR6 , STR7 )
17702	pos is equal to integer 0 .	pos = 0
17703	end_text_pos is equal to integer 0 .	end_text_pos = 0
17704	current_len is equal to integer 0 .	current_len = 0
17705	open_tags is an empty list .	open_tags = [ ]
17706	if words is true , substitute re_words for regex , if not substitute re_chars for regex .	regex = re_words if words else re_chars
17707	while current_len is smaller than or equal to length ,	while current_len <= length :
17708	call the method regex.search with 2 arguments : text and pos .	m = regex . search ( text , pos )
17709	if m is false ,	if not m :
17710	break from the loop execution ,	break
17711	call the method m.end with an argument integer 0 , substitute the result for pos .	pos = m . end ( 0 )
17712	call the function m.group , if the result evaluates to true ,	if m . group ( 1 ) :
17713	increment current_len by integer 1 ,	current_len += 1
17714	if current_len equals truncate_len ,	if current_len == truncate_len :
17715	substitute pos for end_text_pos .	end_text_pos = pos
17716	skip this loop iteration .	continue
17717	call the method m.group with an argument integer 0 , use it as an argument for the call to the re_tag.match function , substitute the result for tag .	tag = re_tag . match ( m . group ( 0 ) )
17718	if tag is false or current_len is greater or equal to truncate_len ,	if not tag or current_len >= truncate_len :
17719	skip this loop iteration .	continue
17720	call the method tag.groups , substitute the result for closing_tag , tagname and self_closing , respectively .	closing_tag , tagname , self_closing = tag . groups ( )
17721	convert tagname to lowercase , substitute it for tagname .	tagname = tagname . lower ( )
17722	if self_closing is true or tagname is contained in html4_singlets ,	if self_closing or tagname in html4_singlets :
17723	do nothing .	pass
17724	otherwise if closing_tag is true ,	elif closing_tag :
17725	try ,	try :
17726	get the index of the first occurrence of tagname , substitute it for i .	i = open_tags . index ( tagname )
17727	if ValueError exception is caught ,	except ValueError :
17728	do nothing .	pass
17729	if not ,	else :
17730	create a list out of open_tags elements form ( i+1 ) -th index to the end , substitute it for open_tags .	open_tags = open_tags [ i + 1 : ]
17731	if not ,	else :
17732	insert tagname at the beginning of open_tags .	open_tags . insert ( 0 , tagname )
17733	if current_len is smaller than or equal to length ,	if current_len <= length :
17734	return text .	return text
17735	create a list out of fist end_text_pos text elemnts , substitue it for out .	out = text [ : end_text_pos ]
17736	call the method self.add_truncation_text with 2 arguments : an empty string and truncate , substitute it for truncate_text .	truncate_text = self . add_truncation_text ( STR , truncate )
17737	if truncate_text is true ,	if truncate_text :
17738	append truncate_text to out .	out += truncate_text
17739	for every tag in open_tags ,	for tag in open_tags :
17740	replace STR0 in string STR1 with tag , append the result to out .	out += STR0 % tag
17741	return out .	return out
17742	define the function get_valid_filename with an argument s .	def get_valid_filename ( s ) :
17743	call the function force_text with an argument s , strip the result of whitespaces from both ends , replace every occurrence of whitespaces in the previous result for STR0 , substitute the result for s .	s = force_text ( s ) . strip ( ) . replace ( STR , STR0 )
17744	call the function re.sub with 3 arguments : raw string STR0 , an empty string and s , return the result .	return re . sub ( STR0 , STR , s )
17745	call the function allow_lazy with 2 arguments : get_valid_filename and six.text_type , substitute the result for get_valid_filename .	get_valid_filename = allow_lazy ( get_valid_filename , six . text_type )
17746	define the function get_text_list with 2 arguments : list_ and last_word set to result of the function ugettext_lazy called with an argument string STR0 .	def get_text_list ( list_ , last_word = ugettext_lazy ( STR0 ) ) :
17747	is length of list_ equals integer 0 ,	if len ( list_ ) == 0 :
17748	return an empty string .	return STR
17749	if length of list_ equals integer 1 ,	if len ( list_ ) == 1 :
17750	call the function force_text with first element of list_ as an argument , return the result .	return force_text ( list_ [ 0 ] )
17751	return a string STR0 formated with 3 elements : result of the function force_text called with an argument i , separated by result of the function _ called with an argument string STR1 , for every i in list_ without last element , result of the function force_text called with an argument last_word , result of the function force_text called with an argument : last element of list_ .	return STR0 % ( _ ( STR1 ) . join ( force_text ( i ) for i in list_ [ : - 1 ] ) , force_text ( last_word ) , force_text ( list_ [ - 1 ] ) )
17752	call the function allow_lazy with 2 arguments : get_text_list and six.text_type , substitute the result for get_text_list .	get_text_list = allow_lazy ( get_text_list , six . text_type )
17753	define the function normalize_newlines with an argument text .	def normalize_newlines ( text ) :
17754	call the function force_text with an argument text , substitute the result for text .	text = force_text ( text )
17755	call the method re_newlines.sub with 2 arguments : STR0 and text , return the result .	return re_newlines . sub ( STR0 , text )
17756	call the function allow_lazy with 2 arguments : normalize_newlines and six.text_type , substitute the result for normalize_newlines .	normalize_newlines = allow_lazy ( normalize_newlines , six . text_type )
17757	define the function phone2numeric with an argument phone .	def phone2numeric ( phone ) :
17758	char2number is an dictionary , with 26 elements : 2 for STR0 , 2 for STR , 2 for STR1 , 3 for STR2 , 3 for STR3 , 3 for STR4 , 4 for STR5 , 4 for STR6 , 4 for STR7 , 4 for STR8 , 5 for STR9 , 5 for STR10 , 5 for STR11 , 6 for STR12 , 6 for STR13 , 6 for STR14 , 7 for STR15 , 7 for STR , 7 for STR , 7 for STR16 , 7 for STR17 , 8 for STR18 , 8 for STR19 , 8 for STR20 , 9 for STR21 , 9 for STR22 , 9 for STR23 and 9 for STR24 .	char2number = { STR0 : STR1 , STR : STR2 , STR3 : STR4 , STR5 : STR6 , STR7 : STR8 , STR9 : STR10 , STR11 : STR12 , STR13 : STR14 , STR15 : STR16 , STR17 : STR18 , STR19 : STR20 , STR21 : STR22 , STR23 : STR24 , STR25 : STR26 , STR27 : STR28 , STR29 : STR30 , STR31 : STR32 , STR : STR33 , STR34 : STR35 , STR36 : STR37 , STR38 : STR39 , STR40 : STR41 , STR42 : STR43 , STR44 : STR45 , STR46 : STR47 , STR48 : STR49 }
17759	for every c in phone converted to lowercase , join the value under the c key of the char2number dictionary into a string , return it .	return STR . join ( char2number . get ( c , c ) for c in phone . lower ( ) )
17760	call the function allow_lazy with an argument phone2numeric , substitute the result for phone2numeric .	phone2numeric = allow_lazy ( phone2numeric )
17761	define the function compress_string with an argument s .	def compress_string ( s ) :
17762	zbuf is an instance of BytesIO class .	zbuf = BytesIO ( )
17763	zfile is an instance of GzipFile class , created with 3 arguments : mode set to string STR0 , compresslevel set to integer 6 , and fileobj set to zbuf .	zfile = GzipFile ( mode = STR0 , compresslevel = 6 , fileobj = zbuf )
17764	call the method zfile.write with an argument s .	zfile . write ( s )
17765	call the method zfile.close .	zfile . close ( )
17766	call the method zbuf.getvalue , return the result .	return zbuf . getvalue ( )
17767	derive the class StreamingBuffer from the object base class .	class StreamingBuffer ( object ) :
17768	define the method __init__ with an argument self .	def __init__ ( self ) :
17769	self.vals is an empty list .	self . vals = [ ]
17770	define the method write with 2 arguments : self and val .	def write ( self , val ) :
17771	append val to self.vals .	self . vals . append ( val )
17772	define the method read with an argument self .	def read ( self ) :
17773	join elements of self.vals into a bytes string , substitute the result for ret .	ret = STR . join ( self . vals )
17774	self.vals is an empty list .	self . vals = [ ]
17775	return ret .	return ret
17776	define the method flush with an argument self .	def flush ( self ) :
17777	return nothing .	return
17778	define the method close with an argument self .	def close ( self ) :
17779	return nothing .	return
17780	define the function compress_sequence with an argument sequence .	def compress_sequence ( sequence ) :
17781	buf is an instance of StreamingBuffer class .	buf = StreamingBuffer ( )
17782	zfile is an instance of GzipFile class , created with 3 arguments : mode set to string STR0 , compresslevel set to integer 6 , and fileobj set to buf .	zfile = GzipFile ( mode = STR0 , compresslevel = 6 , fileobj = buf )
17783	read data from buf file stream , yield the result .	yield buf . read ( )
17784	for every item in sequence ,	for item in sequence :
17785	write item to zfile stream .	zfile . write ( item )
17786	flush zfile stream buffer .	zfile . flush ( )
17787	read data from buf , yield the result .	yield buf . read ( )
17788	close zfile stream .	zfile . close ( )
17789	read data from buf , yield the result .	yield buf . read ( )
17790	call the function re.compile with an argument string STR0 , substitute the result for ustring_re .	ustring_re = re . compile ( STR0 )
17791	define the function javascript_quote with 2 arguments : s and quote_double_quotes set to boolean False .	def javascript_quote ( s , quote_double_quotes = False ) :
17792	msg is an string STR0 .	msg = ( STR0 )
17793	call the function warnings.warn with 3 arguments : msg , RemovedInDjango19Warning and stacklevel as integer 2 .	warnings . warn ( msg , RemovedInDjango19Warning , stacklevel = 2 )
17794	define the function fix with an argument match .	def fix ( match ) :
17795	get the unicode representation of result of the method match.group called with an integer 1 , format with in a string STR0 , return the result .	return STR0 % ord ( match . group ( 1 ) )
17796	if type of s equals bytes ,	if type ( s ) == bytes :
17797	call the method s.decode with an argument string STR0 , substitute the result for s .	s = s . decode ( STR0 )
17798	otherwise if , type of s doesnt equal to six.text_type ,	elif type ( s ) != six . text_type :
17799	raise an TypeError with an argument s .	raise TypeError ( s )
17800	replace every occurrence of STRspecial in s with '\\\STR .	s = s . replace ( STRspecial , STR0 )
17801	replace every occurrence of STRspecial in s with STR0 .	s = s . replace ( STRspecial , STR0 )
17802	replace every occurrence of STR0 in s with STR1 .	s = s . replace ( STR0 , STR1 )
17803	replace every occurrence of STR0 in s with STR1 .	s = s . replace ( STR0 , STR1 )
17804	replace every occurrence of STR in s with STR0 .	s = s . replace ( STR , STR0 )
17805	replace every occurrence of STR0 in s with STR1 .	s = s . replace ( STR0 , STR1 )
17806	if quote_double_quotes is true ,	if quote_double_quotes :
17807	replace every occurrence of STR in s with STR0 .	s = s . replace ( STR , STR0 )
17808	call the method ustring_re.sub with 2 arguments : fix and s , return the result .	return ustring_re . sub ( fix , s )
17809	call the function allow_lazy with 2 arguments : javascript_quote and six.text_type , substitute the result for javascript_quote .	javascript_quote = allow_lazy ( javascript_quote , six . text_type )
17810	call the function re.compile with 2 arguments : raw string STR0 ] * ( ? : ( ? : STR1\\ ] |\\ . ) * STR2 ] * ) + ) | \+ ) '' , and re.VERBOSE , substitute the result for smart_split_re .	smart_split_re = re . compile ( STR0 , re . VERBOSE )
17811	define the function smart_split with an argument text .	def smart_split ( text ) :
17812	call the function force_text with an argument text , substitute the result for text .	text = force_text ( text )
17813	call the method smart_split_re.finditer with an argument text , for every bit in result ,	for bit in smart_split_re . finditer ( text ) :
17814	call the method bit.group with an argument integer 0 , yield the result .	yield bit . group ( 0 )
17815	define the function _replace_entity with an argument match .	def _replace_entity ( match ) :
17816	call the method match.group with an argument integer 1 , substitute the result for text .	text = match . group ( 1 )
17817	if first element of text equals STR0 ,	if text [ 0 ] == STR0 :
17818	remove first element of text .	text = text [ 1 : ]
17819	try ,	try :
17820	if first element of text is contained in STR0 .	if text [ 0 ] in STR0 :
17821	convert text without first element to hexadecimal integer , substitute it for c .	c = int ( text [ 1 : ] , 16 )
17822	if nor ,	else :
17823	convert text to an integer , substitute it for c .	c = int ( text )
17824	call the method six.unichr with an argument c , return the result .	return six . unichr ( c )
17825	if ValueError exception is caught ,	except ValueError :
17826	call the method match.group with an argument integer 0 , return the result .	return match . group ( 0 )
17827	if not ,	else :
17828	try ,	try :
17829	call the function six.unichr with value under the text key of the html_entities.name2codepoint dictionary , return the result .	return six . unichr ( html_entities . name2codepoint [ text ] )
17830	if OverflowError or ValueError exceptions are caught ,	except ( ValueError , KeyError ) :
17831	call the method match.group with an argument integer 0 , return the result .	return match . group ( 0 )
17832	call the method re.compile with an argument raw string STR0 , substitute the result for _entity_re .	_entity_re = re . compile ( STR0 )
17833	define the function unescape_entities with an argument text .	def unescape_entities ( text ) :
17834	call the method _entity_re.sub with 2 arguments : _replace_entity and text , return the result .	return _entity_re . sub ( _replace_entity , text )
17835	call the function allow_lazy with 2 arguments : unescape_entities and six.text_type , substitute the result for unescape_entities .	unescape_entities = allow_lazy ( unescape_entities , six . text_type )
17836	define the function unescape_string_literal with an argument s .	def unescape_string_literal ( s ) :
17837	if first element of s is not contained in `` STR '' or last element of s is not equal to first element of s ,	if s [ 0 ] not in "STR" or s [ - 1 ] != s [ 0 ] :
17838	raise an ValueError exception wit an argument string STR0 , where STR1 is replaced with s .	raise ValueError ( STR0 % s )
17839	substitute first element of s for quote .	quote = s [ 0 ]
17840	remove first and last elements of s , replace every occurrence of string STR0 formated with quote with quote , replace every occurrence of raw string STRspecial in the result with string '\STR , return the result .	return s [ 1 : - 1 ] . replace ( STR0 % quote , quote ) . replace ( STRspecial , STRspecial )
17841	call the function allow_lazy with an argument unescape_string_literal , substitute the result for unescape_string_literal .	unescape_string_literal = allow_lazy ( unescape_string_literal )
17842	define the function slugify with an argument value .	def slugify ( value ) :
17843	call the method unicodedata.normalize with 2 arguments : string STR0 and value , encode the result with 2 arguments : string STR1 , and string STR2 , call the method decode on the result with an argument string STR3 , substitute the result for value .	value = unicodedata . normalize ( STR0 , value ) . encode ( STR1 , STR2 ) . decode ( STR3 )
17844	call the method re.sub with 3 arguments : string STR0 , empty string and value , strip the result of whitespaces from both ends , and convert it to lowercase , substitute the result for value .	value = re . sub ( STR0 , STR , value ) . strip ( ) . lower ( )
17845	call the function re.sub with 3 arguments : string STR0 , string STR1 and value , use the result as an argument for the call to the , mark_safe function , return the result .	return mark_safe ( re . sub ( STR0 , STR1 , value ) )
17846	call the function allow_lazy with 2 arguments : slugify and six.text_type , substitute the result slugify .	slugify = allow_lazy ( slugify , six . text_type )
17847	define the function camel_case_to_spaces with an argument value .	def camel_case_to_spaces ( value ) :
17848	call the method re_camel_case.sub with 2 arguments : raw string STR0 and value , strip the result of whitespaces from both ends ,	return re_camel_case . sub ( STR0 , value ) . strip ( ) . lower ( )
17849	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
17850	import module datetime .	import datetime
17851	from django.utils.html import avoid_wrapping into default name space .	from django . utils . html import avoid_wrapping
17852	from django.utils.timezone import is_aware and utc into default name space .	from django . utils . timezone import is_aware , utc
17853	from django.utils.translation import ugettext and ungettext_lazy into default name space .	from django . utils . translation import ugettext , ungettext_lazy
17854	define the function timesince with d , now defaulting to None , reversed defaulting to False as arguments .	def timesince ( d , now = None , reversed = False ) :
17855	chunks is a tuple containing 6 initial tuples :	chunks = ( ( 60 * 60 * 24 * 365 , ungettext_lazy ( STR0 , STR1 ) ) , ( 60 * 60 * 24 * 30 , ungettext_lazy ( STR2 , STR3 ) ) , ( 60 * 60 * 24 * 7 , ungettext_lazy ( STR4 , STR5 ) ) , ( 60 * 60 * 24 , ungettext_lazy ( STR6 , STR7 ) ) , ( 60 * 60 , ungettext_lazy ( STR8 , STR9 ) ) , ( 60 , ungettext_lazy ( STR10 , STR11 ) ) )
17856	result of multiplication of integers : 60,60,24,365 , and return value of ungettext_lazy with 2 arguments : STR0 , STR1 , result of multiplication of integers : 60,60,24,30 , and return value of ungettext_lazy with 2 arguments : STR2 , STR3 , result of multiplication of integers : 60,60,24,7 , and return value of ungettext_lazy with 2 arguments : STR4 , STR5 , result of multiplication of integers : 60,60,24 , and return value of ungettext_lazy with 2 arguments : STR6 , STR7 , result of multiplication of integers : 60,60 , and return value of ungettext_lazy with 2 arguments : STR8 , STR9 , result of multiplication of integers : 60 , and return value of ungettext_lazy with 2 arguments : STR10 , STR11 , if d is not an instance of datetime.datetime ,	if not isinstance ( d , datetime . datetime ) :
17857	call the function datetime.datetime with 3 arguments , d.year , d.month and d.day , substitute the result for d .	d = datetime . datetime ( d . year , d . month , d . day )
17858	if now equals to boolean True and now is not an instance of datetime.datetime ,	if now and not isinstance ( now , datetime . datetime ) :
17859	call the function datetime.datetime with 3 arguments , now.year , now.month and now.day , substitute the result for now .	now = datetime . datetime ( now . year , now . month , now . day )
17860	if now is false ,	if not now :
17861	call the function datetime.datetime with utc as argument if call to the is_aware ( d ) returns True , if not None is the argument , store the result in now .	now = datetime . datetime . now ( utc if is_aware ( d ) else None )
17862	if reversed is True substitute difference of d and now for delta , if not substitute the difference of now and d for delta .	delta = ( d - now ) if reversed else ( now - d )
17863	multiply delta.days , integer 24 , integer 60 and integer 60 add delta.seconds to it , substitute the result for since .	since = delta . days * 24 * 60 * 60 + delta . seconds
17864	if since is lesser or equal to integer 0 ,	if since <= 0 :
17865	call the function ugettext with STR0 as argument , use the result as the argument for the call to the avoid_wrapping function , return the result .	return avoid_wrapping ( ugettext ( STR0 ) )
17866	for every i and tuple containing 2 elements : seconds and name , in enumerated chunks ,	for i , ( seconds , name ) in enumerate ( chunks ) :
17867	divide since by seconds , store the floored result in count .	count = since // seconds
17868	if count does not equals to integer 0 ,	if count != 0 :
17869	break the execution of the smallest enclosing loop .	break
17870	use the remainder of the division of name by count as the argument for the call to the avoid_wrapping function , store the result in result .	result = avoid_wrapping ( name % count )
17871	if i incremented by 1 is lesser than length of chunks ,	if i + 1 < len ( chunks ) :
17872	get the element of chunks at the ( i+1 ) -the index , assign it to the seconds2 and name2 , respectively .	seconds2 , name2 = chunks [ i + 1 ]
17873	multiply seconds by count , subtract it from since , divide the result by seconds2 , store the floored result in count2 .	count2 = ( since - ( seconds * count ) ) // seconds2
17874	if count2 does not equals to integer 0 ,	if count2 != 0 :
17875	call avoid_wrapping function with name2 modulus count2 as argument , call the ugettext with STR0 as argument , add previous 2 results , increment variable result by it .	result += ugettext ( STR0 ) + avoid_wrapping ( name2 % count2 )
17876	return result .	return result
17877	define the function timeuntil with 2 arguments , d and now defaulting to none .	def timeuntil ( d , now = None ) :
17878	evaluate the function timesince with d , now and reversed set to boolean true as arguments , return the result .	return timesince ( d , now , reversed = True )
17879	from datetime import datetime , timedelta and tzinfo into default name space .	from datetime import datetime , timedelta , tzinfo
17880	from threading import local into default name space .	from threading import local
17881	import module sys .	import sys
17882	import module time as _time .	import time as _time
17883	try ,	try :
17884	import pytz .	import pytz
17885	if ImportError exception is caught ,	except ImportError :
17886	pytz is None .	pytz = None
17887	from django.conf import settings into default name space .	from django . conf import settings
17888	from django.utils import six into default name space .	from django . utils import six
17889	__all__ is a list with 15 elements : strings STR0 , STR1 , STR2 , STR3 , STR4 , STR5 , STR6 , STR7 , STR8 , STR9 , STR10 , STR11 , STR12 , STR13 and STR14 .	__all__ = [ STR0 , STR1 , STR2 , STR3 , STR4 , STR5 , STR6 , STR7 , STR8 , STR9 , STR10 , STR11 , STR12 , STR13 , STR14 , ]
17890	call the function timedelta with an argument integer 0 , substitute the result for ZERO .	ZERO = timedelta ( 0 )
17891	derive the class UTC from the tzinfo base class .	class UTC ( tzinfo ) :
17892	define the method __repr__ with an argument self .	def __repr__ ( self ) :
17893	return a string STR0 .	return STR0
17894	define the method utcoffset with 2 arguments self and dt .	def utcoffset ( self , dt ) :
17895	return ZERO .	return ZERO
17896	define the method tzname with 2 arguments self and dt .	def tzname ( self , dt ) :
17897	return a string STR0 .	return STR0
17898	define the method dst with 2 arguments self and dt .	def dst ( self , dt ) :
17899	return ZERO .	return ZERO
17900	derive the class FixedOffset from the tzinfo base class .	class FixedOffset ( tzinfo ) :
17901	define the method __init__ with 3 arguments : self , offset set to None , name set to None .	def __init__ ( self , offset = None , name = None ) :
17902	if offset is not None ,	if offset is not None :
17903	call the function timedelta with an argument minutes set to offset , substitute the result for self.__offset .	self . __offset = timedelta ( minutes = offset )
17904	if name is not None ,	if name is not None :
17905	substitute name for self.__name .	self . __name = name
17906	define the method utcoffset with 2 arguments : self and dt .	def utcoffset ( self , dt ) :
17907	return self.__offset .	return self . __offset
17908	define the method tzname with 2 arguments : self and dt .	def tzname ( self , dt ) :
17909	return self.__name__ .	return self . __name__
17910	define the method dst with 2 arguments : self and dt .	def dst ( self , dt ) :
17911	return ZERO .	return ZERO
17912	derive the class ReferenceLocalTimezone from the tzinfo base class .	class ReferenceLocalTimezone ( tzinfo ) :
17913	define the method __init__ with an argument self .	def __init__ ( self ) :
17914	call the function timedelta with an argument seconds set to negative _time.timezone , substitute the result for self.STDOFFSET .	self . STDOFFSET = timedelta ( seconds = - _time . timezone )
17915	if _time.daylight is true ,	if _time . daylight :
17916	call the function timedelta with an argument seconds set to negative _time.altzone , substitute the result for self.DSTOFFSET .	self . DSTOFFSET = timedelta ( seconds = - _time . altzone )
17917	if not ,	else :
17918	substitute self.STDOFFSET for self.DSTOFFSET .	self . DSTOFFSET = self . STDOFFSET
17919	subtract self.STDOFFSET with self.DSTOFFSET , substitute the result for self.DSTDIFF .	self . DSTDIFF = self . DSTOFFSET - self . STDOFFSET
17920	call the method tzinfo.__init__ with an argument self .	tzinfo . __init__ ( self )
17921	define the method utcoffset with 2 arguments : self and dt .	def utcoffset ( self , dt ) :
17922	call the method self._isdst with an argument dt , if it evaluates to true ,	if self . _isdst ( dt ) :
17923	return self.DSTOFFSET .	return self . DSTOFFSET
17924	if not ,	else :
17925	return self.STDOFFSET .	return self . STDOFFSET
17926	define the method utcoffset with 2 arguments : self and dt .	def dst ( self , dt ) :
17927	call the method self._isdst with an argument dt , if it evaluates to true ,	if self . _isdst ( dt ) :
17928	return self.DSTDIFF .	return self . DSTDIFF
17929	if not ,	else :
17930	return ZERO .	return ZERO
17931	define the method tzname with 2 arguments : self and dt .	def tzname ( self , dt ) :
17932	call the method self._isdst with an argument dt , use it as an key to get the value from the _time.tzname dictionary , return it .	return _time . tzname [ self . _isdst ( dt ) ]
17933	define the method _isdst with 2 arguments : self and dt .	def _isdst ( self , dt ) :
17934	tt is a tuple with 9 elements : dt.year , dt.month , dt.day , dt.hour , dt.minute , dt.second , result of the method dt.weekday , ingeter 0 and integer 0 .	tt = ( dt . year , dt . month , dt . day , dt . hour , dt . minute , dt . second , dt . weekday ( ) , 0 , 0 )
17935	call the method _time.mktime with an argument tt , substitute the result for stamp .	stamp = _time . mktime ( tt )
17936	call the method _time.localtime with an argument stamp , substitute the result for tt .	tt = _time . localtime ( stamp )
17937	if tt.tm_isdst is greater than integer 0 , return the result .	return tt . tm_isdst > 0
17938	derive the class LocalTimezone from the ReferenceLocalTimezone base class .	class LocalTimezone ( ReferenceLocalTimezone ) :
17939	define the method tzname with 2 arguments : self and dt .	def tzname ( self , dt ) :
17940	if dt is None , is_dst is boolean False , otherwise call the method _isdst with an argument dt , substitute the result for is_dst .	is_dst = False if dt is None else self . _isdst ( dt )
17941	return the value under the is_dst key of the _time.tzname dictionary .	return _time . tzname [ is_dst ]
17942	define the method _isdst with 2 arguments : self and dt .	def _isdst ( self , dt ) :
17943	try ,	try :
17944	call the method _isdst with an argument dt from the base class of the class LocalTimezone , return the result .	return super ( LocalTimezone , self ) . _isdst ( dt )
17945	if OverflowError or ValueError , renamed to exc , exceptions are caught ,	except ( OverflowError , ValueError ) as exc :
17946	get the type of the exc object , substitute it for exc_type .	exc_type = type ( exc )
17947	call the function exc_type with an argument string STR0 , replace STR1 with dt , substitute the result for exc_value .	exc_value = exc_type ( STR0 % dt )
17948	substitute exc for exc_value.__cause__ .	exc_value . __cause__ = exc
17949	call the function six.reraise with 3 arguments : exc_type , exc_value and third element of the result of the method sys.exc_info .	six . reraise ( exc_type , exc_value , sys . exc_info ( ) [ 2 ] )
17950	if pytz is true , substitute pytz.utc for utc , otherwise substitute result of the function UTC for utc .	utc = pytz . utc if pytz else UTC ( )
17951	define the function get_fixed_timezone with an argument offset .	def get_fixed_timezone ( offset ) :
17952	if offset is an instance of timedelta class ,	if isinstance ( offset , timedelta ) :
17953	substitute offset.seconds for offset .	offset = offset . seconds // 60
17954	if offset is smaller than integer 0 , sign is STR0 , otherwise sign is STR1 .	sign = STR0 if offset < 0 else STR1
17955	divide absolute offset by module 60 , use the result to format string STR0 , substitute it for hhmm .	hhmm = STR0 % divmod ( abs ( offset ) , 60 )
17956	sum sign and hhmm , substitute the result for name .	name = sign + hhmm
17957	return an instance of FixedOffset class , created with 2 arguments : offset and name .	return FixedOffset ( offset , name )
17958	_localtime is None .	_localtime = None
17959	define the function get_default_timezone .	def get_default_timezone ( ) :
17960	use global variable _localtime .	global _localtime
17961	if _localtime is None ,	if _localtime is None :
17962	if settings.TIME_ZONE is an instance of six.string_types and pytz is not None ,	if isinstance ( settings . TIME_ZONE , six . string_types ) and pytz is not None :
17963	call the method pytz.timezone with an argument settings.TIME_ZONE , substitute the result for _localtime .	_localtime = pytz . timezone ( settings . TIME_ZONE )
17964	if not ,	else :
17965	_localtime is an instance of LocalTimezone class .	_localtime = LocalTimezone ( )
17966	return _localtime .	return _localtime
17967	define the function get_default_timezone_name .	def get_default_timezone_name ( ) :
17968	call the function get_default_timezone , use the result as an argument for the call to the function _get_timezone_name , return the result .	return _get_timezone_name ( get_default_timezone ( ) )
17969	call the method local , substitute the result for _active .	_active = local ( )
17970	define the function get_current_timezone .	def get_current_timezone ( ) :
17971	get STR0 attribute of the _active object , if it exists return it , if not , call the function get_default_timezone and return the result .	return getattr ( _active , STR0 , get_default_timezone ( ) )
17972	define the function get_current_timezone_name .	def get_current_timezone_name ( ) :
17973	call the function get_current_timezone , use the result as an argument for the call to the function _get_timezone_name , return the result .	return _get_timezone_name ( get_current_timezone ( ) )
17974	define the function _get_timezone_name with an argument timezone .	def _get_timezone_name ( timezone ) :
17975	try ,	try :
17976	return timezone.zone .	return timezone . zone
17977	if AttributeError exception is caught ,	except AttributeError :
17978	call the method timezone.tzname with an argument None , return the result .	return timezone . tzname ( None )
17979	define the function activate with an argument timezone .	def activate ( timezone ) :
17980	if timezone is an instance of tzinfo ,	if isinstance ( timezone , tzinfo ) :
17981	substitute timezone for _active.value .	_active . value = timezone
17982	otherwise if timezone is an instance of six.string_types and pytz is not None ,	elif isinstance ( timezone , six . string_types ) and pytz is not None :
17983	call the method pytz.timezone with an argument timezone , substitute the result for _active.value .	_active . value = pytz . timezone ( timezone )
17984	if not ,	else :
17985	raise an ValueError with an argument string STR0 , substitute STR1 with timezone .	raise ValueError ( STR0 % timezone )
17986	define the function deactivate .	def deactivate ( ) :
17987	if active has an attribute STR0 ,	if hasattr ( _active , STR0 ) :
17988	delete _active.value .	del _active . value
17989	derive the class override from the object base class .	class override ( object ) :
17990	define the method __init__ with 2 arguments : self and timezone .	def __init__ ( self , timezone ) :
17991	substitute timezone for self.timezone .	self . timezone = timezone
17992	get STR0 attribute of the _active object	self . old_timezone = getattr ( _active , STR0 , None )
17993	define the method __enter__ with an argument self .	def __enter__ ( self ) :
17994	if self.timezone is None ,	if self . timezone is None :
17995	call the method deactivate .	deactivate ( )
17996	if not ,	else :
17997	call the method activate with an argument self.timezone .	activate ( self . timezone )
17998	define the method __exit__ with 4 arguments self , exc_type , exc_value and traceback .	def __exit__ ( self , exc_type , exc_value , traceback ) :
17999	if self.old_timezone is None ,	if self . old_timezone is None :
18000	call the method deactivate .	deactivate ( )
18001	if not ,	else :
18002	substitute self.old_timezone for _active.value .	_active . value = self . old_timezone
18003	define the function template_localtime with 2 arguments : value and use_tz set to None .	def template_localtime ( value , use_tz = None ) :
18004	if value is an instance of datetime and settings.USE_TZ if use_tz is None else use_tz and call to the function is_naive , with an argument value evaluates to false , and if STR0 attribute of value object doesnt exists , or is it does is boolean True , should_convert is boolean True , otherwise is boolean False .	should_convert = ( isinstance ( value , datetime ) and ( settings . USE_TZ if use_tz is None else use_tz ) and not is_naive ( value ) and getattr ( value , STR0 , True ) )
18005	if should_convert is true , call the function localtime with an argument value and return the result , otherwise return value .	return localtime ( value ) if should_convert else value
18006	define the function localtime with 2 arguments : value and timezone set to None .	def localtime ( value , timezone = None ) :
18007	if timezone is None ,	if timezone is None :
18008	call the function get_current_timezone , substitute the result for timezone .	timezone = get_current_timezone ( )
18009	call the method value.astimezone with an argument timezone , substitute the result for value .	value = value . astimezone ( timezone )
18010	if timezone has an attribute STR0 ,	if hasattr ( timezone , STR0 ) :
18011	call the method timezone.normalize with an argument value , substitute the result for value .	value = timezone . normalize ( value )
18012	return value .	return value
18013	define the function now .	def now ( ) :
18014	if settings.USE_TZ is true ,	if settings . USE_TZ :
18015	call the method datetime.utcnow , on the result call the method replace with an argument tzinfo set to utc , return the result .	return datetime . utcnow ( ) . replace ( tzinfo = utc )
18016	if not ,	else :
18017	call the method datetime.now , return the result .	return datetime . now ( )
18018	define the function is_aware with an argument value .	def is_aware ( value ) :
18019	if value.tzinfo is not None and call to the method value.tzinfo.utcoffset called with an argument value evaluates to not None , return boolean True , otherwise return boolean False .	return value . tzinfo is not None and value . tzinfo . utcoffset ( value ) is not None
18020	define the function is_naive with an argument value .	def is_naive ( value ) :
18021	if value.tzinfo is None and call to the method value.tzinfo.utcoffset called with an argument value evaluates to None , return boolean True , otherwise return boolean False .	return value . tzinfo is None or value . tzinfo . utcoffset ( value ) is None
18022	define the function make_aware with 2 arguments : value and timezone .	def make_aware ( value , timezone ) :
18023	if timezone has an attribute STR0 ,	if hasattr ( timezone , STR0 ) :
18024	call the method timezone.localize with 2 arguments : value and is_dst as None , return the result .	return timezone . localize ( value , is_dst = None )
18025	if not ,	else :
18026	call the function is_aware with an argument value , if it evaluates to true ,	if is_aware ( value ) :
18027	raise an ValueError exception with an argument string STR0 , where STR1 is replaced with value .	raise ValueError ( STR0 % value )
18028	call the method value.replace with an argument tzinfo as timezone , return the result .	return value . replace ( tzinfo = timezone )
18029	define the function make_naive with 2 arguments : value and timezone .	def make_naive ( value , timezone ) :
18030	call the method value.astimezone with an argument timezone , substitute the result for value .	value = value . astimezone ( timezone )
18031	if timezone has an attribute STR0 ,	if hasattr ( timezone , STR0 ) :
18032	call the method timezone.normalize with an argument value , substitute the result for value .	value = timezone . normalize ( value )
18033	call the method value.replace with an arugment tzinfo set to None , return the result .	return value . replace ( tzinfo = None )
18034	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
18035	import module re .	import re
18036	from django.utils.encoding import force_text into default name space .	from django . utils . encoding import force_text
18037	from django.utils.functional import lazy into default name space .	from django . utils . functional import lazy
18038	from django.utils import six into default name space .	from django . utils import six
18039	__all__ is an list containing strings : STR0 , STR1 , STR2 , STR3 , STR4 , STR5 , STR6 , STR7 , STR8 , STR9 , STR10 , STR11 , STR12 , STR13 , STR14 , STR15 , STR16 , STR17 , STR18 , STR19 , STR20 , STR21 , STR22 , STR23 , STR24 , STR25 and STR26 .	__all__ = [ STR0 , STR1 , STR2 , STR3 , STR4 , STR5 , STR6 , STR7 , STR8 , STR9 , STR10 , STR11 , STR12 , STR13 , STR14 , STR15 , STR16 , STR17 , STR18 , STR19 , STR20 , STR21 , STR22 , STR23 , STR24 , STR25 , STR26 , ]
18040	LANGUAGE_SESSION_KEY is an string STR0 .	LANGUAGE_SESSION_KEY = STR0
18041	derive the class TranslatorCommentWarning from the SyntaxWarning base class .	class TranslatorCommentWarning ( SyntaxWarning ) :
18042	do nothing .	pass
18043	derive the class Trans from the object base class .	class Trans ( object ) :
18044	define the method __getattr__ with 2 arguments : self and real_name .	def __getattr__ ( self , real_name ) :
18045	from django.conf import settings .	from django . conf import settings
18046	if settings.USE_I18N is true ,	if settings . USE_I18N :
18047	from django.utils.translation import trans_real as trans .	from django . utils . translation import trans_real as trans
18048	if not ,	else :
18049	from django.utils.translation import trans_null as trans .	from django . utils . translation import trans_null as trans
18050	set real_name attribute of the self object to value of real_name attribute of trans object .	setattr ( self , real_name , getattr ( trans , real_name ) )
18051	get attribute real_name from the trans object , return it .	return getattr ( trans , real_name )
18052	_trans is an instance of Trans class .	_trans = Trans ( )
18053	delete Trans .	del Trans
18054	define the function gettext_noop with an argument message .	def gettext_noop ( message ) :
18055	call the method _trans.gettext_noop with an argument message .	return _trans . gettext_noop ( message )
18056	substitute gettext_noop for ugettext_noop .	ugettext_noop = gettext_noop
18057	define the function gettext_noop with an argument message .	def gettext ( message ) :
18058	call the method _trans.gettext with an argument message .	return _trans . gettext ( message )
18059	define the function ngettext with 3 arguments : singular , plural and number .	def ngettext ( singular , plural , number ) :
18060	call the method _trans.ngettext with 3 arguments singular , plural and number .	return _trans . ngettext ( singular , plural , number )
18061	define the method ugettext with an argument message .	def ugettext ( message ) :
18062	call the method _trans.gettext_noop with an argument message .	return _trans . ugettext ( message )
18063	define the function ungettext with 3 arguments : singular , plural and number .	def ungettext ( singular , plural , number ) :
18064	call the method _trans.ungettext with 3 arguments singular , plural and number .	return _trans . ungettext ( singular , plural , number )
18065	define the function pgettext with 2 arguments : context and message .	def pgettext ( context , message ) :
18066	call the method _trans.pgettext with 2 arguments context and message .	return _trans . pgettext ( context , message )
18067	define the function npgettext with 4 arguments : context , singular , plural and number .	def npgettext ( context , singular , plural , number ) :
18068	call the method _trans.npgettext with 4 arguments context , singular , plural and number .	return _trans . npgettext ( context , singular , plural , number )
18069	call the function lazy with 2 arguments : gettext and str , substitute gettext_lazy .	gettext_lazy = lazy ( gettext , str )
18070	call the function lazy with 2 arguments : ugettext and six.text_type , substitute ugettext_lazy .	ugettext_lazy = lazy ( ugettext , six . text_type )
18071	call the function lazy with 2 arguments : pgettext and six.text_type , substitute pgettext_lazy .	pgettext_lazy = lazy ( pgettext , six . text_type )
18072	define the function lazy_number with 4 arguments : func , resultclass , number set to None and unpacked dictionary kwargs .	def lazy_number ( func , resultclass , number = None , ** kwargs ) :
18073	if number is an instance of int type .	if isinstance ( number , int ) :
18074	substitute number for value under the STR0 key of the kwargs dictionary .	kwargs [ STR0 ] = number
18075	call the function lazy with 2 arguments : func and resultclass , call the result with an argument , unpacked dictionary kwargs , substitute the result for proxy .	proxy = lazy ( func , resultclass ) ( ** kwargs )
18076	if not ,	else :
18077	derive the class NumberAwareString from the resultclass base class .	class NumberAwareString ( resultclass ) :
18078	define the method __mod__ with 2 arguments : self and rhs .	def __mod__ ( self , rhs ) :
18079	if rhs is an instance of dict type and number is true ,	if isinstance ( rhs , dict ) and number :
18080	try ,	try :
18081	substitute value under the number key of the rhs dictionary for number_value .	number_value = rhs [ number ]
18082	if KeyError exception is caught ,	except KeyError :
18083	raise an KeyError with an argument string STR0 , where STR1 is replaced with number .	raise KeyError ( STR0 % number )
18084	if not ,	else :
18085	substitute rhs for number_value .	number_value = rhs
18086	substitute number_value for kwargs dictionary value under the STR0 key .	kwargs [ STR0 ] = number_value
18087	call the function func with unpacked dictionary kwargs as an argument , substitute the result for translated .	translated = func ( ** kwargs )
18088	try ,	try :
18089	format translated with rhs , substitute the result for translated .	translated = translated % rhs
18090	if TypeError exception is caught ,	except TypeError :
18091	do nothing .	pass
18092	return translated .	return translated
18093	call the function lazy with 2 arguments : lambda function with unpacked dictionary kwargs as an argument and return value an instance of NumberAwareString class and NumberAwareString , call the result with an argument unpacked dictionary kwargs , substitute the result for proxy .	proxy = lazy ( lambda ** kwargs : NumberAwareString ( ) , NumberAwareString ) ( ** kwargs )
18094	return proxy .	return proxy
18095	define the function ngettext_lazy with 3 arguments : singular , plural and number set to None .	def ngettext_lazy ( singular , plural , number = None ) :
18096	call the function lazy_number with 5 arguments : ngettext , str , singular set to singular , plural set to plural , and number set to number , return the result .	return lazy_number ( ngettext , str , singular = singular , plural = plural , number = number )
18097	define the function ungettext_lazy with 3 arguments : singular , plural and number set to None .	def ungettext_lazy ( singular , plural , number = None ) :
18098	call the function lazy_number with 5 arguments : ungettext , six.text_type , singular set to singular , plural set to plural , and number set to number , return the result .	return lazy_number ( ungettext , six . text_type , singular = singular , plural = plural , number = number )
18099	define the function npgettext_lazy with 4 arguments : context , singular , plural and number set to None .	def npgettext_lazy ( context , singular , plural , number = None ) :
18100	call the function lazy_number with 6 arguments : npgettext , six.text_type , context set to context , singular set to singular , plural set to plural and number set to number , return the result .	return lazy_number ( npgettext , six . text_type , context = context , singular = singular , plural = plural , number = number )
18101	define the function activate with an argument language .	def activate ( language ) :
18102	call the function _trans.activate with an argument language , return the result .	return _trans . activate ( language )
18103	define the function deactivate .	def deactivate ( ) :
18104	call the function _trans.deactivate , return the result .	return _trans . deactivate ( )
18105	derive the class override from the object base class .	class override ( object ) :
18106	define the method __init__ with 3 arguments : self , language and deactivate set to boolean False .	def __init__ ( self , language , deactivate = False ) :
18107	substitute language for self.language .	self . language = language
18108	substitute deactivate for self.deactivate .	self . deactivate = deactivate
18109	call the function get_language , substitute the result for self.old_language .	self . old_language = get_language ( )
18110	define the method __enter__ with an argument self .	def __enter__ ( self ) :
18111	if self.language is not None ,	if self . language is not None :
18112	call the function activate with an argument self.language .	activate ( self . language )
18113	if not ,	else :
18114	call the function deactivate_all .	deactivate_all ( )
18115	define the method __exit__ with 4 arguments : self , exc_type , exc_value and traceback .	def __exit__ ( self , exc_type , exc_value , traceback ) :
18116	if self.deactivate is true ,	if self . deactivate :
18117	call the method deactivate .	deactivate ( )
18118	if not ,	else :
18119	call the method activate with an argument self.old_language .	activate ( self . old_language )
18120	define the function get_language .	def get_language ( ) :
18121	call the function _trans.get_language , return the result .	return _trans . get_language ( )
18122	define the function get_language_bidi .	def get_language_bidi ( ) :
18123	call the function _trans.get_language_bidi , return the result .	return _trans . get_language_bidi ( )
18124	define the function check_for_language with an argument lang_code .	def check_for_language ( lang_code ) :
18125	call the function _trans.check_for_language with an argument lang_code , return the result .	return _trans . check_for_language ( lang_code )
18126	define the function to_locale with an argument language .	def to_locale ( language ) :
18127	call the function _trans.to_locale with an argument language , return the result .	return _trans . to_locale ( language )
18128	define the function get_language_from_request with 2 arguments : request and check_path set to boolean False .	def get_language_from_request ( request , check_path = False ) :
18129	call the function _trans.get_language_from_request with 2 arguments : request and check_path , return the result .	return _trans . get_language_from_request ( request , check_path )
18130	define the function get_language_from_path with an argument path .	def get_language_from_path ( path ) :
18131	call the function _trans.get_language_from_path with an argument path , return the result .	return _trans . get_language_from_path ( path )
18132	define the function templatize with 2 arguments : src and origin set to None .	def templatize ( src , origin = None ) :
18133	call the function _trans.templatize with 2 arguments : src and origin , return the result .	return _trans . templatize ( src , origin )
18134	define the function deactivate_all .	def deactivate_all ( ) :
18135	call the function _trans.deactivate_all , return the result .	return _trans . deactivate_all ( )
18136	define the function _string_concat with an argument unpacked list strings .	def _string_concat ( * strings ) :
18137	for every s in strings , call the function force_text with an argument s , join the results in a string , return the result .	return STR . join ( force_text ( s ) for s in strings )
18138	call the function lazy with 2 arguments : _string_concat and six.text_type , substitute the result for string_concat .	string_concat = lazy ( _string_concat , six . text_type )
18139	define the function get_language_info with an argument lang_code .	def get_language_info ( lang_code ) :
18140	from django.conf.locale import LANG_INFO .	from django . conf . locale import LANG_INFO
18141	try ,	try :
18142	get the value under the lang_code key of the LANG_INFO dictionary , return it .	return LANG_INFO [ lang_code ]
18143	if KeyError exception is caught ,	except KeyError :
18144	if character STR0 is not contained in lang_code ,	if STR0 not in lang_code :
18145	raise an KeyError with an argument STR0 , where STR1 is replaced with lang_code .	raise KeyError ( STR0 % lang_code )
18146	split lang_code by character STR0 , substitute the first element of the result for generic_lang_code .	generic_lang_code = lang_code . split ( STR0 ) [ 0 ]
18147	try ,	try :
18148	get the LANG_INFO dictionary value under the generic_lang_code key , return the result .	return LANG_INFO [ generic_lang_code ]
18149	if KeyError exception is caught ,	except KeyError :
18150	raise an KeyError with an argument string STR0 , where STR1 is replaced with lang_code , and generic_lang_code .	raise KeyError ( STR0 % ( lang_code , generic_lang_code ) )
18151	call the function re.compile with an argument string STR0 , substitute the result for trim_whitespace_re .	trim_whitespace_re = re . compile ( STR0 )
18152	define the function trim_whitespace with an argument s .	def trim_whitespace ( s ) :
18153	call strip s of the surrounding whitespaces , substitute every occurrence of the whitespace in the trim_whitespace_re with previous result , return the result .	return trim_whitespace_re . sub ( STR , s . strip ( ) )
18154	from django.conf import settings into default name space .	from django . conf import settings
18155	from django.utils.encoding import force_text into default name space .	from django . utils . encoding import force_text
18156	from django.utils.safestring import mark_safe and SafeData into default name space .	from django . utils . safestring import mark_safe , SafeData
18157	define the function ngettext with 3 arguments : singular , plural and number .	def ngettext ( singular , plural , number ) :
18158	if number equals integer 1 ,	if number == 1 :
18159	return singular .	return singular
18160	return plural .	return plural
18161	substitute ngettext for ngettext_lazy .	ngettext_lazy = ngettext
18162	define the function ungettext with 3 arguments : singular , plural and number .	def ungettext ( singular , plural , number ) :
18163	call the function ngettext with 3 arguments : singular , plural and number , use the result as an argument for the call to the force_text , return the result .	return force_text ( ngettext ( singular , plural , number ) )
18164	define the function pgettext with 2 arguments : context and message .	def pgettext ( context , message ) :
18165	call the function ugettext with an argument message .	return ugettext ( message )
18166	define the function ngettext with 4 arguments : context , singular , plural and number .	def npgettext ( context , singular , plural , number ) :
18167	call the function ungettext with 3 arguments : singular , plural and number , return the result .	return ungettext ( singular , plural , number )
18168	activate is a lambda function which returns None for any argument x .	activate = lambda x : None
18169	deactivate and deactivate_all are lambda functions returning None .	deactivate = deactivate_all = lambda : None
18170	get_language is a lambda function returning settings.LANGUAGE_CODE .	get_language = lambda : settings . LANGUAGE_CODE
18171	get_language_bidi is lambda function returning boolean True if settings.LANGUAGE_CODE is contained in settings.LANGUAGES_BIDI .	get_language_bidi = lambda : settings . LANGUAGE_CODE in settings . LANGUAGES_BIDI
18172	check_for_language is lambda function that returns boolean True for every argument x .	check_for_language = lambda x : True
18173	define the function gettext with an argument message .	def gettext ( message ) :
18174	if message is an instance of SafeData .	if isinstance ( message , SafeData ) :
18175	call the function mark_safe with an argument message , return the result .	return mark_safe ( message )
18176	return message .	return message
18177	define the function ugettext with an argument message .	def ugettext ( message ) :
18178	call the function gettext with an argument message , use the result as an argument for the call to the force_text function , return the result .	return force_text ( gettext ( message ) )
18179	substitute gettext for gettext_noop , gettext_lazy and _ .	gettext_noop = gettext_lazy = _ = gettext
18180	define the function to_locale with an argument language .	def to_locale ( language ) :
18181	find position of STR0 in the index of the language , substitute the result for p .	p = language . find ( STR0 )
18182	if p is greater or equal to integer 0 ,	if p >= 0 :
18183	append STR0 to string created from first p elements of languages converted to lowercase , convert slice of language string from ( p+1 ) -th index to the end to uppercase , append it to the previous result , return the resulting string .	return language [ : p ] . lower ( ) + STR0 + language [ p + 1 : ] . upper ( )
18184	if not ,	else :
18185	convert language to lowercase and return it .	return language . lower ( )
18186	define the function get_language_from_request with 2 arguments : request and check_path set to boolean False .	def get_language_from_request ( request , check_path = False ) :
18187	return settings.LANGUAGE_CODE .	return settings . LANGUAGE_CODE
18188	define the function get_language_from_path with an argument request .	def get_language_from_path ( request ) :
18189	return None .	return None
18190	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
18191	from collections import OrderedDict into default name space .	from collections import OrderedDict
18192	import module os .	import os
18193	import module re .	import re
18194	import module sys .	import sys
18195	import module gettext as gettext_module .	import gettext as gettext_module
18196	from threading import local into default name space .	from threading import local
18197	import module warnings .	import warnings
18198	from django.apps import apps into default name space .	from django . apps import apps
18199	from django.conf import settings into default name space .	from django . conf import settings
18200	from django.core.exceptions import AppRegistryNotReady into default name space .	from django . core . exceptions import AppRegistryNotReady
18201	from django.dispatch import receiver into default name space .	from django . dispatch import receiver
18202	from django.test.signals import setting_changed into default name space .	from django . test . signals import setting_changed
18203	from django.utils.deprecation import RemovedInDjango19Warning into default name space .	from django . utils . deprecation import RemovedInDjango19Warning
18204	from django.utils.encoding import force_text into default name space .	from django . utils . encoding import force_text
18205	from django.utils._os import upath into default name space .	from django . utils . _os import upath
18206	from django.utils.safestring import mark_safe and SafeData into default name space .	from django . utils . safestring import mark_safe , SafeData
18207	from django.utils import six and lru_cache into default name space .	from django . utils import six , lru_cache
18208	from django.utils.six import StringIO into default name space .	from django . utils . six import StringIO
18209	from django.utils.translation import TranslatorCommentWarning , trim_whitespace and LANGUAGE_SESSION_KEY into default name space .	from django . utils . translation import TranslatorCommentWarning , trim_whitespace , LANGUAGE_SESSION_KEY
18210	_translations is an empty dictionary .	_translations = { }
18211	call the function local , substitute the result for _active .	_active = local ( )
18212	_default is None .	_default = None
18213	_supported is None .	_supported = None
18214	CONTEXT_SEPARATOR is a string STR0 .	CONTEXT_SEPARATOR = STR0
18215	call the function re.compile with 2 arguments : raw string STR0 , and re.VERBOSE , substitute the result for accept_language_re .	accept_language_re = re . compile ( STR0 , re . VERBOSE )
18216	call the function re.compile with 2 arguments : raw string STR0 and re.IGNORECASE , substitute the result for language_code_re .	language_code_re = re . compile ( STR0 , re . IGNORECASE )
18217	call the function re.compile with an argument raw string STR0 , substitute the result for language_code_prefix_re .	language_code_prefix_re = re . compile ( STR0 )
18218	_BROWSERS_DEPRECATED_LOCALES is an dictionary with 2 initial entries : STR0 for STR1 and STR2 for STR3 .	_BROWSERS_DEPRECATED_LOCALES = { STR0 : STR1 , STR2 : STR3 , }
18219	substitute _BROWSERS_DEPRECATED_LOCALES for _DJANGO_DEPRECATED_LOCALES .	_DJANGO_DEPRECATED_LOCALES = _BROWSERS_DEPRECATED_LOCALES
18220	decorator function receiver with an argument setting_changed ,	@ receiver ( setting_changed )
18221	define the function reset_cache with an argument unpacked dictionary kwargs .	def reset_cache ( ** kwargs ) :
18222	if value under the STR0 key of the kwargs dictionary is equal to string STR1 or strnig STR2 ,	if kwargs [ STR0 ] in ( STR1 , STR2 ) :
18223	use global variable _supported .	global _supported
18224	_supported is None .	_supported = None
18225	call the method check_for_language.cache_clear .	check_for_language . cache_clear ( )
18226	call the method get_supported_language_variant.cache_clear .	get_supported_language_variant . cache_clear ( )
18227	define the function to_locale with 2 arguments language and to_lower set to boolean False .	def to_locale ( language , to_lower = False ) :
18228	find first index of occurrence of character STR0 in language , substitute it for p .	p = language . find ( STR0 )
18229	if p is greater or equal to integer 0 ,	if p >= 0 :
18230	if to_lower is true ,	if to_lower :
18231	convert fist p elements of language to lowercase , append STR0 to it , covert to lowercase language elements from ( p+1 ) -th index to the end , append it to the previous result , return it .	return language [ : p ] . lower ( ) + STR0 + language [ p + 1 : ] . lower ( )
18232	if not ,	else :
18233	slice language from ( p+1 ) -th index to the end , calculate the length of the obtained segment , if it is greater than integer 2 ,	if len ( language [ p + 1 : ] ) > 2 :
18234	convert fist p elements of language to lowercase , append STR0 to it , covert to lowercase language element at ( p+1 ) -th index , append it to the previous result , covert to lowercase language elements from ( p+2 ) -th index to the end , append it to the previous result , return it .	return language [ : p ] . lower ( ) + STR0 + language [ p + 1 ] . upper ( ) + language [ p + 2 : ] . lower ( )
18235	convert fist p elements of language to lowercase , append STR0 to it , covert to uppercase language elements from ( p+1 ) -th index to the end , append it to the previous result , return it .	return language [ : p ] . lower ( ) + STR0 + language [ p + 1 : ] . upper ( )
18236	if not ,	else :
18237	convert language to lowercase , return it .	return language . lower ( )
18238	define the function to_language with an argument locale .	def to_language ( locale ) :
18239	find first index of occurrence of character STR0 in locale , substitute it for p .	p = locale . find ( STR0 )
18240	if p is greater or equal to integer 0 ,	if p >= 0 :
18241	convert fist p elements of locale to lowercase , append STR0 to it , covert to lowercase locale elements from ( p+1 ) -th index to the end , append it to the previous result , return it .	return locale [ : p ] . lower ( ) + STR0 + locale [ p + 1 : ] . lower ( )
18242	if not ,	else :
18243	convert locale to lowercase and return it .	return locale . lower ( )
18244	derive the class DjangoTranslation from gettext_module.GNUTranslations base class .	class DjangoTranslation ( gettext_module . GNUTranslations ) :
18245	define the method __init__ with 2 arguments : self and language .	def __init__ ( self , language ) :
18246	call the method gettext_module.GNUTranslations.__init__ with an argument self .	gettext_module . GNUTranslations . __init__ ( self )
18247	substitute language for self.__language .	self . __language = language
18248	call the function to_language with an argument language , substitute it for self.__to_language .	self . __to_language = to_language ( language )
18249	call the function to_locale with an argument language , substitute it for self.__locale .	self . __locale = to_locale ( language )
18250	self.plural is an lambda function with an argument n , which returns result of boolean expression n not equal to integer 1 , converted to an integer .	self . plural = lambda n : int ( n != 1 )
18251	call the method self._init_translation_catalog .	self . _init_translation_catalog ( )
18252	call the method self._add_installed_apps_translations .	self . _add_installed_apps_translations ( )
18253	call the method self._add_local_translations .	self . _add_local_translations ( )
18254	call the method self._add_fallback .	self . _add_fallback ( )
18255	define the method __repr__ with an argument self .	def __repr__ ( self ) :
18256	return a string STR0 , where STR1 is replaced with self.__language .	return STR0 % self . __language
18257	define the method _new_gnu_trans with 3 arguments : self , localedir and use_null_fallback set to boolean True .	def _new_gnu_trans ( self , localedir , use_null_fallback = True ) :
18258	call the method gettext_module.translation with 5 arguments : domain set to string STR0 , localedir set to localedir , languages set to a list with an element self.__locale , codeset set to a string STR1 and fallback set to use_null_fallback , substitute the result for translation .	translation = gettext_module . translation ( domain = STR0 , localedir = localedir , languages = [ self . __locale ] , codeset = STR1 , fallback = use_null_fallback )
18259	if translation has an attribute STR0 ,	if not hasattr ( translation , STR0 ) :
18260	translation._catalog is an empty dictionary .	translation . _catalog = { }
18261	translation._info is an empty dictionary .	translation . _info = { }
18262	return translation .	return translation
18263	define the method _init_translation_catalog with an argument self .	def _init_translation_catalog ( self ) :
18264	get the value under the settings.__module__ key of the sys.modules dictionary , use its __file__ field as an argument for the call to the function upath , substitute the result for settingsfile .	settingsfile = upath ( sys . modules [ settings . __module__ ] . __file__ )
18265	call the function os.path.dirname with an argument settingsfile , join the result an string STR0 into a file path , substitute it for localedir .	localedir = os . path . join ( os . path . dirname ( settingsfile ) , STR0 )
18266	use_null_fallback is boolean True .	use_null_fallback = True
18267	if self.__language equals settings.LANGUAGE_CODE ,	if self . __language == settings . LANGUAGE_CODE :
18268	use_null_fallback is boolean False .	use_null_fallback = False
18269	call the function self._new_gnu_trans with 2 arguments : localedir and use_null_fallback , substitute the result for translation .	translation = self . _new_gnu_trans ( localedir , use_null_fallback )
18270	call the method translation._info.copy , substitute the result for self._info .	self . _info = translation . _info . copy ( )
18271	call the method translation._catalog.copy , substitute the result for self._catalog .	self . _catalog = translation . _catalog . copy ( )
18272	define the method _add_installed_apps_translations with an argument self .	def _add_installed_apps_translations ( self ) :
18273	try ,	try :
18274	call the method apps.get_app_configs , convert the result in a list , reverse the order of elements , substitute the result for app_configs .	app_configs = reversed ( list ( apps . get_app_configs ( ) ) )
18275	if AppRegistryNotReady exception is caught ,	except AppRegistryNotReady :
18276	raise an AppRegistryNotReady exception with an argument string STR0 .	raise AppRegistryNotReady ( STR0 )
18277	for every app_config in app_configs ,	for app_config in app_configs :
18278	join app_config.path and string STR0 into a file path , substitute it for localedir .	localedir = os . path . join ( app_config . path , STR0 )
18279	call the method self._new_gnu_trans with an argument localedir , substitute the result for translation .	translation = self . _new_gnu_trans ( localedir )
18280	call the method self.merge with an argument translation .	self . merge ( translation )
18281	define the method _add_local_translations with an argument self .	def _add_local_translations ( self ) :
18282	reverse settings.LOCALE_PATHS element order , for every localedir in the result ,	for localedir in reversed ( settings . LOCALE_PATHS ) :
18283	call the function self._new_gnu_trans with an argument localedir , substitute the result for translation .	translation = self . _new_gnu_trans ( localedir )
18284	call the method self.merge with an argument translation .	self . merge ( translation )
18285	define the method _add_fallback with an argument self .	def _add_fallback ( self ) :
18286	if self.__language equals settings.LANGUAGE_CODE or self.__language equals a string STR0 ,	if self . __language == settings . LANGUAGE_CODE or self . __language == STR0 :
18287	return .	return
18288	call the function translation with an argument settings.LANGUAGE_CODE , substitute the result for default_translation .	default_translation = translation ( settings . LANGUAGE_CODE )
18289	call the method self.add_fallback with an argument default_translation .	self . add_fallback ( default_translation )
18290	define the method merge with 2 arguments self and other .	def merge ( self , other ) :
18291	update the self._catalog dictionary with other._catalog .	self . _catalog . update ( other . _catalog )
18292	define the method language with an argument self .	def language ( self ) :
18293	return self.__language .	return self . __language
18294	define the method to_language with an argument self .	def to_language ( self ) :
18295	return self.__to_language .	return self . __to_language
18296	define the function translation with an argument language .	def translation ( language ) :
18297	use global variable _translations .	global _translations
18298	if language is not contained in _translations ,	if language not in _translations :
18299	_translations dictionary value , under the language key is an instance of DjangoTranslation class , created with an argument language .	_translations [ language ] = DjangoTranslation ( language )
18300	return _translations dictionary value , under the language key .	return _translations [ language ]
18301	define the function activate with an argument language .	def activate ( language ) :
18302	if language is contained in _DJANGO_DEPRECATED_LOCALES ,	if language in _DJANGO_DEPRECATED_LOCALES :
18303	msg is a string STR0 .	msg = ( STR0 )
18304	call the method call the function warnings.warn with 3 arguments : msg formatted with language and value under the language key , of the _DJANGO_DEPRECATED_LOCALES dictionary , RemovedInDjango19Warning and stacklevel set to integer 2 .	warnings . warn ( msg % ( language , _DJANGO_DEPRECATED_LOCALES [ language ] ) , RemovedInDjango19Warning , stacklevel = 2 )
18305	call the function translation with an argument language , substitute the result for _active.value .	_active . value = translation ( language )
18306	define the function deactivate .	def deactivate ( ) :
18307	if _active has an attribute STR0 ,	if hasattr ( _active , STR0 ) :
18308	delete _active.value .	del _active . value
18309	define the function deactivate_all .	def deactivate_all ( ) :
18310	call the method gettext_module.NullTranslations , substitute the result for _active.value .	_active . value = gettext_module . NullTranslations ( )
18311	define the function get_language .	def get_language ( ) :
18312	get STR0 attribute of the _active object , if it exists substitute it for t , if not t is None .	t = getattr ( _active , STR0 , None )
18313	if t is not None ,	if t is not None :
18314	try ,	try :
18315	call the method t.to_language , return the result .	return t . to_language ( )
18316	if AttributeError exception is caught ,	except AttributeError :
18317	do nothing .	pass
18318	return settings.LANGUAGE_CODE .	return settings . LANGUAGE_CODE
18319	define the function get_language_bidi .	def get_language_bidi ( ) :
18320	call the function get_language , split the result by STR0 , substitute the first element of the result for base_lang .	base_lang = get_language ( ) . split ( STR0 ) [ 0 ]
18321	if base_lang is contained in settings.LANGUAGES_BIDI , return boolean True , if not , return boolean False .	return base_lang in settings . LANGUAGES_BIDI
18322	define the function catalog .	def catalog ( ) :
18323	use global variable _default .	global _default
18324	get STR0 attribute of the _active object , if it exists substitute it for t , if not t is None .	t = getattr ( _active , STR0 , None )
18325	if t is not None	if t is not None :
18326	return t .	return t
18327	if _default is None	if _default is None :
18328	call the function translation with an argument settings.LANGUAGE_CODE , substitute the result for _default .	_default = translation ( settings . LANGUAGE_CODE )
18329	return _default .	return _default
18330	define the function do_translate with 2 arguments : message and translation_function .	def do_translate ( message , translation_function ) :
18331	use global variable _default .	global _default
18332	replace every occurrence of string STR0 in message with STR1 , replace every occurrence of string STRspecial , in the previous result for with string STR2 , substitute the result for eol_message .	eol_message = message . replace ( str ( STR0 ) , str ( STR1 ) ) . replace ( str ( STRspecial ) , str ( STR2 ) )
18333	get STR0 attribute of the _active object , if it exists substitute it for t , if not t is None .	t = getattr ( _active , STR0 , None )
18334	if t is not None ,	if t is not None :
18335	get translation_function attribute of the object t , call the result with an argument eol_message , substitute the result for result .	result = getattr ( t , translation_function ) ( eol_message )
18336	if not ,	else :
18337	if _default is None ,	if _default is None :
18338	call the function translation with an argument settings.LANGUAGE_CODE , substitute the result for _default .	_default = translation ( settings . LANGUAGE_CODE )
18339	get translation_function attribute of the object _default , call the result with an argument eol_message , substitute the result for result .	result = getattr ( _default , translation_function ) ( eol_message )
18340	if message is an instance of SafeData ,	if isinstance ( message , SafeData ) :
18341	call the function mark_safe with an argument result , return it .	return mark_safe ( result )
18342	return result .	return result
18343	define the function gettext with an argument message .	def gettext ( message ) :
18344	call the function do_translate with 2 arguments : message and string STR0 , return the result .	return do_translate ( message , STR0 )
18345	if six.PY3 is true ,	if six . PY3 :
18346	substitute gettext for ugettext .	ugettext = gettext
18347	if not ,	else :
18348	define the function ugettext with an argument message .	def ugettext ( message ) :
18349	call the function do_translate with 2 arguments : message and string STR0 , return the result .	return do_translate ( message , STR0 )
18350	define the function pgettext with 2 arguments : context and message .	def pgettext ( context , message ) :
18351	convert to strings and concatenate context , CONTEXT_SEPARATOR and message , substitute the result for msg_with_ctxt .	msg_with_ctxt = STR0 % ( context , CONTEXT_SEPARATOR , message )
18352	call the function ugettext with an argument msg_with_ctxt , substitute the result for result .	result = ugettext ( msg_with_ctxt )
18353	if CONTEXT_SEPARATOR is contained in result ,	if CONTEXT_SEPARATOR in result :
18354	call the function force_text with an argument message , return the result .	result = force_text ( message )
18355	return result .	return result
18356	define the function locale with an argument locale .	def gettext_noop ( message ) :
18357	return message .	return message
18358	define the function do_ntranslate with 4 arguments : singular , plural , number and translation_function .	def do_ntranslate ( singular , plural , number , translation_function ) :
18359	use global variable _default .	global _default
18360	get STR0 attribute of the _active object , if it exists substitute it for t , if not t is None .	t = getattr ( _active , STR0 , None )
18361	if t is not None ,	if t is not None :
18362	get translation_function attribute of the t object , call the result with 3 arguments : singular , plural and number , return the result .	return getattr ( t , translation_function ) ( singular , plural , number )
18363	if _default is None ,	if _default is None :
18364	call the function translation with an argument settings.LANGUAGE_CODE , substitute the result for _default .	_default = translation ( settings . LANGUAGE_CODE )
18365	get translation_function attribute of the _default object , call the result with 3 arguments : singular , plural and number , return the result .	return getattr ( _default , translation_function ) ( singular , plural , number )
18366	define the function ngettext with 3 arguments : singular , plural and number .	def ngettext ( singular , plural , number ) :
18367	call the function do_ntranslate with 3 arguments : singular , plural , number and string STR0 , return the result .	return do_ntranslate ( singular , plural , number , STR0 )
18368	if six.PY3 is true ,	if six . PY3 :
18369	substitute ngettext for ungettext .	ungettext = ngettext
18370	if not ,	else :
18371	define the function ungettext with 3 arguments : singular , plural and number .	def ungettext ( singular , plural , number ) :
18372	call the function do_ntranslate with 3 arguments : singular , plural , number and string STR0 , return the result .	return do_ntranslate ( singular , plural , number , STR0 )
18373	define the function npgettext with 4 arguments : context , singular , plural and number .	def npgettext ( context , singular , plural , number ) :
18374	msgs_with_ctxt is a tuple containing 2 elements : string created by concatenating context , CONTEXT_SEPARATOR and singular , string created by concatenating context , CONTEXT_SEPARATOR and plural and number .	msgs_with_ctxt = ( STR0 % ( context , CONTEXT_SEPARATOR , singular ) , STR1 % ( context , CONTEXT_SEPARATOR , plural ) , number )
18375	call the function ungettext with unpacked dictionary msgs_with_ctxt , substitute the result for result .	result = ungettext ( * msgs_with_ctxt )
18376	if CONTEXT_SEPARATOR is contained in result ,	if CONTEXT_SEPARATOR in result :
18377	call the function ungettext with 3 arguments : singular , plural and number , substitute the result for result .	result = ungettext ( singular , plural , number )
18378	return result .	return result
18379	define the function all_locale_paths .	def all_locale_paths ( ) :
18380	get the value under the settings.__module__ key of the sys.modules dictionary , use its __file__ field as an argument , for the call to the function upath , get the directory name of the resulting system path , join the result and string STR0 , into a valid file path , substitute it for globalpath .	globalpath = os . path . join ( os . path . dirname ( upath ( sys . modules [ settings . __module__ ] . __file__ ) ) , STR0 )
18381	append settings.LOCALE_PATHS converted into a list to a list containing an element globalpath , return it .	return [ globalpath ] + list ( settings . LOCALE_PATHS )
18382	decorator function lru_cache.lru_cache with an argument maxsize set to integer 1000 .	@ lru_cache . lru_cache ( maxsize = 1000 )
18383	define the function check_for_language with an argument lang_code .	def check_for_language ( lang_code ) :
18384	call the method language_code_re.search with an argument lang_code , if it evaluates to false ,	if not language_code_re . search ( lang_code ) :
18385	return boolean False .	return False
18386	call the function all_locale_paths , for every path is the result ,	for path in all_locale_paths ( ) :
18387	call the method gettext_module.find with 3 arguments : string STR0 , path and list with an element : result of the function ,	if gettext_module . find ( STR0 , path , [ to_locale ( lang_code ) ] ) is not None :
18388	to_locale called with an argument lang_code , if the result is not None , return boolean True .	return True
18389	return boolean False .	return False
18390	decorator function lru_cache.lru_cache with an argument maxsize set to integer 1000 .	@ lru_cache . lru_cache ( maxsize = 1000 )
18391	define the function get_supported_language_variant with 2 arguments : lang_code and strict set to boolean False .	def get_supported_language_variant ( lang_code , strict = False ) :
18392	use global variable _supported .	global _supported
18393	if _supported is None ,	if _supported is None :
18394	_supported is an instance of OrderedDict class , created with an argument settings.LANGUAGES .	_supported = OrderedDict ( settings . LANGUAGES )
18395	if lang_code is true ,	if lang_code :
18396	get the value under the lang_code key of the _BROWSERS_DEPRECATED_LOCALES dictionary , substitute it for replacement .	replacement = _BROWSERS_DEPRECATED_LOCALES . get ( lang_code )
18397	if lang_code is not contained in _supported and replacement is contained in _supported ,	if lang_code not in _supported and replacement in _supported :
18398	return replacement .	return replacement
18399	split lang_code by STR0 , substitute the first element of the result for generic_lang_code .	generic_lang_code = lang_code . split ( STR0 ) [ 0 ]
18400	for every code in tuple with 2 elements : lang_code and generic_lang_code ,	for code in ( lang_code , generic_lang_code ) :
18401	if code is contained in _supported and call to the function check_for_language with an argument code evaluates to true ,	if code in _supported and check_for_language ( code ) :
18402	return code .	return code
18403	if strict is false ,	if not strict :
18404	for every supported_code in _supported ,	for supported_code in _supported :
18405	append STR0 to generic_lang_code , if supported_code starts with it ,	if supported_code . startswith ( generic_lang_code + STR0 ) :
18406	return supported_code .	return supported_code
18407	raise an LookupError with an argument lang_code .	raise LookupError ( lang_code )
18408	define the function get_language_from_path with 2 arguments : path and strict set to boolean False .	def get_language_from_path ( path , strict = False ) :
18409	call the function language_code_prefix_re.match with an argument path , substitute it for regex_match .	regex_match = language_code_prefix_re . match ( path )
18410	if regex_match is false ,	if not regex_match :
18411	return None .	return None
18412	call the method regex_match.group with an argument integer 1 , substitute the result for lang_code .	lang_code = regex_match . group ( 1 )
18413	try ,	try :
18414	call the function get_supported_language_variant with 2 arguments : lang_code and strict set to strict , return the result .	return get_supported_language_variant ( lang_code , strict = strict )
18415	if LookupError exception is caught ,	except LookupError :
18416	return None .	return None
18417	define the function get_language_from_request with 2 arguments : request and check_path set to boolean False .	def get_language_from_request ( request , check_path = False ) :
18418	use global variable _supported .	global _supported
18419	if _supported is None ,	if _supported is None :
18420	_supported is an instance of OrderedDict class , created with an argument settings.LANGUAGES .	_supported = OrderedDict ( settings . LANGUAGES )
18421	if check_path is true ,	if check_path :
18422	call the function get_language_from_path with an argument request.path_info , substitute it for lang_code .	lang_code = get_language_from_path ( request . path_info )
18423	if lang_code is not None ,	if lang_code is not None :
18424	return lang_code .	return lang_code
18425	if request has an attribute STR0 ,	if hasattr ( request , STR0 ) :
18426	get the value under the LANGUAGE_SESSION_KEY key of the request.session dictionary , substitute it for lang_code .	lang_code = request . session . get ( LANGUAGE_SESSION_KEY )
18427	if lang_code is contained in _supported and lang_code is not None and result of the function check_for_language ,	if lang_code in _supported and lang_code is not None and check_for_language ( lang_code ) :
18428	called with an argument lang_code is true , return lang_code .	return lang_code
18429	get the value under the settings.LANGUAGE_COOKIE_NAME key of the request.COOKIES dictionary , substitute it for lang_code .	lang_code = request . COOKIES . get ( settings . LANGUAGE_COOKIE_NAME )
18430	try ,	try :
18431	call the function get_supported_language_variant with an argument lang_code , return the result .	return get_supported_language_variant ( lang_code )
18432	if LookupError exception is caught ,	except LookupError :
18433	do nothing .	pass
18434	get the value under the STR0 key of the request.META dictionary , if it exists substitute it for accept , if not accept is an empty string .	accept = request . META . get ( STR0 , STR )
18435	call the function parse_accept_lang_header with an argument accept , for every accept_lang and unused in the result ,	for accept_lang , unused in parse_accept_lang_header ( accept ) :
18436	if accept_lang equals STR0 ,	if accept_lang == STR0 :
18437	break from the loop execution .	break
18438	call the method language_code_re.search with an argument accept_lang , if it evaluates to false ,	if not language_code_re . search ( accept_lang ) :
18439	skip this loop iteration .	continue
18440	try ,	try :
18441	call the function get_supported_language_variant with an argument accept_lang , return the result .	return get_supported_language_variant ( accept_lang )
18442	if LookupError exception is caught ,	except LookupError :
18443	skip this loop iteration .	continue
18444	try ,	try :
18445	call the function get_supported_language_variant with an argument settings.LANGUAGE_CODE , return the result .	return get_supported_language_variant ( settings . LANGUAGE_CODE )
18446	if LookupError exception is caught ,	except LookupError :
18447	return settings.LANGUAGE_CODE .	return settings . LANGUAGE_CODE
18448	call the function re.compile with an argument raw string STR0 , substitute it for dot_re .	dot_re = re . compile ( STR0 )
18449	define the function blankout with 2 arguments : src and char .	def blankout ( src , char ) :
18450	call the method dot_re.sub with 2 arguments : char and src , return the result .	return dot_re . sub ( char , src )
18451	call the function re.compile with an argument raw string STR0 [ ^ STR1 ) | ( ? : STR2 ] * ? ' ) ) \s* '' , substitute the result for context_re .	context_re = re . compile ( STR0 )
18452	call the function re.compile with an argument string STR0 [ ^ STR1 ) | ( ? : STR4 ] * ? ' ) ) ( \s+.*context\s+ ( ( ? : STR2 ] * ? STR3 , substitute the result for inline_re .	inline_re = re . compile ( STR0 )
18453	call the function re.compile with an argument raw string STR0 [ ^ STR1 ) | ( ? : STR2 ] * ? ' ) ) ) ? ( ? : \s+| $ ) '' , substitute the result for block_re .	block_re = re . compile ( STR0 )
18454	call the function re.compile with an argument raw string STR0 , substitute the result for endblock_re .	endblock_re = re . compile ( STR0 )
18455	call the function re.compile with an argument raw string STR0 , substitute the result for plural_re .	plural_re = re . compile ( STR0 )
18456	call the function re.compile with an argument raw string STR0.* ? STR1 , substitute the result for constant_re .	constant_re = re . compile ( STR0 )
18457	call the function re.compile with an argument raw string STR0 , substitute the result for one_percent_re .	one_percent_re = re . compile ( STR0 )
18458	define the function templatize with 2 arguments : src and origin set to None .	def templatize ( src , origin = None ) :
18459	from django.template import Lexer , TOKEN_TEXT , TOKEN_VAR , TOKEN_BLOCK , TOKEN_COMMENT and TRANSLATOR_COMMENT_MARK .	from django . template import ( Lexer , TOKEN_TEXT , TOKEN_VAR , TOKEN_BLOCK , TOKEN_COMMENT , TRANSLATOR_COMMENT_MARK )
18460	call the function force_text with 2 arguments : src and settings.FILE_CHARSET .	src = force_text ( src , settings . FILE_CHARSET )
18461	out is an instance of StringIO class , created with an empty string as an argument .	out = StringIO ( STR )
18462	message_context is None .	message_context = None
18463	intrans is boolean False .	intrans = False
18464	inplural is boolean False .	inplural = False
18465	trimmed is boolean False .	trimmed = False
18466	singular is an empty list .	singular = [ ]
18467	plural is an empty list .	plural = [ ]
18468	incomment is boolean False .	incomment = False
18469	comment is an empty list .	comment = [ ]
18470	lineno_comment_map is an dictionary .	lineno_comment_map = { }
18471	comment_lineno_cache is None .	comment_lineno_cache = None
18472	define the function join_tokens with 2 arguments : tokens and trim set to boolean False .	def join_tokens ( tokens , trim = False ) :
18473	join tokens elements into a string , substitute it for message .	message = STR . join ( tokens )
18474	if trim is true ,	if trim :
18475	call the function trim_whitespace with an argument message , substitute the result for message .	message = trim_whitespace ( message )
18476	return message .	return message
18477	instantiate Lexer class with 2 argumets src and origin , call the method tokenize from it , for every t in the result ,	for t in Lexer ( src , origin ) . tokenize ( ) :
18478	if incomment is true ,	if incomment :
18479	if t.token_type equals TOKEN_BLOCK and t.contents equals STR0 ,	if t . token_type == TOKEN_BLOCK and t . contents == STR0 :
18480	join comment elements into a string , substitute it for content .	content = STR . join ( comment )
18481	translators_comment_start is None .	translators_comment_start = None
18482	for every lineno and line is enumerated result of the method content.splitlines , called with an argument boolean True ,	for lineno , line in enumerate ( content . splitlines ( True ) ) :
18483	call the method line.lstrip , if the result starts with TRANSLATOR_COMMENT_MARK ,	if line . lstrip ( ) . startswith ( TRANSLATOR_COMMENT_MARK ) :
18484	substitute lineno for translators_comment_start .	translators_comment_start = lineno
18485	for every lineno and line is enumerated result of the method content.splitlines , called with an argument boolean True ,	for lineno , line in enumerate ( content . splitlines ( True ) ) :
18486	if translators_comment_start is not None and lineno is greater than or equal to translators_comment_start ,	if translators_comment_start is not None and lineno >= translators_comment_start :
18487	substitute STR0 in string STR1 with line , write it to out file .	out . write ( STR0 % line )
18488	if not ,	else :
18489	write string STR0 to out file .	out . write ( STR0 )
18490	incomment is boolean False .	incomment = False
18491	comment is an empty list .	comment = [ ]
18492	if not ,	else :
18493	append t.contents to comment .	comment . append ( t . contents )
18494	otherwise if intrans is true ,	elif intrans :
18495	if t.token_type equals TOKEN_BLOCK ,	if t . token_type == TOKEN_BLOCK :
18496	call the function endblock_re.match with an argument t.contents , substitute the result for endbmatch .	endbmatch = endblock_re . match ( t . contents )
18497	call the function plural_re.match with an argument t.contents , substitute the result for pluralmatch .	pluralmatch = plural_re . match ( t . contents )
18498	if endbmatch is true ,	if endbmatch :
18499	if inplural is true ,	if inplural :
18500	if message_context is true ,	if message_context :
18501	substitute STR0 in string STR1 with message_context , result of the function join_tokens , called with 2 arguments : singular and trimmed and result of the function join_tokens called with 2 arguments : plural and trimmed , write the result to out .	out . write ( STR0 % ( message_context , join_tokens ( singular , trimmed ) , join_tokens ( plural , trimmed ) ) )
18502	if not ,	else :
18503	substitute STR0 in string STR1 with result of the function join_tokens , called with 2 arguments : singular , and trimmed and result of the function join_tokens called with 2 arguments : plural and trimmed , write the result to out .	out . write ( STR0 % ( join_tokens ( singular , trimmed ) , join_tokens ( plural , trimmed ) ) )
18504	for every part in singular ,	for part in singular :
18505	call the method blankout with 2 arguments : part and STR0 , write the result to out .	out . write ( blankout ( part , STR0 ) )
18506	for every part in plural ,	for part in plural :
18507	call the method blankout with 2 arguments : part and STR0 , write the result to out .	out . write ( blankout ( part , STR0 ) )
18508	if not ,	else :
18509	if message_context is true ,	if message_context :
18510	substitute STR0 in string STR1 with message_context and result of the function join_tokens , called with 2 arguments : singular and trimmed , write the result to out .	out . write ( STR0 % ( message_context , join_tokens ( singular , trimmed ) ) )
18511	if not ,	else :
18512	substitute STR0 in string STR1 with result of the function join_tokens , called with 2 arguments : singular , and trimmed , write the result to out .	out . write ( STR0 % join_tokens ( singular , trimmed ) )
18513	for every part in singular ,	for part in singular :
18514	call the method blankout with 2 arguments : part and STR0 , write the result to out .	out . write ( blankout ( part , STR0 ) )
18515	message_context is None .	message_context = None
18516	intrans is boolean False .	intrans = False
18517	inplural is boolean False .	inplural = False
18518	singular is an empty list .	singular = [ ]
18519	plural is an empty list .	plural = [ ]
18520	otherwise if pluralmatch is true ,	elif pluralmatch :
18521	inplural is boolean True .	inplural = True
18522	if not ,	else :
18523	filemsg is an empty string .	filemsg = STR
18524	if origin is true ,	if origin :
18525	filemsg is a string STR0 , where STR1 is replaced with origin .	filemsg = STR0 % origin
18526	raise an SyntaxError with an argument string STR0 , formated with t.contents , filemsg and t.lineno .	raise SyntaxError ( STR0 % ( t . contents , filemsg , t . lineno ) )
18527	otherwise if t.token_type equals TOKEN_VAR ,	elif t . token_type == TOKEN_VAR :
18528	if inplural is true ,	if inplural :
18529	append string STR0 to plural , where STR1 is replaced with t.contents .	plural . append ( STR0 % t . contents )
18530	if not ,	else :
18531	append string STR0 to singular , where STR1 is replaced with t.contents .	singular . append ( STR0 % t . contents )
18532	if t.token_type == TOKEN_TEXT :	elif t . token_type == TOKEN_TEXT :
18533	call the method one_percent_re.sub with 2 arguments : string STR0 and t.contents , substitute the result for contents .	contents = one_percent_re . sub ( STR0 , t . contents )
18534	if inplural is true ,	if inplural :
18535	append contents to plural .	plural . append ( contents )
18536	if not ,	else :
18537	append contents to singular .	singular . append ( contents )
18538	if not ,	else :
18539	if comment_lineno_cache is not None ,	if comment_lineno_cache is not None :
18540	count occurrences of STR0 in t.contents , add the result to t.lineno , substitute the result for cur_lineno .	cur_lineno = t . lineno + t . contents . count ( STR0 )
18541	if comment_lineno_cache equals cur_lineno .	if comment_lineno_cache == cur_lineno :
18542	if t.token_type is not equal to TOKEN_COMMENT ,	if t . token_type != TOKEN_COMMENT :
18543	for every c in lineno_comment_map dictionary value under the comment_lineno_cache key ,	for c in lineno_comment_map [ comment_lineno_cache ] :
18544	filemsg is an empty string .	filemsg = STR
18545	if origin is true ,	if origin :
18546	filemsg is a string STR0 , where STR1 is replaced with origin .	filemsg = STR0 % origin
18547	warn_msg is a string STR0 , formated with c , filemsg and comment_lineno_cache .	warn_msg = ( STR0 ) % ( c , filemsg , comment_lineno_cache )
18548	call the function warnings.warn with 2 arguments : warn_msg and TranslatorCommentWarning .	warnings . warn ( warn_msg , TranslatorCommentWarning )
18549	value under the comment_lineno_cache key of the lineno_comment_map dictionary is an empty string .	lineno_comment_map [ comment_lineno_cache ] = [ ]
18550	if not ,	else :
18551	join lineno_comment_map dictionary value under the comment_lineno_cache key into a string , separated with STR0 , format with it a string STR1 , write it to out .	out . write ( STR0 % STR1 . join ( lineno_comment_map [ comment_lineno_cache ] ) )
18552	comment_lineno_cache is None ,	comment_lineno_cache = None
18553	if t.token_type equals TOKEN_BLOCK ,	if t . token_type == TOKEN_BLOCK :
18554	call the function inline_re.match with an argument t.contents , substitute the result for imatch .	imatch = inline_re . match ( t . contents )
18555	call the function block_re.match with an argument t.contents , substitute the result for bmatch .	bmatch = block_re . match ( t . contents )
18556	call the function constant_re.findall with an argument t.contents , substitute the result for cmatches .	cmatches = constant_re . findall ( t . contents )
18557	if imatch is true ,	if imatch :
18558	call the method imatch.group with an argument integer 1 , substitute the result for g .	g = imatch . group ( 1 )
18559	if first element of g equals a string STR ,	if g [ 0 ] == STR :
18560	strip g of STR from both ends ,	g = g . strip ( STR )
18561	otherwise if first element of g equals a string STR ,	elif g [ 0 ] == STR :
18562	strip g of STR from both ends ,	g = g . strip ( STR )
18563	call the method one_percent_re.sub with 2 arguments : string STR0 and g , substitute the result for .	g = one_percent_re . sub ( STR0 , g )
18564	call the method imatch.group with an argument integer 1 , if it evaluates to true ,	if imatch . group ( 2 ) :
18565	call the method imatch.group with an argument integer 2 , use the result as an argument for the call to the method context_re.match , substitute the result for context_match .	context_match = context_re . match ( imatch . group ( 2 ) )
18566	call the method context_match.group with an argument integer 1 , substitute the result for message_context .	message_context = context_match . group ( 1 )
18567	if first element of message_context equals to character STR ,	if message_context [ 0 ] == STR :
18568	strip message_context of STR characters from both ends , substitute the result for message_context .	message_context = message_context . strip ( STR )
18569	otherwise if , first element of message_context is equal to STR ,	elif message_context [ 0 ] == STR :
18570	strip message_context of STR characters from both ends , substitute the result for message_context .	message_context = message_context . strip ( STR )
18571	format string STR0 with message_context and g , write it to out .	out . write ( STR0 % ( message_context , g ) )
18572	message_context is None .	message_context = None
18573	if not ,	else :
18574	format string STR0 with g , write it to out .	out . write ( STR0 % g )
18575	otherwise if bmatch is true ,	elif bmatch :
18576	call the method constant_re.findall with an argument t.contents , for every fmatch in the result ,	for fmatch in constant_re . findall ( t . contents ) :
18577	format string STR0 , with fmatch , write it to out .	out . write ( STR0 % fmatch )
18578	call the method bmatch.group with an argument integer 1 , if it evaluates to true ,	if bmatch . group ( 1 ) :
18579	call the method bmatch.group with an argument integer 1 , use the result as an argument for the call to the function context_re.match , substitute the result for context_match .	context_match = context_re . match ( bmatch . group ( 1 ) )
18580	call the method context_match.group with an argument integer 1 , substitute the result for message_context .	message_context = context_match . group ( 1 )
18581	if first element of message_context equals to character STR ,	if message_context [ 0 ] == STR :
18582	strip message_context of STR characters from both ends , substitute the result for message_context .	message_context = message_context . strip ( STR )
18583	otherwise if first element of message_context equals to character STR ,	elif message_context [ 0 ] == STR :
18584	strip message_context of STR characters from both ends , substitute the result for message_context .	message_context = message_context . strip ( STR )
18585	intrans is boolean True .	intrans = True
18586	inplural is boolean False .	inplural = False
18587	if string STR0 is contained in result of the method t.split_contents , trimmed is boolean True , otherwise is boolean False .	trimmed = STR0 in t . split_contents ( )
18588	singular is an empty list .	singular = [ ]
18589	plural is an empty list .	plural = [ ]
18590	otherwise if cmatches is true ,	elif cmatches :
18591	for every cmatch in cmatches ,	for cmatch in cmatches :
18592	format string STR0 , with fmatch , write it to out .	out . write ( STR0 % cmatch )
18593	otherwise if t.contents equals a string STR0 ,	elif t . contents == STR0 :
18594	incomment is boolean True .	incomment = True
18595	if not ,	else :
18596	call the function blankout with 2 arguments : t.contents and STR0 , write the result to out .	out . write ( blankout ( t . contents , STR0 ) )
18597	otherwise if t.token_type equals TOKEN_VAR ,	elif t . token_type == TOKEN_VAR :
18598	split t.contents by STR0 symbol , substitute the result for parts ,	parts = t . contents . split ( STR0 )
18599	call the method constant_re.match with first element of parts as an argument , substitute the result for cmatch .	cmatch = constant_re . match ( parts [ 0 ] )
18600	if cmatch is true ,	if cmatch :
18601	call the method cmatch.group with an argument integer 1 , format with the result string STR0 , write it to out .	out . write ( STR0 % cmatch . group ( 1 ) )
18602	for every p in parts without the first element ,	for p in parts [ 1 : ] :
18603	find index of the occurrence of string STR0 in p , if its greater or equal to integer 0 ,	if p . find ( STR0 ) >= 0 :
18604	split p into two parts at the first STR0 , use the second element of the result to format string STR1 , write it to out .	out . write ( STR0 % p . split ( STR1 , 1 ) [ 1 ] )
18605	if not ,	else :
18606	call the function blankout with 2 arguments : p and STR0 , write the result to out .	out . write ( blankout ( p , STR0 ) )
18607	otherwise if t.token_type equals TOKEN_COMMENT ,	elif t . token_type == TOKEN_COMMENT :
18608	strip t.contents from the left side of whitespaces , if the result starts with TRANSLATOR_COMMENT_MARK ,	if t . contents . lstrip ( ) . startswith ( TRANSLATOR_COMMENT_MARK ) :
18609	call the method lineno_comment_map.setdefault with 2 arguments : t.lineno and an empty list , append t.contents to the result .	lineno_comment_map . setdefault ( t . lineno , [ ] ) . append ( t . contents )
18610	substitute t.lineno for comment_lineno_cache .	comment_lineno_cache = t . lineno
18611	if not ,	else :
18612	call the function blankout with 2 arguments : t.contents and STR0 , write the result to out .	out . write ( blankout ( t . contents , STR0 ) )
18613	call the method out.getvalue , return the result .	return out . getvalue ( )
18614	define the function parse_accept_lang_header with an argument lang_string .	def parse_accept_lang_header ( lang_string ) :
18615	result is an empty list .	result = [ ]
18616	convert lang_string to lowercase , split by the result string accept_language_re , substitute the result for pieces .	pieces = accept_language_re . split ( lang_string . lower ( ) )
18617	if last element of pieces is true ,	if pieces [ - 1 ] :
18618	return an empty list .	return [ ]
18619	for every i in range of integers from integer 0 to the length of pieces decremented by one , with step of integer 3 ,	for i in range ( 0 , len ( pieces ) - 1 , 3 ) :
18620	substitute 3 successive elements starting from the i-th index of pieces for first , lang and priority , respectively .	first , lang , priority = pieces [ i : i + 3 ]
18621	if first is true ,	if first :
18622	return an empty list .	return [ ]
18623	if priority is true ,	if priority :
18624	try ,	try :
18625	convert priority into a floating point integer , substitute it for priority .	priority = float ( priority )
18626	if ValueError exception is caught ,	except ValueError :
18627	return an empty list .	return [ ]
18628	if priority is false ,	if not priority :
18629	priority is floating point number 1.0 .	priority = 1.0
18630	append a tuple with 2 entries lang and priority to result .	result . append ( ( lang , priority ) )
18631	sort result in reversed order by the key as lambda function with an argument k and reeturn value second element of k .	result . sort ( key = lambda k : k [ 1 ] , reverse = True )
18632	return result .	return result
18633	import module copy .	import copy
18634	derive the class Node from object base class .	class Node ( object ) :
18635	default is a string STR0 .	default = STR0
18636	define the method __init__ with 4 arguments : self , children set to None , connector set to None and negated set to boolean False .	def __init__ ( self , children = None , connector = None , negated = False ) :
18637	if children is true , copy children list to self.children , otherwise self.children is an empty list .	self . children = children [ : ] if children else [ ]
18638	if connector is true , substitute it for self.connector , otherwise substitute self.default for self.connector .	self . connector = connector or self . default
18639	substitute negated for self.negated .	self . negated = negated
18640	decorator classmethod ,	@ classmethod
18641	define the method _new_instance with 4 arguments : ( cls , children set to None , connector set to None and negated set to boolean False .	def _new_instance ( cls , children = None , connector = None , negated = False ) :
18642	obj is an instance of Node class , created with 3 arguments : children , connector and negated .	obj = Node ( children , connector , negated )
18643	substitute cls for obj.__class__ .	obj . __class__ = cls
18644	return obj .	return obj
18645	define the method __str__ with an argument self .	def __str__ ( self ) :
18646	if self.negated ,	if self . negated :
18647	return string STR0 , formated with self.connector and string created by joining c into a string , separated by STR1 , for every c in self.children .	return STR0 % ( self . connector , STR1 . join ( [ str ( c ) for c in self . children ] ) )
18648	return string STR0 , formated with self.connector and string created by joining c into a string , separated by STR1 , for every c in self.children .	return STR0 % ( self . connector , STR1 . join ( [ str ( c ) for c in self . children ] ) )
18649	define the method __repr__ with an argument self .	def __repr__ ( self ) :
18650	return string STR0 , formated with self.__class__.__name__ and self .	return STR0 % ( self . __class__ . __name__ , self )
18651	define the method __deepcopy__ with 2 arguments : self and memodict .	def __deepcopy__ ( self , memodict ) :
18652	obj is an instance of Node class , created with 2 arguments : connector set to self.connector and negated set to self.negated .	obj = Node ( connector = self . connector , negated = self . negated )
18653	substitute self.__class__ for obj.__class__ .	obj . __class__ = self . __class__
18654	call the function copy.deepcopy with 2 arguments : self.children and memodict , substitute the result for obj.children .	obj . children = copy . deepcopy ( self . children , memodict )
18655	return obj .	return obj
18656	define the method __len__ with an argument self .	def __len__ ( self ) :
18657	return the length of self.children .	return len ( self . children )
18658	define the method __bool__ with an argument self .	def __bool__ ( self ) :
18659	convert self.children into an boolean , return it .	return bool ( self . children )
18660	define the method __nonzero__ with an argument self .	def __nonzero__ ( self ) :
18661	get the type of the self object , on the result call the __bool__ method with an argument self , return the result .	return type ( self ) . __bool__ ( self )
18662	define the method __contains__ with 2 arguments : self and other .	def __contains__ ( self , other ) :
18663	if other is contained in self.children , return boolean True , otherwise return boolean False .	return other in self . children
18664	define the method _prepare_data with 2 arguments : self and data .	def _prepare_data ( self , data ) :
18665	return data .	return data
18666	define the method add with 4 arguments : self , data , conn_type and squash set to boolean True .	def add ( self , data , conn_type , squash = True ) :
18667	if data is contained in self.children ,	if data in self . children :
18668	return data .	return data
18669	call the method self._prepare_data with an argument data , substitute the result for data .	data = self . _prepare_data ( data )
18670	if squash is false ,	if not squash :
18671	append data to self.children .	self . children . append ( data )
18672	return data .	return data
18673	if self.connector equals conn_type ,	if self . connector == conn_type :
18674	if data is instance of Node and data.negated is false , and if data.connector equals conn_type or length of data equals integer 1 ,	if ( isinstance ( data , Node ) and not data . negated and ( data . connector == conn_type or len ( data ) == 1 ) ) :
18675	extend self.children list with data.children .	self . children . extend ( data . children )
18676	return self .	return self
18677	if not ,	else :
18678	append data to self.children .	self . children . append ( data )
18679	return data .	return data
18680	if not ,	else :
18681	call the method self._new_instance with 3 arguments : self.children , self.connector and self.negated , substitute the result for obj .	obj = self . _new_instance ( self . children , self . connector , self . negated )
18682	substitute conn_type for self.connector .	self . connector = conn_type
18683	self.children is an list with 2 elements : obj and data .	self . children = [ obj , data ]
18684	return data .	return data
18685	define the method negate with an argument self .	def negate ( self ) :
18686	invert self.negated .	self . negated = not self . negated
18687	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
18688	from datetime import timedelta and tzinfo into default name space .	from datetime import timedelta , tzinfo
18689	import module time .	import time
18690	import module warnings .	import warnings
18691	from django.utils.deprecation import RemovedInDjango19Warning into default name space .	from django . utils . deprecation import RemovedInDjango19Warning
18692	from django.utils.encoding import force_str , force_text and DEFAULT_LOCALE_ENCODING into default name space .	from django . utils . encoding import force_str , force_text , DEFAULT_LOCALE_ENCODING
18693	call the function warnings.warn with 3 arguments : string STR0 , RemovedInDjango19Warning and stacklevel set to 2 .	warnings . warn ( STR0 , RemovedInDjango19Warning , stacklevel = 2 )
18694	derive the class FixedOffset from the tzinfo base class .	class FixedOffset ( tzinfo ) :
18695	define the method __init__ with 2 arguments : self and offset .	def __init__ ( self , offset ) :
18696	call the function warnings.warn with 2 arguments : STR0 and RemovedInDjango19Warning .	warnings . warn ( STR0 , RemovedInDjango19Warning )
18697	if offset is an instance of timedelta class ,	if isinstance ( offset , timedelta ) :
18698	substitute offset for self.__offset .	self . __offset = offset
18699	substitute self.__offset.seconds for offset .	offset = self . __offset . seconds // 60
18700	if not ,	else :
18701	call the function timedelta with an argument minutes set to offset , substitute the result for self.__offset .	self . __offset = timedelta ( minutes = offset )
18702	if offset is lesser than integer 0 , sign is set to STR0 , otherwise sign is STR1 ,	sign = STR0 if offset < 0 else STR1
18703	self.__name is a string STR0 , replace STR1 with sign , STR2 is replaced with absolute value of offset divided by 60 , and placed into 2 character spaces , and STR3 is replaced with reminder of the division of absolute offset by integer 60 , and placed into 2 character spaces .	self . __name = STR0 % ( sign , abs ( offset ) / 60. , abs ( offset ) % 60 )
18704	define the method __repr__ with an argument self .	def __repr__ ( self ) :
18705	return self.__name .	return self . __name
18706	define the method __getinitargs__ with an argument self .	def __getinitargs__ ( self ) :
18707	return a tuple with an element self.__offset .	return self . __offset ,
18708	define the method utcoffset with 2 arguments self and dt .	def utcoffset ( self , dt ) :
18709	return self.__offset .	return self . __offset
18710	define the method tzname with 2 arguments self and dt .	def tzname ( self , dt ) :
18711	return self.__name .	return self . __name
18712	define the method dst with 2 arguments self and dt .	def dst ( self , dt ) :
18713	call the function timedelta with an argument integer 0 , return the result .	return timedelta ( 0 )
18714	derive the class LocalTimezone from the tzinfo base class .	class LocalTimezone ( tzinfo ) :
18715	define the method __init__ with 2 arguments self and dt .	def __init__ ( self , dt ) :
18716	call the function warnings.warn with 2 arguments : string STR0 and RemovedInDjango19Warning .	warnings . warn ( STR0 , RemovedInDjango19Warning )
18717	call the method tzinfo.__init__ with an argument self .	tzinfo . __init__ ( self )
18718	substitute dt for self.__dt .	self . __dt = dt
18719	call the method self.tzname with an argument dt , substitute the result for self._tzname .	self . _tzname = self . tzname ( dt )
18720	define the method __repr__ with an argument self .	def __repr__ ( self ) :
18721	call the function force_str with an argument self._tzname , return the result .	return force_str ( self . _tzname )
18722	define the method __getinitargs__ with an argument self .	def __getinitargs__ ( self ) :
18723	return a tuple with an element self.__dt .	return self . __dt ,
18724	define the method utcoffset with 2 arguments self and dt .	def utcoffset ( self , dt ) :
18725	call the nethod self._isdst with an argument dt , if it evaluates to true ,	if self . _isdst ( dt ) :
18726	call the function timedelta with an argument seconds as negative time.altzone , return the result .	return timedelta ( seconds = - time . altzone )
18727	if not ,	else :
18728	call the function timedelta with an argument seconds as negative time.timezone , return the result .	return timedelta ( seconds = - time . timezone )
18729	define the method dst with 2 arguments self and dt .	def dst ( self , dt ) :
18730	call the nethod self._isdst with an argument dt , if it evaluates to true ,	if self . _isdst ( dt ) :
18731	call the function timedelta with an argument seconds as negative time.timezone , subtract the result from the result of the call , to the function timedelta called with an argument seconds as negative time.altzone , return the result .	return timedelta ( seconds = - time . altzone ) - timedelta ( seconds = - time . timezone )
18732	if not ,	else :
18733	call the function timedelta with an argument integer 0 , return the result .	return timedelta ( 0 )
18734	define the method tzname with 2 arguments self and dt .	def tzname ( self , dt ) :
18735	if dt is None is_dst is boolean False , otherwise call the method self._isdst with an argument dt , substitute the result for is_dst .	is_dst = False if dt is None else self . _isdst ( dt )
18736	try ,	try :
18737	call the function force_text with 2 arguments : value under the is_dst key of the time.tzname and DEFAULT_LOCALE_ENCODING , return the result .	return force_text ( time . tzname [ is_dst ] , DEFAULT_LOCALE_ENCODING )
18738	if UnicodeDecodeError exception is caught ,	except UnicodeDecodeError :
18739	return None .	return None
18740	define the method _isdst with 2 arguments self and dt .	def _isdst ( self , dt ) :
18741	tt is an tuple with 9 elements : dt.year , dt.month , dt.day , dt.hour , dt.minute , dt.second , result of the function dt.weekday , integer 0 and integer 0 .	tt = ( dt . year , dt . month , dt . day , dt . hour , dt . minute , dt . second , dt . weekday ( ) , 0 , 0 )
18742	try ,	try :
18743	call the method time.mktime with an argument tt , substitute the result for stamp .	stamp = time . mktime ( tt )
18744	if OverflowError or ValueError exceptions are caught ,	except ( OverflowError , ValueError ) :
18745	create a tuple out a tuple with an element integer 2037 and a list tt elements without the first element , substitute the result for tt .	tt = ( 2037 , ) + tt [ 1 : ]
18746	call the method time.mktime with an argument tt , substitute the result for stamp .	stamp = time . mktime ( tt )
18747	call the method time.localtime with an argument stamp , substitute the result for tt .	tt = time . localtime ( stamp )
18748	if tt.tm_isdst is greater than intger 0 , return boolean True , otherwise return boolean False .	return tt . tm_isdst > 0
18749	from __future__ import absolute_import into default name space .	from __future__ import absolute_import
18750	import module warnings .	import warnings
18751	from django.utils.deprecation import RemovedInDjango19Warning into default name space .	from django . utils . deprecation import RemovedInDjango19Warning
18752	call the function warnings.warn with 3 arguments : string STR0 , RemovedInDjango19Warning and stacklevel as integer 2 .	warnings . warn ( STR0 , RemovedInDjango19Warning , stacklevel = 2 )
18753	try ,	try :
18754	from unittest2 import everything .	from unittest2 import *
18755	if ImportError exception is caught ,	except ImportError :
18756	from unittest import import everything .	from unittest import *
18757	from __future__ import unicode_literals into default name space .	from __future__ import unicode_literals
18758	import module datetime .	import datetime
18759	import module os .	import os
18760	import module subprocess .	import subprocess
18761	define the function get_version with version set to None as argument .	def get_version ( version = None ) :
18762	call the get_complete_version function with version as argument , store the result in version .	version = get_complete_version ( version )
18763	call the get_major_version wit version as argument , store the result in major .	major = get_major_version ( version )
18764	sub is an empty string .	sub = STR
18765	if fourth element of version equals to string STR0 and fight element of version equals to integer 0 ,	if version [ 3 ] == STR0 and version [ 4 ] == 0 :
18766	call the function get_git_changeset , store the result in git_changeset .	git_changeset = get_git_changeset ( )
18767	if git_changeset is true ,	if git_changeset :
18768	convert git_changeset to string , append it to the string STR0 , replace it for sub .	sub = STR0 % git_changeset
18769	otherwise if fourth element of version does not equals to STR0 ,	elif version [ 3 ] != STR0 :
18770	mapping is a dictionary with 3 initial entries : STR0 for STR1 , STR for STR2 and STR3 for STR4 .	mapping = { STR0 : STR1 , STR2 : STR , STR3 : STR4 }
18771	use fourth element of version as a key to get the value from mapping dictionary , append to it fourth element of version converted to string , substitute it for sub .	sub = mapping [ version [ 3 ] ] + str ( version [ 4 ] )
18772	sum major and sub , return the result converted to string .	return str ( major + sub )
18773	define the function get_major_version with an argument version defaulting to None .	def get_major_version ( version = None ) :
18774	call the get_complete_version with an argument version , store the result in version .	version = get_complete_version ( version )
18775	assign integer 2 to parts if third element of version equals to zero , otherwise assign it integer 3 .	parts = 2 if version [ 2 ] == 0 else 3
18776	convert x into a string for every x in list of version elements up to the parts index , join the previous into a string separated by STR0 , assign the result to major .	major = STR0 . join ( str ( x ) for x in version [ : parts ] )
18777	return major .	return major
18778	define the function get_complete_version with in argument version , defaulting to None .	def get_complete_version ( version = None ) :
18779	if version is None ,	if version is None :
18780	from django import VERSION as version into default name space .	from django import VERSION as version
18781	if not ,	else :
18782	if length of version does not equals to integer 5 , raise an exception .	assert len ( version ) == 5
18783	if fourth element of version does not equals to string STR0 or STR1 or STR2 or STR3 , raise an exception .	assert version [ 3 ] in ( STR0 , STR1 , STR2 , STR3 )
18784	return version	return version
18785	define the function get_git_changeset .	def get_git_changeset ( ) :
18786	if get_git_changeset has an attribute STR0 ,	if hasattr ( get_git_changeset , STR0 ) :
18787	return get_git_changeset.cache .	return get_git_changeset . cache
18788	get the absolute path of the __file__ , repo_dir is name of the directory two leveles above it .	repo_dir = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) )
18789	call the subprocess.Popen function with , STR0 , stdout set to subprocess.PIPE , stderr set to subprocess.PIPE , shell set to boolean True , cwd set to repo_dir and universal_newlines set to boolean True , as arguments , substitute the result for git_log .	git_log = subprocess . Popen ( STR0 , stdout = subprocess . PIPE , stderr = subprocess . PIPE , shell = True , cwd = repo_dir , universal_newlines = True )
18790	evaluate the method git_log.communicate , substitute first element of the result for timestamp .	timestamp = git_log . communicate ( ) [ 0 ]
18791	try	try :
18792	call the datetime.datetime.utcfromtimestamp with timestamp converted to an integer as argument , substitute result for timestamp .	timestamp = datetime . datetime . utcfromtimestamp ( int ( timestamp ) )
18793	if ValueError exception is caught ,	except ValueError :
18794	changeset is None .	changeset = None
18795	if not ,	else :
18796	call the timestamp.strftime with string STR0 as an argument , substitute the result for changeset .	changeset = timestamp . strftime ( STR0 )
18797	substitute changeset for get_git_changeset.cache .	get_git_changeset . cache = changeset
18798	return changeset .	return changeset
18799	from xml.sax.saxutils import XMLGenerator into default name space .	from xml . sax . saxutils import XMLGenerator
18800	derive the class SimplerXMLGenerator form the XMLGenerator base class .	class SimplerXMLGenerator ( XMLGenerator ) :
18801	define the method addQuickElement with 4 arguments : self , name , contents set to None and attrs set to None .	def addQuickElement ( self , name , contents = None , attrs = None ) :
18802	if attrs is None ,	if attrs is None :
18803	attrs is an empty dictionary .	attrs = { }
18804	cal the method self.startElement with 2 arguments : name and attrs .	self . startElement ( name , attrs )
18805	if contents is not None ,	if contents is not None :
18806	call the method self.characters with an argument contents .	self . characters ( contents )
18807	call the method self.endElement with an argument name .	self . endElement ( name )